/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsantoshbaral%2FDocuments%2FREVX%2Fhelpdex%2Fspu-ai%2Fapp%2Fcomponents%2FSpeechSetup.tsx&modules=%2FUsers%2Fsantoshbaral%2FDocuments%2FREVX%2Fhelpdex%2Fspu-ai%2Fapp%2Fpage.client.tsx&modules=%2FUsers%2Fsantoshbaral%2FDocuments%2FREVX%2Fhelpdex%2Fspu-ai%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fscript.js&modules=%2FUsers%2Fsantoshbaral%2FDocuments%2FREVX%2Fhelpdex%2Fspu-ai%2Fnode_modules%2Fnext%2Fdist%2Fshared%2Flib%2Flazy-dynamic%2Fdynamic-bailout-to-csr.js&server=false!":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsantoshbaral%2FDocuments%2FREVX%2Fhelpdex%2Fspu-ai%2Fapp%2Fcomponents%2FSpeechSetup.tsx&modules=%2FUsers%2Fsantoshbaral%2FDocuments%2FREVX%2Fhelpdex%2Fspu-ai%2Fapp%2Fpage.client.tsx&modules=%2FUsers%2Fsantoshbaral%2FDocuments%2FREVX%2Fhelpdex%2Fspu-ai%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fscript.js&modules=%2FUsers%2Fsantoshbaral%2FDocuments%2FREVX%2Fhelpdex%2Fspu-ai%2Fnode_modules%2Fnext%2Fdist%2Fshared%2Flib%2Flazy-dynamic%2Fdynamic-bailout-to-csr.js&server=false! ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/components/SpeechSetup.tsx */ \"(app-pages-browser)/./app/components/SpeechSetup.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/page.client.tsx */ \"(app-pages-browser)/./app/page.client.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/script.js */ \"(app-pages-browser)/./node_modules/next/dist/client/script.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZVc2VycyUyRnNhbnRvc2hiYXJhbCUyRkRvY3VtZW50cyUyRlJFVlglMkZoZWxwZGV4JTJGc3B1LWFpJTJGYXBwJTJGY29tcG9uZW50cyUyRlNwZWVjaFNldHVwLnRzeCZtb2R1bGVzPSUyRlVzZXJzJTJGc2FudG9zaGJhcmFsJTJGRG9jdW1lbnRzJTJGUkVWWCUyRmhlbHBkZXglMkZzcHUtYWklMkZhcHAlMkZwYWdlLmNsaWVudC50c3gmbW9kdWxlcz0lMkZVc2VycyUyRnNhbnRvc2hiYXJhbCUyRkRvY3VtZW50cyUyRlJFVlglMkZoZWxwZGV4JTJGc3B1LWFpJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZzY3JpcHQuanMmbW9kdWxlcz0lMkZVc2VycyUyRnNhbnRvc2hiYXJhbCUyRkRvY3VtZW50cyUyRlJFVlglMkZoZWxwZGV4JTJGc3B1LWFpJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZzaGFyZWQlMkZsaWIlMkZsYXp5LWR5bmFtaWMlMkZkeW5hbWljLWJhaWxvdXQtdG8tY3NyLmpzJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsMExBQXFIO0FBQ3JILG9LQUEwRztBQUMxRyxrTkFBOEg7QUFDOUgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz9kMDY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL3NhbnRvc2hiYXJhbC9Eb2N1bWVudHMvUkVWWC9oZWxwZGV4L3NwdS1haS9hcHAvY29tcG9uZW50cy9TcGVlY2hTZXR1cC50c3hcIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9zYW50b3NoYmFyYWwvRG9jdW1lbnRzL1JFVlgvaGVscGRleC9zcHUtYWkvYXBwL3BhZ2UuY2xpZW50LnRzeFwiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL3NhbnRvc2hiYXJhbC9Eb2N1bWVudHMvUkVWWC9oZWxwZGV4L3NwdS1haS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9zY3JpcHQuanNcIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9zYW50b3NoYmFyYWwvRG9jdW1lbnRzL1JFVlgvaGVscGRleC9zcHUtYWkvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2xhenktZHluYW1pYy9keW5hbWljLWJhaWxvdXQtdG8tY3NyLmpzXCIpIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsantoshbaral%2FDocuments%2FREVX%2Fhelpdex%2Fspu-ai%2Fapp%2Fcomponents%2FSpeechSetup.tsx&modules=%2FUsers%2Fsantoshbaral%2FDocuments%2FREVX%2Fhelpdex%2Fspu-ai%2Fapp%2Fpage.client.tsx&modules=%2FUsers%2Fsantoshbaral%2FDocuments%2FREVX%2Fhelpdex%2Fspu-ai%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fscript.js&modules=%2FUsers%2Fsantoshbaral%2FDocuments%2FREVX%2Fhelpdex%2Fspu-ai%2Fnode_modules%2Fnext%2Fdist%2Fshared%2Flib%2Flazy-dynamic%2Fdynamic-bailout-to-csr.js&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/copy-to-clipboard/index.js":
/*!*************************************************!*\
  !*** ./node_modules/copy-to-clipboard/index.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar deselectCurrent = __webpack_require__(/*! toggle-selection */ \"(app-pages-browser)/./node_modules/toggle-selection/index.js\");\nvar clipboardToIE11Formatting = {\n    \"text/plain\": \"Text\",\n    \"text/html\": \"Url\",\n    \"default\": \"Text\"\n};\nvar defaultMessage = \"Copy to clipboard: #{key}, Enter\";\nfunction format(message) {\n    var copyKey = (/mac os x/i.test(navigator.userAgent) ? \"âŒ˜\" : \"Ctrl\") + \"+C\";\n    return message.replace(/#{\\s*key\\s*}/g, copyKey);\n}\nfunction copy(text, options) {\n    var debug, message, reselectPrevious, range, selection, mark, success = false;\n    if (!options) {\n        options = {};\n    }\n    debug = options.debug || false;\n    try {\n        reselectPrevious = deselectCurrent();\n        range = document.createRange();\n        selection = document.getSelection();\n        mark = document.createElement(\"span\");\n        mark.textContent = text;\n        // avoid screen readers from reading out loud the text\n        mark.ariaHidden = \"true\";\n        // reset user styles for span element\n        mark.style.all = \"unset\";\n        // prevents scrolling to the end of the page\n        mark.style.position = \"fixed\";\n        mark.style.top = 0;\n        mark.style.clip = \"rect(0, 0, 0, 0)\";\n        // used to preserve spaces and line breaks\n        mark.style.whiteSpace = \"pre\";\n        // do not inherit user-select (it may be `none`)\n        mark.style.webkitUserSelect = \"text\";\n        mark.style.MozUserSelect = \"text\";\n        mark.style.msUserSelect = \"text\";\n        mark.style.userSelect = \"text\";\n        mark.addEventListener(\"copy\", function(e) {\n            e.stopPropagation();\n            if (options.format) {\n                e.preventDefault();\n                if (typeof e.clipboardData === \"undefined\") {\n                    debug && console.warn(\"unable to use e.clipboardData\");\n                    debug && console.warn(\"trying IE specific stuff\");\n                    window.clipboardData.clearData();\n                    var format = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting[\"default\"];\n                    window.clipboardData.setData(format, text);\n                } else {\n                    e.clipboardData.clearData();\n                    e.clipboardData.setData(options.format, text);\n                }\n            }\n            if (options.onCopy) {\n                e.preventDefault();\n                options.onCopy(e.clipboardData);\n            }\n        });\n        document.body.appendChild(mark);\n        range.selectNodeContents(mark);\n        selection.addRange(range);\n        var successful = document.execCommand(\"copy\");\n        if (!successful) {\n            throw new Error(\"copy command was unsuccessful\");\n        }\n        success = true;\n    } catch (err) {\n        debug && console.error(\"unable to copy using execCommand: \", err);\n        debug && console.warn(\"trying IE specific stuff\");\n        try {\n            window.clipboardData.setData(options.format || \"text\", text);\n            options.onCopy && options.onCopy(window.clipboardData);\n            success = true;\n        } catch (err) {\n            debug && console.error(\"unable to copy using clipboardData: \", err);\n            debug && console.error(\"falling back to prompt\");\n            message = format(\"message\" in options ? options.message : defaultMessage);\n            window.prompt(message, text);\n        }\n    } finally{\n        if (selection) {\n            if (typeof selection.removeRange == \"function\") {\n                selection.removeRange(range);\n            } else {\n                selection.removeAllRanges();\n            }\n        }\n        if (mark) {\n            document.body.removeChild(mark);\n        }\n        reselectPrevious();\n    }\n    return success;\n}\nmodule.exports = copy;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb3B5LXRvLWNsaXBib2FyZC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUlBLGtCQUFrQkMsbUJBQU9BLENBQUMsc0ZBQWtCO0FBRWhELElBQUlDLDRCQUE0QjtJQUM5QixjQUFjO0lBQ2QsYUFBYTtJQUNiLFdBQVc7QUFDYjtBQUVBLElBQUlDLGlCQUFpQjtBQUVyQixTQUFTQyxPQUFPQyxPQUFPO0lBQ3JCLElBQUlDLFVBQVUsQ0FBQyxZQUFZQyxJQUFJLENBQUNDLFVBQVVDLFNBQVMsSUFBSSxNQUFNLE1BQUssSUFBSztJQUN2RSxPQUFPSixRQUFRSyxPQUFPLENBQUMsaUJBQWlCSjtBQUMxQztBQUVBLFNBQVNLLEtBQUtDLElBQUksRUFBRUMsT0FBTztJQUN6QixJQUFJQyxPQUNGVCxTQUNBVSxrQkFDQUMsT0FDQUMsV0FDQUMsTUFDQUMsVUFBVTtJQUNaLElBQUksQ0FBQ04sU0FBUztRQUNaQSxVQUFVLENBQUM7SUFDYjtJQUNBQyxRQUFRRCxRQUFRQyxLQUFLLElBQUk7SUFDekIsSUFBSTtRQUNGQyxtQkFBbUJmO1FBRW5CZ0IsUUFBUUksU0FBU0MsV0FBVztRQUM1QkosWUFBWUcsU0FBU0UsWUFBWTtRQUVqQ0osT0FBT0UsU0FBU0csYUFBYSxDQUFDO1FBQzlCTCxLQUFLTSxXQUFXLEdBQUdaO1FBQ25CLHNEQUFzRDtRQUN0RE0sS0FBS08sVUFBVSxHQUFHO1FBQ2xCLHFDQUFxQztRQUNyQ1AsS0FBS1EsS0FBSyxDQUFDQyxHQUFHLEdBQUc7UUFDakIsNENBQTRDO1FBQzVDVCxLQUFLUSxLQUFLLENBQUNFLFFBQVEsR0FBRztRQUN0QlYsS0FBS1EsS0FBSyxDQUFDRyxHQUFHLEdBQUc7UUFDakJYLEtBQUtRLEtBQUssQ0FBQ0ksSUFBSSxHQUFHO1FBQ2xCLDBDQUEwQztRQUMxQ1osS0FBS1EsS0FBSyxDQUFDSyxVQUFVLEdBQUc7UUFDeEIsZ0RBQWdEO1FBQ2hEYixLQUFLUSxLQUFLLENBQUNNLGdCQUFnQixHQUFHO1FBQzlCZCxLQUFLUSxLQUFLLENBQUNPLGFBQWEsR0FBRztRQUMzQmYsS0FBS1EsS0FBSyxDQUFDUSxZQUFZLEdBQUc7UUFDMUJoQixLQUFLUSxLQUFLLENBQUNTLFVBQVUsR0FBRztRQUN4QmpCLEtBQUtrQixnQkFBZ0IsQ0FBQyxRQUFRLFNBQVNDLENBQUM7WUFDdENBLEVBQUVDLGVBQWU7WUFDakIsSUFBSXpCLFFBQVFULE1BQU0sRUFBRTtnQkFDbEJpQyxFQUFFRSxjQUFjO2dCQUNoQixJQUFJLE9BQU9GLEVBQUVHLGFBQWEsS0FBSyxhQUFhO29CQUMxQzFCLFNBQVMyQixRQUFRQyxJQUFJLENBQUM7b0JBQ3RCNUIsU0FBUzJCLFFBQVFDLElBQUksQ0FBQztvQkFDdEJDLE9BQU9ILGFBQWEsQ0FBQ0ksU0FBUztvQkFDOUIsSUFBSXhDLFNBQVNGLHlCQUF5QixDQUFDVyxRQUFRVCxNQUFNLENBQUMsSUFBSUYseUJBQXlCLENBQUMsVUFBVTtvQkFDOUZ5QyxPQUFPSCxhQUFhLENBQUNLLE9BQU8sQ0FBQ3pDLFFBQVFRO2dCQUN2QyxPQUFPO29CQUNMeUIsRUFBRUcsYUFBYSxDQUFDSSxTQUFTO29CQUN6QlAsRUFBRUcsYUFBYSxDQUFDSyxPQUFPLENBQUNoQyxRQUFRVCxNQUFNLEVBQUVRO2dCQUMxQztZQUNGO1lBQ0EsSUFBSUMsUUFBUWlDLE1BQU0sRUFBRTtnQkFDbEJULEVBQUVFLGNBQWM7Z0JBQ2hCMUIsUUFBUWlDLE1BQU0sQ0FBQ1QsRUFBRUcsYUFBYTtZQUNoQztRQUNGO1FBRUFwQixTQUFTMkIsSUFBSSxDQUFDQyxXQUFXLENBQUM5QjtRQUUxQkYsTUFBTWlDLGtCQUFrQixDQUFDL0I7UUFDekJELFVBQVVpQyxRQUFRLENBQUNsQztRQUVuQixJQUFJbUMsYUFBYS9CLFNBQVNnQyxXQUFXLENBQUM7UUFDdEMsSUFBSSxDQUFDRCxZQUFZO1lBQ2YsTUFBTSxJQUFJRSxNQUFNO1FBQ2xCO1FBQ0FsQyxVQUFVO0lBQ1osRUFBRSxPQUFPbUMsS0FBSztRQUNaeEMsU0FBUzJCLFFBQVFjLEtBQUssQ0FBQyxzQ0FBc0NEO1FBQzdEeEMsU0FBUzJCLFFBQVFDLElBQUksQ0FBQztRQUN0QixJQUFJO1lBQ0ZDLE9BQU9ILGFBQWEsQ0FBQ0ssT0FBTyxDQUFDaEMsUUFBUVQsTUFBTSxJQUFJLFFBQVFRO1lBQ3ZEQyxRQUFRaUMsTUFBTSxJQUFJakMsUUFBUWlDLE1BQU0sQ0FBQ0gsT0FBT0gsYUFBYTtZQUNyRHJCLFVBQVU7UUFDWixFQUFFLE9BQU9tQyxLQUFLO1lBQ1p4QyxTQUFTMkIsUUFBUWMsS0FBSyxDQUFDLHdDQUF3Q0Q7WUFDL0R4QyxTQUFTMkIsUUFBUWMsS0FBSyxDQUFDO1lBQ3ZCbEQsVUFBVUQsT0FBTyxhQUFhUyxVQUFVQSxRQUFRUixPQUFPLEdBQUdGO1lBQzFEd0MsT0FBT2EsTUFBTSxDQUFDbkQsU0FBU087UUFDekI7SUFDRixTQUFVO1FBQ1IsSUFBSUssV0FBVztZQUNiLElBQUksT0FBT0EsVUFBVXdDLFdBQVcsSUFBSSxZQUFZO2dCQUM5Q3hDLFVBQVV3QyxXQUFXLENBQUN6QztZQUN4QixPQUFPO2dCQUNMQyxVQUFVeUMsZUFBZTtZQUMzQjtRQUNGO1FBRUEsSUFBSXhDLE1BQU07WUFDUkUsU0FBUzJCLElBQUksQ0FBQ1ksV0FBVyxDQUFDekM7UUFDNUI7UUFDQUg7SUFDRjtJQUVBLE9BQU9JO0FBQ1Q7QUFFQXlDLE9BQU9DLE9BQU8sR0FBR2xEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb3B5LXRvLWNsaXBib2FyZC9pbmRleC5qcz9jNGNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZGVzZWxlY3RDdXJyZW50ID0gcmVxdWlyZShcInRvZ2dsZS1zZWxlY3Rpb25cIik7XG5cbnZhciBjbGlwYm9hcmRUb0lFMTFGb3JtYXR0aW5nID0ge1xuICBcInRleHQvcGxhaW5cIjogXCJUZXh0XCIsXG4gIFwidGV4dC9odG1sXCI6IFwiVXJsXCIsXG4gIFwiZGVmYXVsdFwiOiBcIlRleHRcIlxufVxuXG52YXIgZGVmYXVsdE1lc3NhZ2UgPSBcIkNvcHkgdG8gY2xpcGJvYXJkOiAje2tleX0sIEVudGVyXCI7XG5cbmZ1bmN0aW9uIGZvcm1hdChtZXNzYWdlKSB7XG4gIHZhciBjb3B5S2V5ID0gKC9tYWMgb3MgeC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgPyBcIuKMmFwiIDogXCJDdHJsXCIpICsgXCIrQ1wiO1xuICByZXR1cm4gbWVzc2FnZS5yZXBsYWNlKC8je1xccyprZXlcXHMqfS9nLCBjb3B5S2V5KTtcbn1cblxuZnVuY3Rpb24gY29weSh0ZXh0LCBvcHRpb25zKSB7XG4gIHZhciBkZWJ1ZyxcbiAgICBtZXNzYWdlLFxuICAgIHJlc2VsZWN0UHJldmlvdXMsXG4gICAgcmFuZ2UsXG4gICAgc2VsZWN0aW9uLFxuICAgIG1hcmssXG4gICAgc3VjY2VzcyA9IGZhbHNlO1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgZGVidWcgPSBvcHRpb25zLmRlYnVnIHx8IGZhbHNlO1xuICB0cnkge1xuICAgIHJlc2VsZWN0UHJldmlvdXMgPSBkZXNlbGVjdEN1cnJlbnQoKTtcblxuICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcblxuICAgIG1hcmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBtYXJrLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAvLyBhdm9pZCBzY3JlZW4gcmVhZGVycyBmcm9tIHJlYWRpbmcgb3V0IGxvdWQgdGhlIHRleHRcbiAgICBtYXJrLmFyaWFIaWRkZW4gPSBcInRydWVcIlxuICAgIC8vIHJlc2V0IHVzZXIgc3R5bGVzIGZvciBzcGFuIGVsZW1lbnRcbiAgICBtYXJrLnN0eWxlLmFsbCA9IFwidW5zZXRcIjtcbiAgICAvLyBwcmV2ZW50cyBzY3JvbGxpbmcgdG8gdGhlIGVuZCBvZiB0aGUgcGFnZVxuICAgIG1hcmsuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgbWFyay5zdHlsZS50b3AgPSAwO1xuICAgIG1hcmsuc3R5bGUuY2xpcCA9IFwicmVjdCgwLCAwLCAwLCAwKVwiO1xuICAgIC8vIHVzZWQgdG8gcHJlc2VydmUgc3BhY2VzIGFuZCBsaW5lIGJyZWFrc1xuICAgIG1hcmsuc3R5bGUud2hpdGVTcGFjZSA9IFwicHJlXCI7XG4gICAgLy8gZG8gbm90IGluaGVyaXQgdXNlci1zZWxlY3QgKGl0IG1heSBiZSBgbm9uZWApXG4gICAgbWFyay5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gXCJ0ZXh0XCI7XG4gICAgbWFyay5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gXCJ0ZXh0XCI7XG4gICAgbWFyay5zdHlsZS5tc1VzZXJTZWxlY3QgPSBcInRleHRcIjtcbiAgICBtYXJrLnN0eWxlLnVzZXJTZWxlY3QgPSBcInRleHRcIjtcbiAgICBtYXJrLmFkZEV2ZW50TGlzdGVuZXIoXCJjb3B5XCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBpZiAob3B0aW9ucy5mb3JtYXQpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAodHlwZW9mIGUuY2xpcGJvYXJkRGF0YSA9PT0gXCJ1bmRlZmluZWRcIikgeyAvLyBJRSAxMVxuICAgICAgICAgIGRlYnVnICYmIGNvbnNvbGUud2FybihcInVuYWJsZSB0byB1c2UgZS5jbGlwYm9hcmREYXRhXCIpO1xuICAgICAgICAgIGRlYnVnICYmIGNvbnNvbGUud2FybihcInRyeWluZyBJRSBzcGVjaWZpYyBzdHVmZlwiKTtcbiAgICAgICAgICB3aW5kb3cuY2xpcGJvYXJkRGF0YS5jbGVhckRhdGEoKTtcbiAgICAgICAgICB2YXIgZm9ybWF0ID0gY2xpcGJvYXJkVG9JRTExRm9ybWF0dGluZ1tvcHRpb25zLmZvcm1hdF0gfHwgY2xpcGJvYXJkVG9JRTExRm9ybWF0dGluZ1tcImRlZmF1bHRcIl1cbiAgICAgICAgICB3aW5kb3cuY2xpcGJvYXJkRGF0YS5zZXREYXRhKGZvcm1hdCwgdGV4dCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIGFsbCBvdGhlciBicm93c2Vyc1xuICAgICAgICAgIGUuY2xpcGJvYXJkRGF0YS5jbGVhckRhdGEoKTtcbiAgICAgICAgICBlLmNsaXBib2FyZERhdGEuc2V0RGF0YShvcHRpb25zLmZvcm1hdCwgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm9uQ29weSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG9wdGlvbnMub25Db3B5KGUuY2xpcGJvYXJkRGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG1hcmspO1xuXG4gICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG1hcmspO1xuICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG5cbiAgICB2YXIgc3VjY2Vzc2Z1bCA9IGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiY29weVwiKTtcbiAgICBpZiAoIXN1Y2Nlc3NmdWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNvcHkgY29tbWFuZCB3YXMgdW5zdWNjZXNzZnVsXCIpO1xuICAgIH1cbiAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVidWcgJiYgY29uc29sZS5lcnJvcihcInVuYWJsZSB0byBjb3B5IHVzaW5nIGV4ZWNDb21tYW5kOiBcIiwgZXJyKTtcbiAgICBkZWJ1ZyAmJiBjb25zb2xlLndhcm4oXCJ0cnlpbmcgSUUgc3BlY2lmaWMgc3R1ZmZcIik7XG4gICAgdHJ5IHtcbiAgICAgIHdpbmRvdy5jbGlwYm9hcmREYXRhLnNldERhdGEob3B0aW9ucy5mb3JtYXQgfHwgXCJ0ZXh0XCIsIHRleHQpO1xuICAgICAgb3B0aW9ucy5vbkNvcHkgJiYgb3B0aW9ucy5vbkNvcHkod2luZG93LmNsaXBib2FyZERhdGEpO1xuICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBkZWJ1ZyAmJiBjb25zb2xlLmVycm9yKFwidW5hYmxlIHRvIGNvcHkgdXNpbmcgY2xpcGJvYXJkRGF0YTogXCIsIGVycik7XG4gICAgICBkZWJ1ZyAmJiBjb25zb2xlLmVycm9yKFwiZmFsbGluZyBiYWNrIHRvIHByb21wdFwiKTtcbiAgICAgIG1lc3NhZ2UgPSBmb3JtYXQoXCJtZXNzYWdlXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMubWVzc2FnZSA6IGRlZmF1bHRNZXNzYWdlKTtcbiAgICAgIHdpbmRvdy5wcm9tcHQobWVzc2FnZSwgdGV4dCk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0aW9uLnJlbW92ZVJhbmdlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlUmFuZ2UocmFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXJrKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG1hcmspO1xuICAgIH1cbiAgICByZXNlbGVjdFByZXZpb3VzKCk7XG4gIH1cblxuICByZXR1cm4gc3VjY2Vzcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5O1xuIl0sIm5hbWVzIjpbImRlc2VsZWN0Q3VycmVudCIsInJlcXVpcmUiLCJjbGlwYm9hcmRUb0lFMTFGb3JtYXR0aW5nIiwiZGVmYXVsdE1lc3NhZ2UiLCJmb3JtYXQiLCJtZXNzYWdlIiwiY29weUtleSIsInRlc3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJyZXBsYWNlIiwiY29weSIsInRleHQiLCJvcHRpb25zIiwiZGVidWciLCJyZXNlbGVjdFByZXZpb3VzIiwicmFuZ2UiLCJzZWxlY3Rpb24iLCJtYXJrIiwic3VjY2VzcyIsImRvY3VtZW50IiwiY3JlYXRlUmFuZ2UiLCJnZXRTZWxlY3Rpb24iLCJjcmVhdGVFbGVtZW50IiwidGV4dENvbnRlbnQiLCJhcmlhSGlkZGVuIiwic3R5bGUiLCJhbGwiLCJwb3NpdGlvbiIsInRvcCIsImNsaXAiLCJ3aGl0ZVNwYWNlIiwid2Via2l0VXNlclNlbGVjdCIsIk1velVzZXJTZWxlY3QiLCJtc1VzZXJTZWxlY3QiLCJ1c2VyU2VsZWN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsImNsaXBib2FyZERhdGEiLCJjb25zb2xlIiwid2FybiIsIndpbmRvdyIsImNsZWFyRGF0YSIsInNldERhdGEiLCJvbkNvcHkiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJzZWxlY3ROb2RlQ29udGVudHMiLCJhZGRSYW5nZSIsInN1Y2Nlc3NmdWwiLCJleGVjQ29tbWFuZCIsIkVycm9yIiwiZXJyIiwiZXJyb3IiLCJwcm9tcHQiLCJyZW1vdmVSYW5nZSIsInJlbW92ZUFsbFJhbmdlcyIsInJlbW92ZUNoaWxkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/copy-to-clipboard/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMvRCxPQUFPO1lBQ1Q7WUFFQSxJQUFJQyxnQkFBZ0JMLHlCQUF5QkksYUFBYSxDQUFDSixzQkFBc0IsSUFBSUksYUFBYSxDQUFDRixxQkFBcUI7WUFFeEgsSUFBSSxPQUFPRyxrQkFBa0IsWUFBWTtnQkFDdkMsT0FBT0E7WUFDVDtZQUVBLE9BQU87UUFDVDtRQUVBLElBQUlDLHVCQUF1QnhCLE1BQU15QixrREFBa0Q7UUFFbkYsU0FBU0MsTUFBTUMsTUFBTTtZQUNuQjtnQkFDRTtvQkFDRSxJQUFLLElBQUlDLFFBQVFDLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixRQUFRLElBQUlBLFFBQVEsSUFBSSxJQUFJSyxRQUFRLEdBQUdBLFFBQVFMLE9BQU9LLFFBQVM7d0JBQ2pIRixJQUFJLENBQUNFLFFBQVEsRUFBRSxHQUFHSixTQUFTLENBQUNJLE1BQU07b0JBQ3BDO29CQUVBQyxhQUFhLFNBQVNQLFFBQVFJO2dCQUNoQztZQUNGO1FBQ0Y7UUFFQSxTQUFTRyxhQUFhQyxLQUFLLEVBQUVSLE1BQU0sRUFBRUksSUFBSTtZQUN2QyxtREFBbUQ7WUFDbkQsNkNBQTZDO1lBQzdDO2dCQUNFLElBQUlLLHlCQUF5QloscUJBQXFCWSxzQkFBc0I7Z0JBQ3hFLElBQUlDLFFBQVFELHVCQUF1QkUsZ0JBQWdCO2dCQUVuRCxJQUFJRCxVQUFVLElBQUk7b0JBQ2hCVixVQUFVO29CQUNWSSxPQUFPQSxLQUFLUSxNQUFNLENBQUM7d0JBQUNGO3FCQUFNO2dCQUM1QixFQUFFLCtEQUErRDtnQkFHakUsSUFBSUcsaUJBQWlCVCxLQUFLVSxHQUFHLENBQUMsU0FBVUMsSUFBSTtvQkFDMUMsT0FBT0MsT0FBT0Q7Z0JBQ2hCLElBQUksK0NBQStDO2dCQUVuREYsZUFBZUksT0FBTyxDQUFDLGNBQWNqQixTQUFTLG9FQUFvRTtnQkFDbEgsNkRBQTZEO2dCQUM3RCxnRUFBZ0U7Z0JBRWhFa0IsU0FBU0MsU0FBUyxDQUFDQyxLQUFLLENBQUNDLElBQUksQ0FBQ0MsT0FBTyxDQUFDZCxNQUFNLEVBQUVjLFNBQVNUO1lBQ3pEO1FBQ0Y7UUFFQSxnRkFBZ0Y7UUFFaEYsSUFBSVUsaUJBQWlCLE9BQU8sd0NBQXdDO1FBQ3BFLElBQUlDLHFCQUFxQjtRQUN6QixJQUFJQywwQkFBMEIsT0FBTywrQ0FBK0M7UUFFcEYsSUFBSUMscUJBQXFCLE9BQU8sc0RBQXNEO1FBQ3RGLCtFQUErRTtRQUMvRSx3QkFBd0I7UUFFeEIsSUFBSUMscUJBQXFCO1FBRXpCLElBQUlDLDJCQUEyQnBELE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxTQUFTb0QsbUJBQW1CQyxJQUFJO1lBQzlCLElBQUksT0FBT0EsU0FBUyxZQUFZLE9BQU9BLFNBQVMsWUFBWTtnQkFDMUQsT0FBTztZQUNULEVBQUUsbUZBQW1GO1lBR3JGLElBQUlBLFNBQVNuRCx1QkFBdUJtRCxTQUFTakQsdUJBQXVCOEMsc0JBQXVCRyxTQUFTbEQsMEJBQTBCa0QsU0FBUzdDLHVCQUF1QjZDLFNBQVM1Qyw0QkFBNEJ3QyxzQkFBdUJJLFNBQVN6Qyx3QkFBd0JrQyxrQkFBbUJDLHNCQUF1QkMseUJBQTBCO2dCQUM3VCxPQUFPO1lBQ1Q7WUFFQSxJQUFJLE9BQU9LLFNBQVMsWUFBWUEsU0FBUyxNQUFNO2dCQUM3QyxJQUFJQSxLQUFLQyxRQUFRLEtBQUszQyxtQkFBbUIwQyxLQUFLQyxRQUFRLEtBQUs1QyxtQkFBbUIyQyxLQUFLQyxRQUFRLEtBQUtqRCx1QkFBdUJnRCxLQUFLQyxRQUFRLEtBQUtoRCxzQkFBc0IrQyxLQUFLQyxRQUFRLEtBQUsvQywwQkFBMEIsNkRBQTZEO2dCQUN4USw2REFBNkQ7Z0JBQzdELCtEQUErRDtnQkFDL0QsUUFBUTtnQkFDUjhDLEtBQUtDLFFBQVEsS0FBS0gsNEJBQTRCRSxLQUFLRSxXQUFXLEtBQUtDLFdBQVc7b0JBQzVFLE9BQU87Z0JBQ1Q7WUFDRjtZQUVBLE9BQU87UUFDVDtRQUVBLFNBQVNDLGVBQWVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFQyxXQUFXO1lBQ3ZELElBQUlDLGNBQWNILFVBQVVHLFdBQVc7WUFFdkMsSUFBSUEsYUFBYTtnQkFDZixPQUFPQTtZQUNUO1lBRUEsSUFBSUMsZUFBZUgsVUFBVUUsV0FBVyxJQUFJRixVQUFVSSxJQUFJLElBQUk7WUFDOUQsT0FBT0QsaUJBQWlCLEtBQUtGLGNBQWMsTUFBTUUsZUFBZSxNQUFNRjtRQUN4RSxFQUFFLCtEQUErRDtRQUdqRSxTQUFTSSxlQUFlWCxJQUFJO1lBQzFCLE9BQU9BLEtBQUtRLFdBQVcsSUFBSTtRQUM3QjtRQUVBLElBQUlJLDJCQUEyQmxFLE9BQU9DLEdBQUcsQ0FBQywyQkFBMkIsdUdBQXVHO1FBRTVLLFNBQVNrRSx5QkFBeUJiLElBQUk7WUFDcEMsSUFBSUEsUUFBUSxNQUFNO2dCQUNoQiw2Q0FBNkM7Z0JBQzdDLE9BQU87WUFDVDtZQUVBLElBQUksT0FBT0EsU0FBUyxZQUFZO2dCQUM5QixJQUFJQSxLQUFLQyxRQUFRLEtBQUtXLDBCQUEwQjtvQkFDOUMsMEVBQTBFO29CQUMxRSxPQUFPO2dCQUNUO2dCQUVBLE9BQU9aLEtBQUtRLFdBQVcsSUFBSVIsS0FBS1UsSUFBSSxJQUFJO1lBQzFDO1lBRUEsSUFBSSxPQUFPVixTQUFTLFVBQVU7Z0JBQzVCLE9BQU9BO1lBQ1Q7WUFFQSxPQUFRQTtnQkFDTixLQUFLbkQ7b0JBQ0gsT0FBTztnQkFFVCxLQUFLRDtvQkFDSCxPQUFPO2dCQUVULEtBQUtHO29CQUNILE9BQU87Z0JBRVQsS0FBS0Q7b0JBQ0gsT0FBTztnQkFFVCxLQUFLSztvQkFDSCxPQUFPO2dCQUVULEtBQUtDO29CQUNILE9BQU87Z0JBRVQsS0FBS0k7b0JBQ0g7d0JBQ0UsT0FBTztvQkFDVDtZQUVKO1lBRUEsSUFBSSxPQUFPd0MsU0FBUyxVQUFVO2dCQUM1QjtvQkFDRSxJQUFJLE9BQU9BLEtBQUtjLEdBQUcsS0FBSyxVQUFVO3dCQUNoQzdDLE1BQU0sa0VBQWtFO29CQUMxRTtnQkFDRjtnQkFFQSxPQUFRK0IsS0FBS0MsUUFBUTtvQkFDbkIsS0FBS2hEO3dCQUNILElBQUk4RCxVQUFVZjt3QkFDZCxPQUFPVyxlQUFlSSxXQUFXO29CQUVuQyxLQUFLL0Q7d0JBQ0gsSUFBSWdFLFdBQVdoQjt3QkFDZixPQUFPVyxlQUFlSyxTQUFTQyxRQUFRLElBQUk7b0JBRTdDLEtBQUsvRDt3QkFDSCxPQUFPa0QsZUFBZUosTUFBTUEsS0FBS2tCLE1BQU0sRUFBRTtvQkFFM0MsS0FBSzdEO3dCQUNILElBQUk4RCxZQUFZbkIsS0FBS1EsV0FBVyxJQUFJO3dCQUVwQyxJQUFJVyxjQUFjLE1BQU07NEJBQ3RCLE9BQU9BO3dCQUNUO3dCQUVBLE9BQU9OLHlCQUF5QmIsS0FBS0EsSUFBSSxLQUFLO29CQUVoRCxLQUFLMUM7d0JBQ0g7NEJBQ0UsSUFBSThELGdCQUFnQnBCOzRCQUNwQixJQUFJcUIsVUFBVUQsY0FBY0UsUUFBUTs0QkFDcEMsSUFBSUMsT0FBT0gsY0FBY0ksS0FBSzs0QkFFOUIsSUFBSTtnQ0FDRixPQUFPWCx5QkFBeUJVLEtBQUtGOzRCQUN2QyxFQUFFLE9BQU9JLEdBQUc7Z0NBQ1YsT0FBTzs0QkFDVDt3QkFDRjtnQkFFSjtZQUNGO1lBRUEsT0FBTztRQUNUO1FBRUEsSUFBSUMsU0FBU0MsT0FBT0QsTUFBTTtRQUUxQix5RUFBeUU7UUFDekUsdUVBQXVFO1FBQ3ZFLHNFQUFzRTtRQUN0RSwwQ0FBMEM7UUFDMUMsSUFBSUUsZ0JBQWdCO1FBQ3BCLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBRUosU0FBU0MsZUFBZTtRQUV4QkEsWUFBWUMsa0JBQWtCLEdBQUc7UUFDakMsU0FBU0M7WUFDUDtnQkFDRSxJQUFJVixrQkFBa0IsR0FBRztvQkFDdkIsdURBQXVELEdBQ3ZEQyxVQUFVckMsUUFBUStDLEdBQUc7b0JBQ3JCVCxXQUFXdEMsUUFBUWdELElBQUk7b0JBQ3ZCVCxXQUFXdkMsUUFBUWlELElBQUk7b0JBQ3ZCVCxZQUFZeEMsUUFBUXZCLEtBQUs7b0JBQ3pCZ0UsWUFBWXpDLFFBQVFrRCxLQUFLO29CQUN6QlIscUJBQXFCMUMsUUFBUW1ELGNBQWM7b0JBQzNDUixlQUFlM0MsUUFBUW9ELFFBQVEsRUFBRSxpREFBaUQ7b0JBRWxGLElBQUlDLFFBQVE7d0JBQ1ZDLGNBQWM7d0JBQ2RDLFlBQVk7d0JBQ1pDLE9BQU9aO3dCQUNQYSxVQUFVO29CQUNaLEdBQUcsNkRBQTZEO29CQUVoRXRCLE9BQU91QixnQkFBZ0IsQ0FBQzFELFNBQVM7d0JBQy9CZ0QsTUFBTUs7d0JBQ05OLEtBQUtNO3dCQUNMSixNQUFNSTt3QkFDTjVFLE9BQU80RTt3QkFDUEgsT0FBT0c7d0JBQ1BGLGdCQUFnQkU7d0JBQ2hCRCxVQUFVQztvQkFDWjtnQkFDQSxzREFBc0QsR0FDeEQ7Z0JBRUFqQjtZQUNGO1FBQ0Y7UUFDQSxTQUFTdUI7WUFDUDtnQkFDRXZCO2dCQUVBLElBQUlBLGtCQUFrQixHQUFHO29CQUN2Qix1REFBdUQsR0FDdkQsSUFBSWlCLFFBQVE7d0JBQ1ZDLGNBQWM7d0JBQ2RDLFlBQVk7d0JBQ1pFLFVBQVU7b0JBQ1osR0FBRyw2REFBNkQ7b0JBRWhFdEIsT0FBT3VCLGdCQUFnQixDQUFDMUQsU0FBUzt3QkFDL0IrQyxLQUFLYixPQUFPLENBQUMsR0FBR21CLE9BQU87NEJBQ3JCRyxPQUFPbkI7d0JBQ1Q7d0JBQ0FXLE1BQU1kLE9BQU8sQ0FBQyxHQUFHbUIsT0FBTzs0QkFDdEJHLE9BQU9sQjt3QkFDVDt3QkFDQVcsTUFBTWYsT0FBTyxDQUFDLEdBQUdtQixPQUFPOzRCQUN0QkcsT0FBT2pCO3dCQUNUO3dCQUNBOUQsT0FBT3lELE9BQU8sQ0FBQyxHQUFHbUIsT0FBTzs0QkFDdkJHLE9BQU9oQjt3QkFDVDt3QkFDQVUsT0FBT2hCLE9BQU8sQ0FBQyxHQUFHbUIsT0FBTzs0QkFDdkJHLE9BQU9mO3dCQUNUO3dCQUNBVSxnQkFBZ0JqQixPQUFPLENBQUMsR0FBR21CLE9BQU87NEJBQ2hDRyxPQUFPZDt3QkFDVDt3QkFDQVUsVUFBVWxCLE9BQU8sQ0FBQyxHQUFHbUIsT0FBTzs0QkFDMUJHLE9BQU9iO3dCQUNUO29CQUNGO2dCQUNBLHNEQUFzRCxHQUN4RDtnQkFFQSxJQUFJUCxnQkFBZ0IsR0FBRztvQkFDckIzRCxNQUFNLG9DQUFvQztnQkFDNUM7WUFDRjtRQUNGO1FBRUEsSUFBSW1GLHlCQUF5QnJGLHFCQUFxQnFGLHNCQUFzQjtRQUN4RSxJQUFJQztRQUNKLFNBQVNDLDhCQUE4QjVDLElBQUksRUFBRTZDLE1BQU0sRUFBRUMsT0FBTztZQUMxRDtnQkFDRSxJQUFJSCxXQUFXbEQsV0FBVztvQkFDeEIsb0RBQW9EO29CQUNwRCxJQUFJO3dCQUNGLE1BQU1zRDtvQkFDUixFQUFFLE9BQU9oQyxHQUFHO3dCQUNWLElBQUlpQyxRQUFRakMsRUFBRTdDLEtBQUssQ0FBQytFLElBQUksR0FBR0QsS0FBSyxDQUFDO3dCQUNqQ0wsU0FBU0ssU0FBU0EsS0FBSyxDQUFDLEVBQUUsSUFBSTtvQkFDaEM7Z0JBQ0YsRUFBRSwyRUFBMkU7Z0JBRzdFLE9BQU8sT0FBT0wsU0FBUzNDO1lBQ3pCO1FBQ0Y7UUFDQSxJQUFJa0QsVUFBVTtRQUNkLElBQUlDO1FBRUo7WUFDRSxJQUFJQyxrQkFBa0IsT0FBT0MsWUFBWSxhQUFhQSxVQUFVQztZQUNoRUgsc0JBQXNCLElBQUlDO1FBQzVCO1FBQ0E7Ozs7Ozs7Ozs7Q0FVQyxHQUdELFNBQVNHLDZCQUE2QkMsRUFBRSxFQUFFQyxTQUFTO1lBQ2pELDhFQUE4RTtZQUM5RSxJQUFJLENBQUNELE1BQU1OLFNBQVM7Z0JBQ2xCLE9BQU87WUFDVDtZQUVBO2dCQUNFLElBQUlRLFFBQVFQLG9CQUFvQlEsR0FBRyxDQUFDSDtnQkFFcEMsSUFBSUUsVUFBVWpFLFdBQVc7b0JBQ3ZCLE9BQU9pRTtnQkFDVDtZQUNGO1lBRUFSLFVBQVU7WUFDVixJQUFJVSw0QkFBNEJiLE1BQU1jLGlCQUFpQixFQUFFLDBEQUEwRDtZQUVuSGQsTUFBTWMsaUJBQWlCLEdBQUdwRTtZQUMxQixJQUFJcUU7WUFFSjtnQkFDRUEscUJBQXFCcEIsdUJBQXVCcUIsT0FBTyxFQUFFLDhFQUE4RTtnQkFDbkksZ0JBQWdCO2dCQUVoQnJCLHVCQUF1QnFCLE9BQU8sR0FBRztnQkFDakNuQztZQUNGO1lBQ0E7Ozs7Ozs7Ozs7R0FVQyxHQUdELElBQUlvQyxpQkFBaUI7Z0JBQ25CQyw2QkFBNkI7b0JBQzNCLElBQUlDO29CQUVKLElBQUk7d0JBQ0YscUJBQXFCO3dCQUNyQixJQUFJVCxXQUFXOzRCQUNiLDREQUE0RDs0QkFDNUQsSUFBSVUsT0FBTztnQ0FDVCxNQUFNcEI7NEJBQ1IsR0FBRywyQkFBMkI7NEJBRzlCOUIsT0FBT21ELGNBQWMsQ0FBQ0QsS0FBS3hGLFNBQVMsRUFBRSxTQUFTO2dDQUM3QzBGLEtBQUs7b0NBQ0gsbUVBQW1FO29DQUNuRSwwREFBMEQ7b0NBQzFELE1BQU10QjtnQ0FDUjs0QkFDRjs0QkFFQSxJQUFJLE9BQU91QixZQUFZLFlBQVlBLFFBQVFiLFNBQVMsRUFBRTtnQ0FDcEQsc0VBQXNFO2dDQUN0RSxzQ0FBc0M7Z0NBQ3RDLElBQUk7b0NBQ0ZhLFFBQVFiLFNBQVMsQ0FBQ1UsTUFBTSxFQUFFO2dDQUM1QixFQUFFLE9BQU9wRCxHQUFHO29DQUNWbUQsVUFBVW5EO2dDQUNaO2dDQUVBdUQsUUFBUWIsU0FBUyxDQUFDRCxJQUFJLEVBQUUsRUFBRVc7NEJBQzVCLE9BQU87Z0NBQ0wsSUFBSTtvQ0FDRkEsS0FBS3RGLElBQUk7Z0NBQ1gsRUFBRSxPQUFPa0MsR0FBRztvQ0FDVm1ELFVBQVVuRDtnQ0FDWixFQUFFLHFEQUFxRDtnQ0FHdkR5QyxHQUFHM0UsSUFBSSxDQUFDc0YsS0FBS3hGLFNBQVM7NEJBQ3hCO3dCQUNGLE9BQU87NEJBQ0wsSUFBSTtnQ0FDRixNQUFNb0U7NEJBQ1IsRUFBRSxPQUFPaEMsR0FBRztnQ0FDVm1ELFVBQVVuRDs0QkFDWixFQUFFLHVFQUF1RTs0QkFDekUsMkVBQTJFOzRCQUMzRSwyQkFBMkI7NEJBRzNCLElBQUl3RCxlQUFlZixNQUFNLG9FQUFvRTs0QkFDN0Ysd0VBQXdFOzRCQUN4RSxxQkFBcUI7NEJBQ3JCLGdFQUFnRTs0QkFFaEUsSUFBSWUsZ0JBQWdCLE9BQU9BLGFBQWFDLEtBQUssS0FBSyxZQUFZO2dDQUM1REQsYUFBYUMsS0FBSyxDQUFDLFlBQWE7NEJBQ2xDO3dCQUNGO29CQUNGLEVBQUUsT0FBT0MsUUFBUTt3QkFDZixpRUFBaUU7d0JBQ2pFLElBQUlBLFVBQVVQLFdBQVcsT0FBT08sT0FBT3ZHLEtBQUssS0FBSyxVQUFVOzRCQUN6RCxPQUFPO2dDQUFDdUcsT0FBT3ZHLEtBQUs7Z0NBQUVnRyxRQUFRaEcsS0FBSzs2QkFBQzt3QkFDdEM7b0JBQ0Y7b0JBRUEsT0FBTzt3QkFBQzt3QkFBTTtxQkFBSztnQkFDckI7WUFDRixHQUFHLDJCQUEyQjtZQUU5QjhGLGVBQWVDLDJCQUEyQixDQUFDbkUsV0FBVyxHQUFHO1lBQ3pELElBQUk0RSxxQkFBcUJ6RCxPQUFPMEQsd0JBQXdCLENBQUNYLGVBQWVDLDJCQUEyQixFQUFFLFNBQVMsd0RBQXdEO1lBRXRLLElBQUlTLHNCQUFzQkEsbUJBQW1CdEMsWUFBWSxFQUFFO2dCQUN6RCwwRUFBMEU7Z0JBQzFFbkIsT0FBT21ELGNBQWMsQ0FBQ0osZUFBZUMsMkJBQTJCLEVBQ2hFLHFCQUFxQjtnQkFDckIsMkJBQTJCO2dCQUMzQixRQUFRO29CQUNOM0IsT0FBTztnQkFDVDtZQUNGO1lBRUEsSUFBSTtnQkFDRixJQUFJc0Msd0JBQXdCWixlQUFlQywyQkFBMkIsSUFDbEVZLGNBQWNELHFCQUFxQixDQUFDLEVBQUUsRUFDdENFLGVBQWVGLHFCQUFxQixDQUFDLEVBQUU7Z0JBRTNDLElBQUlDLGVBQWVDLGNBQWM7b0JBQy9CLGdGQUFnRjtvQkFDaEYscUVBQXFFO29CQUNyRSxJQUFJQyxjQUFjRixZQUFZRyxLQUFLLENBQUM7b0JBQ3BDLElBQUlDLGVBQWVILGFBQWFFLEtBQUssQ0FBQztvQkFDdEMsSUFBSUUsSUFBSTtvQkFDUixJQUFJQyxJQUFJO29CQUVSLE1BQU9ELElBQUlILFlBQVlwSCxNQUFNLElBQUksQ0FBQ29ILFdBQVcsQ0FBQ0csRUFBRSxDQUFDRSxRQUFRLENBQUMsK0JBQWdDO3dCQUN4RkY7b0JBQ0Y7b0JBRUEsTUFBT0MsSUFBSUYsYUFBYXRILE1BQU0sSUFBSSxDQUFDc0gsWUFBWSxDQUFDRSxFQUFFLENBQUNDLFFBQVEsQ0FBQywrQkFBZ0M7d0JBQzFGRDtvQkFDRixFQUFFLHlFQUF5RTtvQkFDM0UscUVBQXFFO29CQUNyRSxtQkFBbUI7b0JBR25CLElBQUlELE1BQU1ILFlBQVlwSCxNQUFNLElBQUl3SCxNQUFNRixhQUFhdEgsTUFBTSxFQUFFO3dCQUN6RHVILElBQUlILFlBQVlwSCxNQUFNLEdBQUc7d0JBQ3pCd0gsSUFBSUYsYUFBYXRILE1BQU0sR0FBRzt3QkFFMUIsTUFBT3VILEtBQUssS0FBS0MsS0FBSyxLQUFLSixXQUFXLENBQUNHLEVBQUUsS0FBS0QsWUFBWSxDQUFDRSxFQUFFLENBQUU7NEJBQzdELG1EQUFtRDs0QkFDbkQseUVBQXlFOzRCQUN6RSx1RUFBdUU7NEJBQ3ZFLDBFQUEwRTs0QkFDMUUsMEVBQTBFOzRCQUMxRSx1Q0FBdUM7NEJBQ3ZDQTt3QkFDRjtvQkFDRjtvQkFFQSxNQUFPRCxLQUFLLEtBQUtDLEtBQUssR0FBR0QsS0FBS0MsSUFBSzt3QkFDakMscUVBQXFFO3dCQUNyRSx5REFBeUQ7d0JBQ3pELElBQUlKLFdBQVcsQ0FBQ0csRUFBRSxLQUFLRCxZQUFZLENBQUNFLEVBQUUsRUFBRTs0QkFDdEMsdUVBQXVFOzRCQUN2RSwrRUFBK0U7NEJBQy9FLDZFQUE2RTs0QkFDN0Usa0ZBQWtGOzRCQUNsRixnRkFBZ0Y7NEJBQ2hGLElBQUlELE1BQU0sS0FBS0MsTUFBTSxHQUFHO2dDQUN0QixHQUFHO29DQUNERDtvQ0FDQUMsS0FBSyx5RUFBeUU7b0NBQzlFLCtEQUErRDtvQ0FFL0QsSUFBSUEsSUFBSSxLQUFLSixXQUFXLENBQUNHLEVBQUUsS0FBS0QsWUFBWSxDQUFDRSxFQUFFLEVBQUU7d0NBQy9DLGtGQUFrRjt3Q0FDbEYsSUFBSUUsU0FBUyxPQUFPTixXQUFXLENBQUNHLEVBQUUsQ0FBQ0ksT0FBTyxDQUFDLFlBQVksU0FBUyxrREFBa0Q7d0NBQ2xILDRDQUE0Qzt3Q0FDNUMsZ0RBQWdEO3dDQUdoRCxJQUFJOUIsR0FBRzFELFdBQVcsSUFBSXVGLE9BQU9ELFFBQVEsQ0FBQyxnQkFBZ0I7NENBQ3BEQyxTQUFTQSxPQUFPQyxPQUFPLENBQUMsZUFBZTlCLEdBQUcxRCxXQUFXO3dDQUN2RDt3Q0FFQSxJQUFJLElBQUksRUFBRTs0Q0FDUixJQUFJLE9BQU8wRCxPQUFPLFlBQVk7Z0RBQzVCTCxvQkFBb0JrQixHQUFHLENBQUNiLElBQUk2Qjs0Q0FDOUI7d0NBQ0YsRUFBRSw0QkFBNEI7d0NBRzlCLE9BQU9BO29DQUNUO2dDQUNGLFFBQVNILEtBQUssS0FBS0MsS0FBSyxHQUFHOzRCQUM3Qjs0QkFFQTt3QkFDRjtvQkFDRjtnQkFDRjtZQUNGLFNBQVU7Z0JBQ1JqQyxVQUFVO2dCQUVWO29CQUNFUix1QkFBdUJxQixPQUFPLEdBQUdEO29CQUNqQ3JCO2dCQUNGO2dCQUVBTSxNQUFNYyxpQkFBaUIsR0FBR0Q7WUFDNUIsRUFBRSxnRUFBZ0U7WUFHbEUsSUFBSTVELE9BQU93RCxLQUFLQSxHQUFHMUQsV0FBVyxJQUFJMEQsR0FBR3hELElBQUksR0FBRztZQUM1QyxJQUFJdUYsaUJBQWlCdkYsT0FBTzRDLDhCQUE4QjVDLFFBQVE7WUFFbEU7Z0JBQ0UsSUFBSSxPQUFPd0QsT0FBTyxZQUFZO29CQUM1Qkwsb0JBQW9Ca0IsR0FBRyxDQUFDYixJQUFJK0I7Z0JBQzlCO1lBQ0Y7WUFFQSxPQUFPQTtRQUNUO1FBQ0EsU0FBU0MsK0JBQStCaEMsRUFBRSxFQUFFWCxNQUFNLEVBQUVDLE9BQU87WUFDekQ7Z0JBQ0UsT0FBT1MsNkJBQTZCQyxJQUFJO1lBQzFDO1FBQ0Y7UUFFQSxTQUFTaUMsZ0JBQWdCQyxTQUFTO1lBQ2hDLElBQUkvRyxZQUFZK0csVUFBVS9HLFNBQVM7WUFDbkMsT0FBTyxDQUFDLENBQUVBLENBQUFBLGFBQWFBLFVBQVVnSCxnQkFBZ0I7UUFDbkQ7UUFFQSxTQUFTQyxxQ0FBcUN0RyxJQUFJLEVBQUV1RCxNQUFNLEVBQUVDLE9BQU87WUFFakUsSUFBSXhELFFBQVEsTUFBTTtnQkFDaEIsT0FBTztZQUNUO1lBRUEsSUFBSSxPQUFPQSxTQUFTLFlBQVk7Z0JBQzlCO29CQUNFLE9BQU9pRSw2QkFBNkJqRSxNQUFNbUcsZ0JBQWdCbkc7Z0JBQzVEO1lBQ0Y7WUFFQSxJQUFJLE9BQU9BLFNBQVMsVUFBVTtnQkFDNUIsT0FBT3NELDhCQUE4QnREO1lBQ3ZDO1lBRUEsT0FBUUE7Z0JBQ04sS0FBSzdDO29CQUNILE9BQU9tRyw4QkFBOEI7Z0JBRXZDLEtBQUtsRztvQkFDSCxPQUFPa0csOEJBQThCO1lBQ3pDO1lBRUEsSUFBSSxPQUFPdEQsU0FBUyxVQUFVO2dCQUM1QixPQUFRQSxLQUFLQyxRQUFRO29CQUNuQixLQUFLL0M7d0JBQ0gsT0FBT2dKLCtCQUErQmxHLEtBQUtrQixNQUFNO29CQUVuRCxLQUFLN0Q7d0JBQ0gsb0VBQW9FO3dCQUNwRSxPQUFPaUoscUNBQXFDdEcsS0FBS0EsSUFBSSxFQUFFdUQsUUFBUUM7b0JBRWpFLEtBQUtsRzt3QkFDSDs0QkFDRSxJQUFJOEQsZ0JBQWdCcEI7NEJBQ3BCLElBQUlxQixVQUFVRCxjQUFjRSxRQUFROzRCQUNwQyxJQUFJQyxPQUFPSCxjQUFjSSxLQUFLOzRCQUU5QixJQUFJO2dDQUNGLG9FQUFvRTtnQ0FDcEUsT0FBTzhFLHFDQUFxQy9FLEtBQUtGLFVBQVVrQyxRQUFRQzs0QkFDckUsRUFBRSxPQUFPL0IsR0FBRyxDQUFDO3dCQUNmO2dCQUNKO1lBQ0Y7WUFFQSxPQUFPO1FBQ1Q7UUFFQSwrQkFBK0I7UUFDL0IsSUFBSThFLGlCQUFpQjVFLE9BQU90QyxTQUFTLENBQUNrSCxjQUFjO1FBRXBELElBQUlDLHFCQUFxQixDQUFDO1FBQzFCLElBQUlDLDJCQUEyQjFJLHFCQUFxQlksc0JBQXNCO1FBRTFFLFNBQVMrSCxnQ0FBZ0NDLE9BQU87WUFDOUM7Z0JBQ0UsSUFBSUEsU0FBUztvQkFDWCxJQUFJQyxRQUFRRCxRQUFRRSxNQUFNO29CQUMxQixJQUFJakksUUFBUTBILHFDQUFxQ0ssUUFBUTNHLElBQUksRUFBRTJHLFFBQVFHLE9BQU8sRUFBRUYsUUFBUUEsTUFBTTVHLElBQUksR0FBRztvQkFDckd5Ryx5QkFBeUJNLGtCQUFrQixDQUFDbkk7Z0JBQzlDLE9BQU87b0JBQ0w2SCx5QkFBeUJNLGtCQUFrQixDQUFDO2dCQUM5QztZQUNGO1FBQ0Y7UUFFQSxTQUFTQyxlQUFlQyxTQUFTLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxhQUFhLEVBQUVULE9BQU87WUFDekU7Z0JBQ0Usc0VBQXNFO2dCQUN0RSxJQUFJVSxNQUFNakksU0FBU0csSUFBSSxDQUFDK0gsSUFBSSxDQUFDZjtnQkFFN0IsSUFBSyxJQUFJZ0IsZ0JBQWdCTixVQUFXO29CQUNsQyxJQUFJSSxJQUFJSixXQUFXTSxlQUFlO3dCQUNoQyxJQUFJQyxVQUFVLEtBQUssR0FBRyxvRUFBb0U7d0JBQzFGLG1FQUFtRTt3QkFDbkUsMERBQTBEO3dCQUUxRCxJQUFJOzRCQUNGLHFFQUFxRTs0QkFDckUsbUVBQW1FOzRCQUNuRSxJQUFJLE9BQU9QLFNBQVMsQ0FBQ00sYUFBYSxLQUFLLFlBQVk7Z0NBQ2pELDJEQUEyRDtnQ0FDM0QsSUFBSUUsTUFBTWhFLE1BQU0sQ0FBQzJELGlCQUFpQixhQUFZLElBQUssT0FBT0QsV0FBVyxZQUFZSSxlQUFlLG1CQUFtQixpRkFBaUYsT0FBT04sU0FBUyxDQUFDTSxhQUFhLEdBQUcsT0FBTztnQ0FDNU9FLElBQUkvRyxJQUFJLEdBQUc7Z0NBQ1gsTUFBTStHOzRCQUNSOzRCQUVBRCxVQUFVUCxTQUFTLENBQUNNLGFBQWEsQ0FBQ0wsUUFBUUssY0FBY0gsZUFBZUQsVUFBVSxNQUFNO3dCQUN6RixFQUFFLE9BQU9PLElBQUk7NEJBQ1hGLFVBQVVFO3dCQUNaO3dCQUVBLElBQUlGLFdBQVcsQ0FBRUEsQ0FBQUEsbUJBQW1CL0QsS0FBSSxHQUFJOzRCQUMxQ2lELGdDQUFnQ0M7NEJBRWhDMUksTUFBTSxpQ0FBaUMsd0NBQXdDLGtFQUFrRSxvRUFBb0UsbUVBQW1FLG1DQUFtQ21KLGlCQUFpQixlQUFlRCxVQUFVSSxjQUFjLE9BQU9DOzRCQUUxWGQsZ0NBQWdDO3dCQUNsQzt3QkFFQSxJQUFJYyxtQkFBbUIvRCxTQUFTLENBQUUrRCxDQUFBQSxRQUFRRyxPQUFPLElBQUluQixrQkFBaUIsR0FBSTs0QkFDeEUsd0VBQXdFOzRCQUN4RSxjQUFjOzRCQUNkQSxrQkFBa0IsQ0FBQ2dCLFFBQVFHLE9BQU8sQ0FBQyxHQUFHOzRCQUN0Q2pCLGdDQUFnQ0M7NEJBRWhDMUksTUFBTSxzQkFBc0JrSixVQUFVSyxRQUFRRyxPQUFPOzRCQUVyRGpCLGdDQUFnQzt3QkFDbEM7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsSUFBSWtCLGNBQWNySixNQUFNc0osT0FBTyxFQUFFLHdDQUF3QztRQUV6RSxTQUFTQSxRQUFRQyxDQUFDO1lBQ2hCLE9BQU9GLFlBQVlFO1FBQ3JCO1FBRUE7Ozs7Ozs7O0NBUUMsR0FDRCxzRkFBc0Y7UUFDdEYsU0FBU0MsU0FBUy9FLEtBQUs7WUFDckI7Z0JBQ0UsbUVBQW1FO2dCQUNuRSxJQUFJZ0YsaUJBQWlCLE9BQU90TCxXQUFXLGNBQWNBLE9BQU91TCxXQUFXO2dCQUN2RSxJQUFJakksT0FBT2dJLGtCQUFrQmhGLEtBQUssQ0FBQ3RHLE9BQU91TCxXQUFXLENBQUMsSUFBSWpGLE1BQU1rRixXQUFXLENBQUN4SCxJQUFJLElBQUksVUFBVSxrQ0FBa0M7Z0JBRWhJLE9BQU9WO1lBQ1Q7UUFDRixFQUFFLHNGQUFzRjtRQUd4RixTQUFTbUksa0JBQWtCbkYsS0FBSztZQUM5QjtnQkFDRSxJQUFJO29CQUNGb0YsbUJBQW1CcEY7b0JBQ25CLE9BQU87Z0JBQ1QsRUFBRSxPQUFPcUYsR0FBRztvQkFDVixPQUFPO2dCQUNUO1lBQ0Y7UUFDRjtRQUVBLFNBQVNELG1CQUFtQnBGLEtBQUs7WUFDL0IsMkVBQTJFO1lBQzNFLDZFQUE2RTtZQUM3RSx5RUFBeUU7WUFDekUscUVBQXFFO1lBQ3JFLEVBQUU7WUFDRiw4RUFBOEU7WUFDOUUsMEVBQTBFO1lBQzFFLDhFQUE4RTtZQUM5RSwyRUFBMkU7WUFDM0UsOEVBQThFO1lBQzlFLG9FQUFvRTtZQUNwRSxFQUFFO1lBQ0YsNEVBQTRFO1lBQzVFLHlFQUF5RTtZQUN6RSxFQUFFO1lBQ0YsMEVBQTBFO1lBQzFFLDJFQUEyRTtZQUMzRSx5RUFBeUU7WUFDekUsNkVBQTZFO1lBQzdFLHNFQUFzRTtZQUN0RSxvREFBb0Q7WUFDcEQsRUFBRTtZQUNGLCtEQUErRDtZQUMvRCxPQUFPLEtBQUtBO1FBQ2Q7UUFDQSxTQUFTc0YsdUJBQXVCdEYsS0FBSztZQUNuQztnQkFDRSxJQUFJbUYsa0JBQWtCbkYsUUFBUTtvQkFDNUIvRSxNQUFNLGdEQUFnRCxpRUFBaUU4SixTQUFTL0U7b0JBRWhJLE9BQU9vRixtQkFBbUJwRixRQUFRLHdEQUF3RDtnQkFDNUY7WUFDRjtRQUNGO1FBRUEsSUFBSXVGLHNCQUFzQnhLLHFCQUFxQnlLLGlCQUFpQjtRQUNoRSxJQUFJQyxpQkFBaUI7WUFDbkJDLEtBQUs7WUFDTEMsS0FBSztZQUNMQyxRQUFRO1lBQ1JDLFVBQVU7UUFDWjtRQUNBLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUVKO1lBQ0VBLHlCQUF5QixDQUFDO1FBQzVCO1FBRUEsU0FBU0MsWUFBWUMsTUFBTTtZQUN6QjtnQkFDRSxJQUFJM0MsZUFBZWhILElBQUksQ0FBQzJKLFFBQVEsUUFBUTtvQkFDdEMsSUFBSUMsU0FBU3hILE9BQU8wRCx3QkFBd0IsQ0FBQzZELFFBQVEsT0FBTzdFLEdBQUc7b0JBRS9ELElBQUk4RSxVQUFVQSxPQUFPQyxjQUFjLEVBQUU7d0JBQ25DLE9BQU87b0JBQ1Q7Z0JBQ0Y7WUFDRjtZQUVBLE9BQU9GLE9BQU9QLEdBQUcsS0FBS3hJO1FBQ3hCO1FBRUEsU0FBU2tKLFlBQVlILE1BQU07WUFDekI7Z0JBQ0UsSUFBSTNDLGVBQWVoSCxJQUFJLENBQUMySixRQUFRLFFBQVE7b0JBQ3RDLElBQUlDLFNBQVN4SCxPQUFPMEQsd0JBQXdCLENBQUM2RCxRQUFRLE9BQU83RSxHQUFHO29CQUUvRCxJQUFJOEUsVUFBVUEsT0FBT0MsY0FBYyxFQUFFO3dCQUNuQyxPQUFPO29CQUNUO2dCQUNGO1lBQ0Y7WUFFQSxPQUFPRixPQUFPUixHQUFHLEtBQUt2STtRQUN4QjtRQUVBLFNBQVNtSixxQ0FBcUNKLE1BQU0sRUFBRUssSUFBSTtZQUN4RDtnQkFDRSxJQUFJLE9BQU9MLE9BQU9QLEdBQUcsS0FBSyxZQUFZSixvQkFBb0I5RCxPQUFPLElBQUk4RSxRQUFRaEIsb0JBQW9COUQsT0FBTyxDQUFDK0UsU0FBUyxLQUFLRCxNQUFNO29CQUMzSCxJQUFJbkMsZ0JBQWdCdkcseUJBQXlCMEgsb0JBQW9COUQsT0FBTyxDQUFDekUsSUFBSTtvQkFFN0UsSUFBSSxDQUFDZ0osc0JBQXNCLENBQUM1QixjQUFjLEVBQUU7d0JBQzFDbkosTUFBTSxrREFBa0Qsd0VBQXdFLHVFQUF1RSxvRkFBb0YsOENBQThDLG1EQUFtRDRDLHlCQUF5QjBILG9CQUFvQjlELE9BQU8sQ0FBQ3pFLElBQUksR0FBR2tKLE9BQU9QLEdBQUc7d0JBRWxjSyxzQkFBc0IsQ0FBQzVCLGNBQWMsR0FBRztvQkFDMUM7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsU0FBU3FDLDJCQUEyQjVHLEtBQUssRUFBRXJDLFdBQVc7WUFDcEQ7Z0JBQ0UsSUFBSWtKLHdCQUF3QjtvQkFDMUIsSUFBSSxDQUFDWiw0QkFBNEI7d0JBQy9CQSw2QkFBNkI7d0JBRTdCN0ssTUFBTSw4REFBOEQsbUVBQW1FLHlFQUF5RSxrREFBa0R1QztvQkFDcFE7Z0JBQ0Y7Z0JBRUFrSixzQkFBc0JOLGNBQWMsR0FBRztnQkFDdkN6SCxPQUFPbUQsY0FBYyxDQUFDakMsT0FBTyxPQUFPO29CQUNsQ3dCLEtBQUtxRjtvQkFDTDVHLGNBQWM7Z0JBQ2hCO1lBQ0Y7UUFDRjtRQUVBLFNBQVM2RywyQkFBMkI5RyxLQUFLLEVBQUVyQyxXQUFXO1lBQ3BEO2dCQUNFLElBQUlvSix3QkFBd0I7b0JBQzFCLElBQUksQ0FBQ2IsNEJBQTRCO3dCQUMvQkEsNkJBQTZCO3dCQUU3QjlLLE1BQU0sOERBQThELG1FQUFtRSx5RUFBeUUsa0RBQWtEdUM7b0JBQ3BRO2dCQUNGO2dCQUVBb0osc0JBQXNCUixjQUFjLEdBQUc7Z0JBQ3ZDekgsT0FBT21ELGNBQWMsQ0FBQ2pDLE9BQU8sT0FBTztvQkFDbEN3QixLQUFLdUY7b0JBQ0w5RyxjQUFjO2dCQUNoQjtZQUNGO1FBQ0Y7UUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUdELFNBQVMrRyxhQUFhN0osSUFBSSxFQUFFMEksR0FBRyxFQUFFQyxHQUFHLEVBQUVZLElBQUksRUFBRWhHLE1BQU0sRUFBRXFELEtBQUssRUFBRS9ELEtBQUs7WUFDOUQsSUFBSThELFVBQVU7Z0JBQ1osa0VBQWtFO2dCQUNsRTFHLFVBQVV4RDtnQkFDVixpREFBaUQ7Z0JBQ2pEdUQsTUFBTUE7Z0JBQ04wSSxLQUFLQTtnQkFDTEMsS0FBS0E7Z0JBQ0w5RixPQUFPQTtnQkFDUCw4REFBOEQ7Z0JBQzlEZ0UsUUFBUUQ7WUFDVjtZQUVBO2dCQUNFLDBEQUEwRDtnQkFDMUQsb0VBQW9FO2dCQUNwRSxtRUFBbUU7Z0JBQ25FLDBDQUEwQztnQkFDMUNELFFBQVFtRCxNQUFNLEdBQUcsQ0FBQyxHQUFHLHVFQUF1RTtnQkFDNUYsbUVBQW1FO2dCQUNuRSxvRUFBb0U7Z0JBQ3BFLGNBQWM7Z0JBRWRuSSxPQUFPbUQsY0FBYyxDQUFDNkIsUUFBUW1ELE1BQU0sRUFBRSxhQUFhO29CQUNqRGhILGNBQWM7b0JBQ2RDLFlBQVk7b0JBQ1pFLFVBQVU7b0JBQ1ZELE9BQU87Z0JBQ1QsSUFBSSwyQ0FBMkM7Z0JBRS9DckIsT0FBT21ELGNBQWMsQ0FBQzZCLFNBQVMsU0FBUztvQkFDdEM3RCxjQUFjO29CQUNkQyxZQUFZO29CQUNaRSxVQUFVO29CQUNWRCxPQUFPdUc7Z0JBQ1QsSUFBSSxvRUFBb0U7Z0JBQ3hFLHdFQUF3RTtnQkFFeEU1SCxPQUFPbUQsY0FBYyxDQUFDNkIsU0FBUyxXQUFXO29CQUN4QzdELGNBQWM7b0JBQ2RDLFlBQVk7b0JBQ1pFLFVBQVU7b0JBQ1ZELE9BQU9PO2dCQUNUO2dCQUVBLElBQUk1QixPQUFPb0ksTUFBTSxFQUFFO29CQUNqQnBJLE9BQU9vSSxNQUFNLENBQUNwRCxRQUFROUQsS0FBSztvQkFDM0JsQixPQUFPb0ksTUFBTSxDQUFDcEQ7Z0JBQ2hCO1lBQ0Y7WUFFQSxPQUFPQTtRQUNUO1FBQ0E7Ozs7O0NBS0MsR0FFRCxTQUFTcUQsU0FBU2hLLElBQUksRUFBRWtKLE1BQU0sRUFBRWUsUUFBUSxFQUFFMUcsTUFBTSxFQUFFZ0csSUFBSTtZQUNwRDtnQkFDRSxJQUFJVyxVQUFVLCtCQUErQjtnQkFFN0MsSUFBSXJILFFBQVEsQ0FBQztnQkFDYixJQUFJNkYsTUFBTTtnQkFDVixJQUFJQyxNQUFNLE1BQU0scUVBQXFFO2dCQUNyRiw0RUFBNEU7Z0JBQzVFLHFFQUFxRTtnQkFDckUsd0VBQXdFO2dCQUN4RSwyRUFBMkU7Z0JBQzNFLHFEQUFxRDtnQkFFckQsSUFBSXNCLGFBQWE5SixXQUFXO29CQUMxQjt3QkFDRW1JLHVCQUF1QjJCO29CQUN6QjtvQkFFQXZCLE1BQU0sS0FBS3VCO2dCQUNiO2dCQUVBLElBQUlaLFlBQVlILFNBQVM7b0JBQ3ZCO3dCQUNFWix1QkFBdUJZLE9BQU9SLEdBQUc7b0JBQ25DO29CQUVBQSxNQUFNLEtBQUtRLE9BQU9SLEdBQUc7Z0JBQ3ZCO2dCQUVBLElBQUlPLFlBQVlDLFNBQVM7b0JBQ3ZCUCxNQUFNTyxPQUFPUCxHQUFHO29CQUNoQlcscUNBQXFDSixRQUFRSztnQkFDL0MsRUFBRSx1REFBdUQ7Z0JBR3pELElBQUtXLFlBQVloQixPQUFRO29CQUN2QixJQUFJM0MsZUFBZWhILElBQUksQ0FBQzJKLFFBQVFnQixhQUFhLENBQUN6QixlQUFlbEMsY0FBYyxDQUFDMkQsV0FBVzt3QkFDckZySCxLQUFLLENBQUNxSCxTQUFTLEdBQUdoQixNQUFNLENBQUNnQixTQUFTO29CQUNwQztnQkFDRixFQUFFLHdCQUF3QjtnQkFHMUIsSUFBSWxLLFFBQVFBLEtBQUttSyxZQUFZLEVBQUU7b0JBQzdCLElBQUlBLGVBQWVuSyxLQUFLbUssWUFBWTtvQkFFcEMsSUFBS0QsWUFBWUMsYUFBYzt3QkFDN0IsSUFBSXRILEtBQUssQ0FBQ3FILFNBQVMsS0FBSy9KLFdBQVc7NEJBQ2pDMEMsS0FBSyxDQUFDcUgsU0FBUyxHQUFHQyxZQUFZLENBQUNELFNBQVM7d0JBQzFDO29CQUNGO2dCQUNGO2dCQUVBLElBQUl4QixPQUFPQyxLQUFLO29CQUNkLElBQUluSSxjQUFjLE9BQU9SLFNBQVMsYUFBYUEsS0FBS1EsV0FBVyxJQUFJUixLQUFLVSxJQUFJLElBQUksWUFBWVY7b0JBRTVGLElBQUkwSSxLQUFLO3dCQUNQZSwyQkFBMkI1RyxPQUFPckM7b0JBQ3BDO29CQUVBLElBQUltSSxLQUFLO3dCQUNQZ0IsMkJBQTJCOUcsT0FBT3JDO29CQUNwQztnQkFDRjtnQkFFQSxPQUFPcUosYUFBYTdKLE1BQU0wSSxLQUFLQyxLQUFLWSxNQUFNaEcsUUFBUWdGLG9CQUFvQjlELE9BQU8sRUFBRTVCO1lBQ2pGO1FBQ0Y7UUFFQSxJQUFJMkYsb0JBQW9CeksscUJBQXFCeUssaUJBQWlCO1FBQzlELElBQUk3Six5QkFBeUJaLHFCQUFxQlksc0JBQXNCO1FBQ3hFLElBQUl5TCx5QkFBeUIxTixPQUFPQyxHQUFHLENBQUM7UUFFeEMsU0FBUzBOLDhCQUE4QjFELE9BQU87WUFDNUM7Z0JBQ0UsSUFBSUEsU0FBUztvQkFDWCxJQUFJQyxRQUFRRCxRQUFRRSxNQUFNO29CQUMxQixJQUFJakksUUFBUTBILHFDQUFxQ0ssUUFBUTNHLElBQUksRUFBRTJHLFFBQVFHLE9BQU8sRUFBRUYsUUFBUUEsTUFBTTVHLElBQUksR0FBRztvQkFDckdyQix1QkFBdUJvSSxrQkFBa0IsQ0FBQ25JO2dCQUM1QyxPQUFPO29CQUNMRCx1QkFBdUJvSSxrQkFBa0IsQ0FBQztnQkFDNUM7WUFDRjtRQUNGO1FBRUEsSUFBSXVEO1FBRUo7WUFDRUEsZ0NBQWdDO1FBQ2xDO1FBQ0E7Ozs7OztDQU1DLEdBR0QsU0FBU0MsZUFBZUMsTUFBTTtZQUM1QjtnQkFDRSxPQUFPLE9BQU9BLFdBQVcsWUFBWUEsV0FBVyxRQUFRQSxPQUFPdkssUUFBUSxLQUFLeEQ7WUFDOUU7UUFDRjtRQUVBLFNBQVNnTztZQUNQO2dCQUNFLElBQUlqQyxrQkFBa0IvRCxPQUFPLEVBQUU7b0JBQzdCLElBQUkvRCxPQUFPRyx5QkFBeUIySCxrQkFBa0IvRCxPQUFPLENBQUN6RSxJQUFJO29CQUVsRSxJQUFJVSxNQUFNO3dCQUNSLE9BQU8scUNBQXFDQSxPQUFPO29CQUNyRDtnQkFDRjtnQkFFQSxPQUFPO1lBQ1Q7UUFDRjtRQUVBLFNBQVNnSywyQkFBMkJuSCxNQUFNO1lBQ3hDO2dCQUNFLElBQUlBLFdBQVdwRCxXQUFXO29CQUN4QixJQUFJd0ssV0FBV3BILE9BQU9vSCxRQUFRLENBQUMzRSxPQUFPLENBQUMsYUFBYTtvQkFDcEQsSUFBSTRFLGFBQWFySCxPQUFPcUgsVUFBVTtvQkFDbEMsT0FBTyw0QkFBNEJELFdBQVcsTUFBTUMsYUFBYTtnQkFDbkU7Z0JBRUEsT0FBTztZQUNUO1FBQ0Y7UUFDQTs7OztDQUlDLEdBR0QsSUFBSUMsd0JBQXdCLENBQUM7UUFFN0IsU0FBU0MsNkJBQTZCQyxVQUFVO1lBQzlDO2dCQUNFLElBQUl2SSxPQUFPaUk7Z0JBRVgsSUFBSSxDQUFDakksTUFBTTtvQkFDVCxJQUFJd0ksYUFBYW5LLHlCQUF5QmtLO29CQUUxQyxJQUFJQyxZQUFZO3dCQUNkeEksT0FBTyxnREFBZ0R3SSxhQUFhO29CQUN0RTtnQkFDRjtnQkFFQSxPQUFPeEk7WUFDVDtRQUNGO1FBQ0E7Ozs7Ozs7Ozs7Q0FVQyxHQUdELFNBQVN5SSxvQkFBb0J0RSxPQUFPLEVBQUVvRSxVQUFVO1lBQzlDO2dCQUNFLElBQUksQ0FBQ3BFLFFBQVFtRCxNQUFNLElBQUluRCxRQUFRbUQsTUFBTSxDQUFDb0IsU0FBUyxJQUFJdkUsUUFBUStCLEdBQUcsSUFBSSxNQUFNO29CQUN0RTtnQkFDRjtnQkFFQS9CLFFBQVFtRCxNQUFNLENBQUNvQixTQUFTLEdBQUc7Z0JBQzNCLElBQUlDLDRCQUE0QkwsNkJBQTZCQztnQkFFN0QsSUFBSUYscUJBQXFCLENBQUNNLDBCQUEwQixFQUFFO29CQUNwRDtnQkFDRjtnQkFFQU4scUJBQXFCLENBQUNNLDBCQUEwQixHQUFHLE1BQU0sNkVBQTZFO2dCQUN0SSxzRUFBc0U7Z0JBQ3RFLHNCQUFzQjtnQkFFdEIsSUFBSUMsYUFBYTtnQkFFakIsSUFBSXpFLFdBQVdBLFFBQVFFLE1BQU0sSUFBSUYsUUFBUUUsTUFBTSxLQUFLMkIsa0JBQWtCL0QsT0FBTyxFQUFFO29CQUM3RSx5REFBeUQ7b0JBQ3pEMkcsYUFBYSxpQ0FBaUN2Syx5QkFBeUI4RixRQUFRRSxNQUFNLENBQUM3RyxJQUFJLElBQUk7Z0JBQ2hHO2dCQUVBcUssOEJBQThCMUQ7Z0JBRTlCMUksTUFBTSwwREFBMEQsd0VBQXdFa04sMkJBQTJCQztnQkFFbktmLDhCQUE4QjtZQUNoQztRQUNGO1FBQ0E7Ozs7Ozs7O0NBUUMsR0FHRCxTQUFTZ0Isa0JBQWtCQyxJQUFJLEVBQUVQLFVBQVU7WUFDekM7Z0JBQ0UsSUFBSSxPQUFPTyxTQUFTLFlBQVksQ0FBQ0EsTUFBTTtvQkFDckM7Z0JBQ0Y7Z0JBRUEsSUFBSUEsS0FBS3JMLFFBQVEsS0FBS21LO3FCQUErQixJQUFJdkMsUUFBUXlELE9BQU87b0JBQ3RFLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxLQUFLak4sTUFBTSxFQUFFa04sSUFBSzt3QkFDcEMsSUFBSUMsUUFBUUYsSUFBSSxDQUFDQyxFQUFFO3dCQUVuQixJQUFJaEIsZUFBZWlCLFFBQVE7NEJBQ3pCUCxvQkFBb0JPLE9BQU9UO3dCQUM3QjtvQkFDRjtnQkFDRixPQUFPLElBQUlSLGVBQWVlLE9BQU87b0JBQy9CLCtDQUErQztvQkFDL0MsSUFBSUEsS0FBS3hCLE1BQU0sRUFBRTt3QkFDZndCLEtBQUt4QixNQUFNLENBQUNvQixTQUFTLEdBQUc7b0JBQzFCO2dCQUNGLE9BQU87b0JBQ0wsSUFBSU8sYUFBYTdOLGNBQWMwTjtvQkFFL0IsSUFBSSxPQUFPRyxlQUFlLFlBQVk7d0JBQ3BDLGlEQUFpRDt3QkFDakQsc0RBQXNEO3dCQUN0RCxJQUFJQSxlQUFlSCxLQUFLSSxPQUFPLEVBQUU7NEJBQy9CLElBQUloTyxXQUFXK04sV0FBV2xNLElBQUksQ0FBQytMOzRCQUMvQixJQUFJSzs0QkFFSixNQUFPLENBQUMsQ0FBQ0EsT0FBT2pPLFNBQVNrTyxJQUFJLEVBQUMsRUFBR0MsSUFBSSxDQUFFO2dDQUNyQyxJQUFJdEIsZUFBZW9CLEtBQUszSSxLQUFLLEdBQUc7b0NBQzlCaUksb0JBQW9CVSxLQUFLM0ksS0FBSyxFQUFFK0g7Z0NBQ2xDOzRCQUNGO3dCQUNGO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBOzs7OztDQUtDLEdBR0QsU0FBU2Usa0JBQWtCbkYsT0FBTztZQUNoQztnQkFDRSxJQUFJM0csT0FBTzJHLFFBQVEzRyxJQUFJO2dCQUV2QixJQUFJQSxTQUFTLFFBQVFBLFNBQVNHLGFBQWEsT0FBT0gsU0FBUyxVQUFVO29CQUNuRTtnQkFDRjtnQkFFQSxJQUFJQSxLQUFLQyxRQUFRLEtBQUttSyx3QkFBd0I7b0JBQzVDO2dCQUNGO2dCQUVBLElBQUkyQjtnQkFFSixJQUFJLE9BQU8vTCxTQUFTLFlBQVk7b0JBQzlCK0wsWUFBWS9MLEtBQUsrTCxTQUFTO2dCQUM1QixPQUFPLElBQUksT0FBTy9MLFNBQVMsWUFBYUEsQ0FBQUEsS0FBS0MsUUFBUSxLQUFLL0MsMEJBQTBCLDJDQUEyQztnQkFDL0gsNkNBQTZDO2dCQUM3QzhDLEtBQUtDLFFBQVEsS0FBSzVDLGVBQWMsR0FBSTtvQkFDbEMwTyxZQUFZL0wsS0FBSytMLFNBQVM7Z0JBQzVCLE9BQU87b0JBQ0w7Z0JBQ0Y7Z0JBRUEsSUFBSUEsV0FBVztvQkFDYiw4REFBOEQ7b0JBQzlELElBQUlyTCxPQUFPRyx5QkFBeUJiO29CQUNwQ2dILGVBQWUrRSxXQUFXcEYsUUFBUTlELEtBQUssRUFBRSxRQUFRbkMsTUFBTWlHO2dCQUN6RCxPQUFPLElBQUkzRyxLQUFLZ00sU0FBUyxLQUFLN0wsYUFBYSxDQUFDbUssK0JBQStCO29CQUN6RUEsZ0NBQWdDLE1BQU0sOERBQThEO29CQUVwRyxJQUFJMkIsUUFBUXBMLHlCQUF5QmI7b0JBRXJDL0IsTUFBTSx1R0FBdUdnTyxTQUFTO2dCQUN4SDtnQkFFQSxJQUFJLE9BQU9qTSxLQUFLa00sZUFBZSxLQUFLLGNBQWMsQ0FBQ2xNLEtBQUtrTSxlQUFlLENBQUNDLG9CQUFvQixFQUFFO29CQUM1RmxPLE1BQU0sK0RBQStEO2dCQUN2RTtZQUNGO1FBQ0Y7UUFDQTs7O0NBR0MsR0FHRCxTQUFTbU8sc0JBQXNCQyxRQUFRO1lBQ3JDO2dCQUNFLElBQUlDLE9BQU8zSyxPQUFPMkssSUFBSSxDQUFDRCxTQUFTeEosS0FBSztnQkFFckMsSUFBSyxJQUFJMEksSUFBSSxHQUFHQSxJQUFJZSxLQUFLak8sTUFBTSxFQUFFa04sSUFBSztvQkFDcEMsSUFBSTdDLE1BQU00RCxJQUFJLENBQUNmLEVBQUU7b0JBRWpCLElBQUk3QyxRQUFRLGNBQWNBLFFBQVEsT0FBTzt3QkFDdkMyQiw4QkFBOEJnQzt3QkFFOUJwTyxNQUFNLHFEQUFxRCw0REFBNER5Szt3QkFFdkgyQiw4QkFBOEI7d0JBQzlCO29CQUNGO2dCQUNGO2dCQUVBLElBQUlnQyxTQUFTMUQsR0FBRyxLQUFLLE1BQU07b0JBQ3pCMEIsOEJBQThCZ0M7b0JBRTlCcE8sTUFBTTtvQkFFTm9NLDhCQUE4QjtnQkFDaEM7WUFDRjtRQUNGO1FBRUEsSUFBSWtDLHdCQUF3QixDQUFDO1FBQzdCLFNBQVNDLGtCQUFrQnhNLElBQUksRUFBRTZDLEtBQUssRUFBRTZGLEdBQUcsRUFBRStELGdCQUFnQixFQUFFbEosTUFBTSxFQUFFZ0csSUFBSTtZQUN6RTtnQkFDRSxJQUFJbUQsWUFBWTNNLG1CQUFtQkMsT0FBTywwRUFBMEU7Z0JBQ3BILHFEQUFxRDtnQkFFckQsSUFBSSxDQUFDME0sV0FBVztvQkFDZCxJQUFJbEssT0FBTztvQkFFWCxJQUFJeEMsU0FBU0csYUFBYSxPQUFPSCxTQUFTLFlBQVlBLFNBQVMsUUFBUTJCLE9BQU8ySyxJQUFJLENBQUN0TSxNQUFNM0IsTUFBTSxLQUFLLEdBQUc7d0JBQ3JHbUUsUUFBUSwrREFBK0Q7b0JBQ3pFO29CQUVBLElBQUltSyxhQUFhakMsMkJBQTJCbkg7b0JBRTVDLElBQUlvSixZQUFZO3dCQUNkbkssUUFBUW1LO29CQUNWLE9BQU87d0JBQ0xuSyxRQUFRaUk7b0JBQ1Y7b0JBRUEsSUFBSW1DO29CQUVKLElBQUk1TSxTQUFTLE1BQU07d0JBQ2pCNE0sYUFBYTtvQkFDZixPQUFPLElBQUkvRSxRQUFRN0gsT0FBTzt3QkFDeEI0TSxhQUFhO29CQUNmLE9BQU8sSUFBSTVNLFNBQVNHLGFBQWFILEtBQUtDLFFBQVEsS0FBS3hELG9CQUFvQjt3QkFDckVtUSxhQUFhLE1BQU8vTCxDQUFBQSx5QkFBeUJiLEtBQUtBLElBQUksS0FBSyxTQUFRLElBQUs7d0JBQ3hFd0MsT0FBTztvQkFDVCxPQUFPO3dCQUNMb0ssYUFBYSxPQUFPNU07b0JBQ3RCO29CQUVBL0IsTUFBTSwwREFBMEQsNkRBQTZELDhCQUE4QjJPLFlBQVlwSztnQkFDeks7Z0JBRUEsSUFBSW1FLFVBQVVxRCxTQUFTaEssTUFBTTZDLE9BQU82RixLQUFLbkYsUUFBUWdHLE9BQU8sb0VBQW9FO2dCQUM1SCx5RUFBeUU7Z0JBRXpFLElBQUk1QyxXQUFXLE1BQU07b0JBQ25CLE9BQU9BO2dCQUNULEVBQUUsMEVBQTBFO2dCQUM1RSw0RUFBNEU7Z0JBQzVFLG1FQUFtRTtnQkFDbkUsMEVBQTBFO2dCQUMxRSx3Q0FBd0M7Z0JBR3hDLElBQUkrRixXQUFXO29CQUNiLElBQUlHLFdBQVdoSyxNQUFNZ0ssUUFBUTtvQkFFN0IsSUFBSUEsYUFBYTFNLFdBQVc7d0JBQzFCLElBQUlzTSxrQkFBa0I7NEJBQ3BCLElBQUk1RSxRQUFRZ0YsV0FBVztnQ0FDckIsSUFBSyxJQUFJdEIsSUFBSSxHQUFHQSxJQUFJc0IsU0FBU3hPLE1BQU0sRUFBRWtOLElBQUs7b0NBQ3hDRixrQkFBa0J3QixRQUFRLENBQUN0QixFQUFFLEVBQUV2TDtnQ0FDakM7Z0NBRUEsSUFBSTJCLE9BQU9vSSxNQUFNLEVBQUU7b0NBQ2pCcEksT0FBT29JLE1BQU0sQ0FBQzhDO2dDQUNoQjs0QkFDRixPQUFPO2dDQUNMNU8sTUFBTSwyREFBMkQsbUVBQW1FOzRCQUN0STt3QkFDRixPQUFPOzRCQUNMb04sa0JBQWtCd0IsVUFBVTdNO3dCQUM5QjtvQkFDRjtnQkFDRjtnQkFFQSxJQUFJdUcsZUFBZWhILElBQUksQ0FBQ3NELE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-speech-recognition/lib/NativeSpeechRecognition.js":
/*!******************************************************************************!*\
  !*** ./node_modules/react-speech-recognition/lib/NativeSpeechRecognition.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = exports.isNative = void 0;\nvar NativeSpeechRecognition =  true && (window.SpeechRecognition || window.webkitSpeechRecognition || window.mozSpeechRecognition || window.msSpeechRecognition || window.oSpeechRecognition);\nvar isNative = function isNative(SpeechRecognition) {\n    return SpeechRecognition === NativeSpeechRecognition;\n};\nexports.isNative = isNative;\nvar _default = NativeSpeechRecognition;\nexports[\"default\"] = _default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zcGVlY2gtcmVjb2duaXRpb24vbGliL05hdGl2ZVNwZWVjaFJlY29nbml0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxrQkFBa0IsR0FBR0EsZ0JBQWdCLEdBQUcsS0FBSztBQUM3QyxJQUFJRywwQkFBMEIsS0FBa0IsSUFBZ0JDLENBQUFBLE9BQU9DLGlCQUFpQixJQUFJRCxPQUFPRSx1QkFBdUIsSUFBSUYsT0FBT0csb0JBQW9CLElBQUlILE9BQU9JLG1CQUFtQixJQUFJSixPQUFPSyxrQkFBa0I7QUFFcE4sSUFBSVAsV0FBVyxTQUFTQSxTQUFTRyxpQkFBaUI7SUFDaEQsT0FBT0Esc0JBQXNCRjtBQUMvQjtBQUVBSCxnQkFBZ0IsR0FBR0U7QUFDbkIsSUFBSVEsV0FBV1A7QUFDZkgsa0JBQWtCLEdBQUdVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zcGVlY2gtcmVjb2duaXRpb24vbGliL05hdGl2ZVNwZWVjaFJlY29nbml0aW9uLmpzP2IyYjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGV4cG9ydHMuaXNOYXRpdmUgPSB2b2lkIDA7XG52YXIgTmF0aXZlU3BlZWNoUmVjb2duaXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAod2luZG93LlNwZWVjaFJlY29nbml0aW9uIHx8IHdpbmRvdy53ZWJraXRTcGVlY2hSZWNvZ25pdGlvbiB8fCB3aW5kb3cubW96U3BlZWNoUmVjb2duaXRpb24gfHwgd2luZG93Lm1zU3BlZWNoUmVjb2duaXRpb24gfHwgd2luZG93Lm9TcGVlY2hSZWNvZ25pdGlvbik7XG5cbnZhciBpc05hdGl2ZSA9IGZ1bmN0aW9uIGlzTmF0aXZlKFNwZWVjaFJlY29nbml0aW9uKSB7XG4gIHJldHVybiBTcGVlY2hSZWNvZ25pdGlvbiA9PT0gTmF0aXZlU3BlZWNoUmVjb2duaXRpb247XG59O1xuXG5leHBvcnRzLmlzTmF0aXZlID0gaXNOYXRpdmU7XG52YXIgX2RlZmF1bHQgPSBOYXRpdmVTcGVlY2hSZWNvZ25pdGlvbjtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaXNOYXRpdmUiLCJOYXRpdmVTcGVlY2hSZWNvZ25pdGlvbiIsIndpbmRvdyIsIlNwZWVjaFJlY29nbml0aW9uIiwid2Via2l0U3BlZWNoUmVjb2duaXRpb24iLCJtb3pTcGVlY2hSZWNvZ25pdGlvbiIsIm1zU3BlZWNoUmVjb2duaXRpb24iLCJvU3BlZWNoUmVjb2duaXRpb24iLCJfZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-speech-recognition/lib/NativeSpeechRecognition.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-speech-recognition/lib/RecognitionManager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/react-speech-recognition/lib/RecognitionManager.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _isAndroid = _interopRequireDefault(__webpack_require__(/*! ./isAndroid */ \"(app-pages-browser)/./node_modules/react-speech-recognition/lib/isAndroid.js\"));\nvar _utils = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/react-speech-recognition/lib/utils.js\");\nvar _NativeSpeechRecognition = __webpack_require__(/*! ./NativeSpeechRecognition */ \"(app-pages-browser)/./node_modules/react-speech-recognition/lib/NativeSpeechRecognition.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nvar RecognitionManager = /*#__PURE__*/ function() {\n    function RecognitionManager(SpeechRecognition) {\n        _classCallCheck(this, RecognitionManager);\n        this.recognition = null;\n        this.pauseAfterDisconnect = false;\n        this.interimTranscript = \"\";\n        this.finalTranscript = \"\";\n        this.listening = false;\n        this.isMicrophoneAvailable = true;\n        this.subscribers = {};\n        this.onStopListening = function() {};\n        this.previousResultWasFinalOnly = false;\n        this.resetTranscript = this.resetTranscript.bind(this);\n        this.startListening = this.startListening.bind(this);\n        this.stopListening = this.stopListening.bind(this);\n        this.abortListening = this.abortListening.bind(this);\n        this.setSpeechRecognition = this.setSpeechRecognition.bind(this);\n        this.disableRecognition = this.disableRecognition.bind(this);\n        this.setSpeechRecognition(SpeechRecognition);\n        if ((0, _isAndroid[\"default\"])()) {\n            this.updateFinalTranscript = (0, _utils.debounce)(this.updateFinalTranscript, 250, true);\n        }\n    }\n    _createClass(RecognitionManager, [\n        {\n            key: \"setSpeechRecognition\",\n            value: function setSpeechRecognition(SpeechRecognition) {\n                var browserSupportsRecogniser = !!SpeechRecognition && ((0, _NativeSpeechRecognition.isNative)(SpeechRecognition) || (0, _utils.browserSupportsPolyfills)());\n                if (browserSupportsRecogniser) {\n                    this.disableRecognition();\n                    this.recognition = new SpeechRecognition();\n                    this.recognition.continuous = false;\n                    this.recognition.interimResults = true;\n                    this.recognition.onresult = this.updateTranscript.bind(this);\n                    this.recognition.onend = this.onRecognitionDisconnect.bind(this);\n                    this.recognition.onerror = this.onError.bind(this);\n                }\n                this.emitBrowserSupportsSpeechRecognitionChange(browserSupportsRecogniser);\n            }\n        },\n        {\n            key: \"subscribe\",\n            value: function subscribe(id, callbacks) {\n                this.subscribers[id] = callbacks;\n            }\n        },\n        {\n            key: \"unsubscribe\",\n            value: function unsubscribe(id) {\n                delete this.subscribers[id];\n            }\n        },\n        {\n            key: \"emitListeningChange\",\n            value: function emitListeningChange(listening) {\n                var _this = this;\n                this.listening = listening;\n                Object.keys(this.subscribers).forEach(function(id) {\n                    var onListeningChange = _this.subscribers[id].onListeningChange;\n                    onListeningChange(listening);\n                });\n            }\n        },\n        {\n            key: \"emitMicrophoneAvailabilityChange\",\n            value: function emitMicrophoneAvailabilityChange(isMicrophoneAvailable) {\n                var _this2 = this;\n                this.isMicrophoneAvailable = isMicrophoneAvailable;\n                Object.keys(this.subscribers).forEach(function(id) {\n                    var onMicrophoneAvailabilityChange = _this2.subscribers[id].onMicrophoneAvailabilityChange;\n                    onMicrophoneAvailabilityChange(isMicrophoneAvailable);\n                });\n            }\n        },\n        {\n            key: \"emitTranscriptChange\",\n            value: function emitTranscriptChange(interimTranscript, finalTranscript) {\n                var _this3 = this;\n                Object.keys(this.subscribers).forEach(function(id) {\n                    var onTranscriptChange = _this3.subscribers[id].onTranscriptChange;\n                    onTranscriptChange(interimTranscript, finalTranscript);\n                });\n            }\n        },\n        {\n            key: \"emitClearTranscript\",\n            value: function emitClearTranscript() {\n                var _this4 = this;\n                Object.keys(this.subscribers).forEach(function(id) {\n                    var onClearTranscript = _this4.subscribers[id].onClearTranscript;\n                    onClearTranscript();\n                });\n            }\n        },\n        {\n            key: \"emitBrowserSupportsSpeechRecognitionChange\",\n            value: function emitBrowserSupportsSpeechRecognitionChange(browserSupportsSpeechRecognitionChange) {\n                var _this5 = this;\n                Object.keys(this.subscribers).forEach(function(id) {\n                    var _this5$subscribers$id = _this5.subscribers[id], onBrowserSupportsSpeechRecognitionChange = _this5$subscribers$id.onBrowserSupportsSpeechRecognitionChange, onBrowserSupportsContinuousListeningChange = _this5$subscribers$id.onBrowserSupportsContinuousListeningChange;\n                    onBrowserSupportsSpeechRecognitionChange(browserSupportsSpeechRecognitionChange);\n                    onBrowserSupportsContinuousListeningChange(browserSupportsSpeechRecognitionChange);\n                });\n            }\n        },\n        {\n            key: \"disconnect\",\n            value: function disconnect(disconnectType) {\n                if (this.recognition && this.listening) {\n                    switch(disconnectType){\n                        case \"ABORT\":\n                            this.pauseAfterDisconnect = true;\n                            this.abort();\n                            break;\n                        case \"RESET\":\n                            this.pauseAfterDisconnect = false;\n                            this.abort();\n                            break;\n                        case \"STOP\":\n                        default:\n                            this.pauseAfterDisconnect = true;\n                            this.stop();\n                    }\n                }\n            }\n        },\n        {\n            key: \"disableRecognition\",\n            value: function disableRecognition() {\n                if (this.recognition) {\n                    this.recognition.onresult = function() {};\n                    this.recognition.onend = function() {};\n                    this.recognition.onerror = function() {};\n                    if (this.listening) {\n                        this.stopListening();\n                    }\n                }\n            }\n        },\n        {\n            key: \"onError\",\n            value: function onError(event) {\n                if (event && event.error && event.error === \"not-allowed\") {\n                    this.emitMicrophoneAvailabilityChange(false);\n                    this.disableRecognition();\n                }\n            }\n        },\n        {\n            key: \"onRecognitionDisconnect\",\n            value: function onRecognitionDisconnect() {\n                this.onStopListening();\n                this.listening = false;\n                if (this.pauseAfterDisconnect) {\n                    this.emitListeningChange(false);\n                } else if (this.recognition) {\n                    if (this.recognition.continuous) {\n                        this.startListening({\n                            continuous: this.recognition.continuous\n                        });\n                    } else {\n                        this.emitListeningChange(false);\n                    }\n                }\n                this.pauseAfterDisconnect = false;\n            }\n        },\n        {\n            key: \"updateTranscript\",\n            value: function updateTranscript(_ref) {\n                var results = _ref.results, resultIndex = _ref.resultIndex;\n                var currentIndex = resultIndex === undefined ? results.length - 1 : resultIndex;\n                this.interimTranscript = \"\";\n                this.finalTranscript = \"\";\n                for(var i = currentIndex; i < results.length; ++i){\n                    if (results[i].isFinal && (!(0, _isAndroid[\"default\"])() || results[i][0].confidence > 0)) {\n                        this.updateFinalTranscript(results[i][0].transcript);\n                    } else {\n                        this.interimTranscript = (0, _utils.concatTranscripts)(this.interimTranscript, results[i][0].transcript);\n                    }\n                }\n                var isDuplicateResult = false;\n                if (this.interimTranscript === \"\" && this.finalTranscript !== \"\") {\n                    if (this.previousResultWasFinalOnly) {\n                        isDuplicateResult = true;\n                    }\n                    this.previousResultWasFinalOnly = true;\n                } else {\n                    this.previousResultWasFinalOnly = false;\n                }\n                if (!isDuplicateResult) {\n                    this.emitTranscriptChange(this.interimTranscript, this.finalTranscript);\n                }\n            }\n        },\n        {\n            key: \"updateFinalTranscript\",\n            value: function updateFinalTranscript(newFinalTranscript) {\n                this.finalTranscript = (0, _utils.concatTranscripts)(this.finalTranscript, newFinalTranscript);\n            }\n        },\n        {\n            key: \"resetTranscript\",\n            value: function resetTranscript() {\n                this.disconnect(\"RESET\");\n            }\n        },\n        {\n            key: \"startListening\",\n            value: function() {\n                var _startListening = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee() {\n                    var _ref2, _ref2$continuous, continuous, language, isContinuousChanged, isLanguageChanged, _args = arguments;\n                    return regeneratorRuntime.wrap(function _callee$(_context) {\n                        while(1){\n                            switch(_context.prev = _context.next){\n                                case 0:\n                                    _ref2 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, _ref2$continuous = _ref2.continuous, continuous = _ref2$continuous === void 0 ? false : _ref2$continuous, language = _ref2.language;\n                                    if (this.recognition) {\n                                        _context.next = 3;\n                                        break;\n                                    }\n                                    return _context.abrupt(\"return\");\n                                case 3:\n                                    isContinuousChanged = continuous !== this.recognition.continuous;\n                                    isLanguageChanged = language && language !== this.recognition.lang;\n                                    if (!(isContinuousChanged || isLanguageChanged)) {\n                                        _context.next = 11;\n                                        break;\n                                    }\n                                    if (!this.listening) {\n                                        _context.next = 9;\n                                        break;\n                                    }\n                                    _context.next = 9;\n                                    return this.stopListening();\n                                case 9:\n                                    this.recognition.continuous = isContinuousChanged ? continuous : this.recognition.continuous;\n                                    this.recognition.lang = isLanguageChanged ? language : this.recognition.lang;\n                                case 11:\n                                    if (this.listening) {\n                                        _context.next = 22;\n                                        break;\n                                    }\n                                    if (!this.recognition.continuous) {\n                                        this.resetTranscript();\n                                        this.emitClearTranscript();\n                                    }\n                                    _context.prev = 13;\n                                    _context.next = 16;\n                                    return this.start();\n                                case 16:\n                                    this.emitListeningChange(true);\n                                    _context.next = 22;\n                                    break;\n                                case 19:\n                                    _context.prev = 19;\n                                    _context.t0 = _context[\"catch\"](13);\n                                    // DOMExceptions indicate a redundant microphone start - safe to swallow\n                                    if (!(_context.t0 instanceof DOMException)) {\n                                        this.emitMicrophoneAvailabilityChange(false);\n                                    }\n                                case 22:\n                                case \"end\":\n                                    return _context.stop();\n                            }\n                        }\n                    }, _callee, this, [\n                        [\n                            13,\n                            19\n                        ]\n                    ]);\n                }));\n                function startListening() {\n                    return _startListening.apply(this, arguments);\n                }\n                return startListening;\n            }()\n        },\n        {\n            key: \"abortListening\",\n            value: function() {\n                var _abortListening = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee2() {\n                    var _this6 = this;\n                    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                        while(1){\n                            switch(_context2.prev = _context2.next){\n                                case 0:\n                                    this.disconnect(\"ABORT\");\n                                    this.emitListeningChange(false);\n                                    _context2.next = 4;\n                                    return new Promise(function(resolve) {\n                                        _this6.onStopListening = resolve;\n                                    });\n                                case 4:\n                                case \"end\":\n                                    return _context2.stop();\n                            }\n                        }\n                    }, _callee2, this);\n                }));\n                function abortListening() {\n                    return _abortListening.apply(this, arguments);\n                }\n                return abortListening;\n            }()\n        },\n        {\n            key: \"stopListening\",\n            value: function() {\n                var _stopListening = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee3() {\n                    var _this7 = this;\n                    return regeneratorRuntime.wrap(function _callee3$(_context3) {\n                        while(1){\n                            switch(_context3.prev = _context3.next){\n                                case 0:\n                                    this.disconnect(\"STOP\");\n                                    this.emitListeningChange(false);\n                                    _context3.next = 4;\n                                    return new Promise(function(resolve) {\n                                        _this7.onStopListening = resolve;\n                                    });\n                                case 4:\n                                case \"end\":\n                                    return _context3.stop();\n                            }\n                        }\n                    }, _callee3, this);\n                }));\n                function stopListening() {\n                    return _stopListening.apply(this, arguments);\n                }\n                return stopListening;\n            }()\n        },\n        {\n            key: \"getRecognition\",\n            value: function getRecognition() {\n                return this.recognition;\n            }\n        },\n        {\n            key: \"start\",\n            value: function() {\n                var _start = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee4() {\n                    return regeneratorRuntime.wrap(function _callee4$(_context4) {\n                        while(1){\n                            switch(_context4.prev = _context4.next){\n                                case 0:\n                                    if (!(this.recognition && !this.listening)) {\n                                        _context4.next = 4;\n                                        break;\n                                    }\n                                    _context4.next = 3;\n                                    return this.recognition.start();\n                                case 3:\n                                    this.listening = true;\n                                case 4:\n                                case \"end\":\n                                    return _context4.stop();\n                            }\n                        }\n                    }, _callee4, this);\n                }));\n                function start() {\n                    return _start.apply(this, arguments);\n                }\n                return start;\n            }()\n        },\n        {\n            key: \"stop\",\n            value: function stop() {\n                if (this.recognition && this.listening) {\n                    this.recognition.stop();\n                    this.listening = false;\n                }\n            }\n        },\n        {\n            key: \"abort\",\n            value: function abort() {\n                if (this.recognition && this.listening) {\n                    this.recognition.abort();\n                    this.listening = false;\n                }\n            }\n        }\n    ]);\n    return RecognitionManager;\n}();\nexports[\"default\"] = RecognitionManager;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zcGVlY2gtcmVjb2duaXRpb24vbGliL1JlY29nbml0aW9uTWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsa0JBQWtCLEdBQUcsS0FBSztBQUUxQixJQUFJRSxhQUFhQyx1QkFBdUJDLG1CQUFPQSxDQUFDLGlHQUFhO0FBRTdELElBQUlDLFNBQVNELG1CQUFPQSxDQUFDLHlGQUFTO0FBRTlCLElBQUlFLDJCQUEyQkYsbUJBQU9BLENBQUMsNkhBQTJCO0FBRWxFLFNBQVNELHVCQUF1QkksR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFBRztBQUVoRyxTQUFTRSxtQkFBbUJDLEdBQUcsRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxHQUFHLEVBQUVDLEdBQUc7SUFBSSxJQUFJO1FBQUUsSUFBSUMsT0FBT1AsR0FBRyxDQUFDSyxJQUFJLENBQUNDO1FBQU0sSUFBSWYsUUFBUWdCLEtBQUtoQixLQUFLO0lBQUUsRUFBRSxPQUFPaUIsT0FBTztRQUFFTixPQUFPTTtRQUFRO0lBQVE7SUFBRSxJQUFJRCxLQUFLRSxJQUFJLEVBQUU7UUFBRVIsUUFBUVY7SUFBUSxPQUFPO1FBQUVtQixRQUFRVCxPQUFPLENBQUNWLE9BQU9vQixJQUFJLENBQUNSLE9BQU9DO0lBQVM7QUFBRTtBQUV4USxTQUFTUSxrQkFBa0JDLEVBQUU7SUFBSSxPQUFPO1FBQWMsSUFBSUMsT0FBTyxJQUFJLEVBQUVDLE9BQU9DO1FBQVcsT0FBTyxJQUFJTixRQUFRLFNBQVVULE9BQU8sRUFBRUMsTUFBTTtZQUFJLElBQUlGLE1BQU1hLEdBQUdJLEtBQUssQ0FBQ0gsTUFBTUM7WUFBTyxTQUFTWixNQUFNWixLQUFLO2dCQUFJUSxtQkFBbUJD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UUFDRjtRQUFHO1lBQ0R0QyxLQUFLO1lBQ0xkLE9BQU8sU0FBU3VHO2dCQUNkLElBQUksSUFBSSxDQUFDdkQsV0FBVyxJQUFJLElBQUksQ0FBQ0ksU0FBUyxFQUFFO29CQUN0QyxJQUFJLENBQUNKLFdBQVcsQ0FBQ3VELEtBQUs7b0JBQ3RCLElBQUksQ0FBQ25ELFNBQVMsR0FBRztnQkFDbkI7WUFDRjtRQUNGO0tBQUU7SUFFRixPQUFPTjtBQUNUO0FBRUEvQyxrQkFBa0IsR0FBRytDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zcGVlY2gtcmVjb2duaXRpb24vbGliL1JlY29nbml0aW9uTWFuYWdlci5qcz9mMDU4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfaXNBbmRyb2lkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc0FuZHJvaWRcIikpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbnZhciBfTmF0aXZlU3BlZWNoUmVjb2duaXRpb24gPSByZXF1aXJlKFwiLi9OYXRpdmVTcGVlY2hSZWNvZ25pdGlvblwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTsgfSBmdW5jdGlvbiBfdGhyb3coZXJyKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpOyB9IF9uZXh0KHVuZGVmaW5lZCk7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIFJlY29nbml0aW9uTWFuYWdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlY29nbml0aW9uTWFuYWdlcihTcGVlY2hSZWNvZ25pdGlvbikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWNvZ25pdGlvbk1hbmFnZXIpO1xuXG4gICAgdGhpcy5yZWNvZ25pdGlvbiA9IG51bGw7XG4gICAgdGhpcy5wYXVzZUFmdGVyRGlzY29ubmVjdCA9IGZhbHNlO1xuICAgIHRoaXMuaW50ZXJpbVRyYW5zY3JpcHQgPSAnJztcbiAgICB0aGlzLmZpbmFsVHJhbnNjcmlwdCA9ICcnO1xuICAgIHRoaXMubGlzdGVuaW5nID0gZmFsc2U7XG4gICAgdGhpcy5pc01pY3JvcGhvbmVBdmFpbGFibGUgPSB0cnVlO1xuICAgIHRoaXMuc3Vic2NyaWJlcnMgPSB7fTtcblxuICAgIHRoaXMub25TdG9wTGlzdGVuaW5nID0gZnVuY3Rpb24gKCkge307XG5cbiAgICB0aGlzLnByZXZpb3VzUmVzdWx0V2FzRmluYWxPbmx5ID0gZmFsc2U7XG4gICAgdGhpcy5yZXNldFRyYW5zY3JpcHQgPSB0aGlzLnJlc2V0VHJhbnNjcmlwdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc3RhcnRMaXN0ZW5pbmcgPSB0aGlzLnN0YXJ0TGlzdGVuaW5nLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zdG9wTGlzdGVuaW5nID0gdGhpcy5zdG9wTGlzdGVuaW5nLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hYm9ydExpc3RlbmluZyA9IHRoaXMuYWJvcnRMaXN0ZW5pbmcuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNldFNwZWVjaFJlY29nbml0aW9uID0gdGhpcy5zZXRTcGVlY2hSZWNvZ25pdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZGlzYWJsZVJlY29nbml0aW9uID0gdGhpcy5kaXNhYmxlUmVjb2duaXRpb24uYmluZCh0aGlzKTtcbiAgICB0aGlzLnNldFNwZWVjaFJlY29nbml0aW9uKFNwZWVjaFJlY29nbml0aW9uKTtcblxuICAgIGlmICgoMCwgX2lzQW5kcm9pZFtcImRlZmF1bHRcIl0pKCkpIHtcbiAgICAgIHRoaXMudXBkYXRlRmluYWxUcmFuc2NyaXB0ID0gKDAsIF91dGlscy5kZWJvdW5jZSkodGhpcy51cGRhdGVGaW5hbFRyYW5zY3JpcHQsIDI1MCwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJlY29nbml0aW9uTWFuYWdlciwgW3tcbiAgICBrZXk6IFwic2V0U3BlZWNoUmVjb2duaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3BlZWNoUmVjb2duaXRpb24oU3BlZWNoUmVjb2duaXRpb24pIHtcbiAgICAgIHZhciBicm93c2VyU3VwcG9ydHNSZWNvZ25pc2VyID0gISFTcGVlY2hSZWNvZ25pdGlvbiAmJiAoKDAsIF9OYXRpdmVTcGVlY2hSZWNvZ25pdGlvbi5pc05hdGl2ZSkoU3BlZWNoUmVjb2duaXRpb24pIHx8ICgwLCBfdXRpbHMuYnJvd3NlclN1cHBvcnRzUG9seWZpbGxzKSgpKTtcblxuICAgICAgaWYgKGJyb3dzZXJTdXBwb3J0c1JlY29nbmlzZXIpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlUmVjb2duaXRpb24oKTtcbiAgICAgICAgdGhpcy5yZWNvZ25pdGlvbiA9IG5ldyBTcGVlY2hSZWNvZ25pdGlvbigpO1xuICAgICAgICB0aGlzLnJlY29nbml0aW9uLmNvbnRpbnVvdXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWNvZ25pdGlvbi5pbnRlcmltUmVzdWx0cyA9IHRydWU7XG4gICAgICAgIHRoaXMucmVjb2duaXRpb24ub25yZXN1bHQgPSB0aGlzLnVwZGF0ZVRyYW5zY3JpcHQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWNvZ25pdGlvbi5vbmVuZCA9IHRoaXMub25SZWNvZ25pdGlvbkRpc2Nvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWNvZ25pdGlvbi5vbmVycm9yID0gdGhpcy5vbkVycm9yLmJpbmQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW1pdEJyb3dzZXJTdXBwb3J0c1NwZWVjaFJlY29nbml0aW9uQ2hhbmdlKGJyb3dzZXJTdXBwb3J0c1JlY29nbmlzZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdWJzY3JpYmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3Vic2NyaWJlKGlkLCBjYWxsYmFja3MpIHtcbiAgICAgIHRoaXMuc3Vic2NyaWJlcnNbaWRdID0gY2FsbGJhY2tzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnN1YnNjcmliZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnN1YnNjcmliZShpZCkge1xuICAgICAgZGVsZXRlIHRoaXMuc3Vic2NyaWJlcnNbaWRdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbWl0TGlzdGVuaW5nQ2hhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXRMaXN0ZW5pbmdDaGFuZ2UobGlzdGVuaW5nKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmxpc3RlbmluZyA9IGxpc3RlbmluZztcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuc3Vic2NyaWJlcnMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBvbkxpc3RlbmluZ0NoYW5nZSA9IF90aGlzLnN1YnNjcmliZXJzW2lkXS5vbkxpc3RlbmluZ0NoYW5nZTtcbiAgICAgICAgb25MaXN0ZW5pbmdDaGFuZ2UobGlzdGVuaW5nKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbWl0TWljcm9waG9uZUF2YWlsYWJpbGl0eUNoYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0TWljcm9waG9uZUF2YWlsYWJpbGl0eUNoYW5nZShpc01pY3JvcGhvbmVBdmFpbGFibGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLmlzTWljcm9waG9uZUF2YWlsYWJsZSA9IGlzTWljcm9waG9uZUF2YWlsYWJsZTtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuc3Vic2NyaWJlcnMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBvbk1pY3JvcGhvbmVBdmFpbGFiaWxpdHlDaGFuZ2UgPSBfdGhpczIuc3Vic2NyaWJlcnNbaWRdLm9uTWljcm9waG9uZUF2YWlsYWJpbGl0eUNoYW5nZTtcbiAgICAgICAgb25NaWNyb3Bob25lQXZhaWxhYmlsaXR5Q2hhbmdlKGlzTWljcm9waG9uZUF2YWlsYWJsZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW1pdFRyYW5zY3JpcHRDaGFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdFRyYW5zY3JpcHRDaGFuZ2UoaW50ZXJpbVRyYW5zY3JpcHQsIGZpbmFsVHJhbnNjcmlwdCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuc3Vic2NyaWJlcnMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBvblRyYW5zY3JpcHRDaGFuZ2UgPSBfdGhpczMuc3Vic2NyaWJlcnNbaWRdLm9uVHJhbnNjcmlwdENoYW5nZTtcbiAgICAgICAgb25UcmFuc2NyaXB0Q2hhbmdlKGludGVyaW1UcmFuc2NyaXB0LCBmaW5hbFRyYW5zY3JpcHQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVtaXRDbGVhclRyYW5zY3JpcHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdENsZWFyVHJhbnNjcmlwdCgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnN1YnNjcmliZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgb25DbGVhclRyYW5zY3JpcHQgPSBfdGhpczQuc3Vic2NyaWJlcnNbaWRdLm9uQ2xlYXJUcmFuc2NyaXB0O1xuICAgICAgICBvbkNsZWFyVHJhbnNjcmlwdCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVtaXRCcm93c2VyU3VwcG9ydHNTcGVlY2hSZWNvZ25pdGlvbkNoYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0QnJvd3NlclN1cHBvcnRzU3BlZWNoUmVjb2duaXRpb25DaGFuZ2UoYnJvd3NlclN1cHBvcnRzU3BlZWNoUmVjb2duaXRpb25DaGFuZ2UpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnN1YnNjcmliZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgX3RoaXM1JHN1YnNjcmliZXJzJGlkID0gX3RoaXM1LnN1YnNjcmliZXJzW2lkXSxcbiAgICAgICAgICAgIG9uQnJvd3NlclN1cHBvcnRzU3BlZWNoUmVjb2duaXRpb25DaGFuZ2UgPSBfdGhpczUkc3Vic2NyaWJlcnMkaWQub25Ccm93c2VyU3VwcG9ydHNTcGVlY2hSZWNvZ25pdGlvbkNoYW5nZSxcbiAgICAgICAgICAgIG9uQnJvd3NlclN1cHBvcnRzQ29udGludW91c0xpc3RlbmluZ0NoYW5nZSA9IF90aGlzNSRzdWJzY3JpYmVycyRpZC5vbkJyb3dzZXJTdXBwb3J0c0NvbnRpbnVvdXNMaXN0ZW5pbmdDaGFuZ2U7XG4gICAgICAgIG9uQnJvd3NlclN1cHBvcnRzU3BlZWNoUmVjb2duaXRpb25DaGFuZ2UoYnJvd3NlclN1cHBvcnRzU3BlZWNoUmVjb2duaXRpb25DaGFuZ2UpO1xuICAgICAgICBvbkJyb3dzZXJTdXBwb3J0c0NvbnRpbnVvdXNMaXN0ZW5pbmdDaGFuZ2UoYnJvd3NlclN1cHBvcnRzU3BlZWNoUmVjb2duaXRpb25DaGFuZ2UpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc2Nvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzY29ubmVjdChkaXNjb25uZWN0VHlwZSkge1xuICAgICAgaWYgKHRoaXMucmVjb2duaXRpb24gJiYgdGhpcy5saXN0ZW5pbmcpIHtcbiAgICAgICAgc3dpdGNoIChkaXNjb25uZWN0VHlwZSkge1xuICAgICAgICAgIGNhc2UgJ0FCT1JUJzpcbiAgICAgICAgICAgIHRoaXMucGF1c2VBZnRlckRpc2Nvbm5lY3QgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5hYm9ydCgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdSRVNFVCc6XG4gICAgICAgICAgICB0aGlzLnBhdXNlQWZ0ZXJEaXNjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmFib3J0KCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1NUT1AnOlxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLnBhdXNlQWZ0ZXJEaXNjb25uZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc2FibGVSZWNvZ25pdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlUmVjb2duaXRpb24oKSB7XG4gICAgICBpZiAodGhpcy5yZWNvZ25pdGlvbikge1xuICAgICAgICB0aGlzLnJlY29nbml0aW9uLm9ucmVzdWx0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgdGhpcy5yZWNvZ25pdGlvbi5vbmVuZCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgIHRoaXMucmVjb2duaXRpb24ub25lcnJvciA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgIGlmICh0aGlzLmxpc3RlbmluZykge1xuICAgICAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25FcnJvcihldmVudCkge1xuICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LmVycm9yICYmIGV2ZW50LmVycm9yID09PSAnbm90LWFsbG93ZWQnKSB7XG4gICAgICAgIHRoaXMuZW1pdE1pY3JvcGhvbmVBdmFpbGFiaWxpdHlDaGFuZ2UoZmFsc2UpO1xuICAgICAgICB0aGlzLmRpc2FibGVSZWNvZ25pdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvblJlY29nbml0aW9uRGlzY29ubmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblJlY29nbml0aW9uRGlzY29ubmVjdCgpIHtcbiAgICAgIHRoaXMub25TdG9wTGlzdGVuaW5nKCk7XG4gICAgICB0aGlzLmxpc3RlbmluZyA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5wYXVzZUFmdGVyRGlzY29ubmVjdCkge1xuICAgICAgICB0aGlzLmVtaXRMaXN0ZW5pbmdDaGFuZ2UoZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnJlY29nbml0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY29nbml0aW9uLmNvbnRpbnVvdXMpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0TGlzdGVuaW5nKHtcbiAgICAgICAgICAgIGNvbnRpbnVvdXM6IHRoaXMucmVjb2duaXRpb24uY29udGludW91c1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZW1pdExpc3RlbmluZ0NoYW5nZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5wYXVzZUFmdGVyRGlzY29ubmVjdCA9IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVUcmFuc2NyaXB0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVRyYW5zY3JpcHQoX3JlZikge1xuICAgICAgdmFyIHJlc3VsdHMgPSBfcmVmLnJlc3VsdHMsXG4gICAgICAgICAgcmVzdWx0SW5kZXggPSBfcmVmLnJlc3VsdEluZGV4O1xuICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHJlc3VsdEluZGV4ID09PSB1bmRlZmluZWQgPyByZXN1bHRzLmxlbmd0aCAtIDEgOiByZXN1bHRJbmRleDtcbiAgICAgIHRoaXMuaW50ZXJpbVRyYW5zY3JpcHQgPSAnJztcbiAgICAgIHRoaXMuZmluYWxUcmFuc2NyaXB0ID0gJyc7XG5cbiAgICAgIGZvciAodmFyIGkgPSBjdXJyZW50SW5kZXg7IGkgPCByZXN1bHRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChyZXN1bHRzW2ldLmlzRmluYWwgJiYgKCEoMCwgX2lzQW5kcm9pZFtcImRlZmF1bHRcIl0pKCkgfHwgcmVzdWx0c1tpXVswXS5jb25maWRlbmNlID4gMCkpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUZpbmFsVHJhbnNjcmlwdChyZXN1bHRzW2ldWzBdLnRyYW5zY3JpcHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaW50ZXJpbVRyYW5zY3JpcHQgPSAoMCwgX3V0aWxzLmNvbmNhdFRyYW5zY3JpcHRzKSh0aGlzLmludGVyaW1UcmFuc2NyaXB0LCByZXN1bHRzW2ldWzBdLnRyYW5zY3JpcHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0R1cGxpY2F0ZVJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5pbnRlcmltVHJhbnNjcmlwdCA9PT0gJycgJiYgdGhpcy5maW5hbFRyYW5zY3JpcHQgIT09ICcnKSB7XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzUmVzdWx0V2FzRmluYWxPbmx5KSB7XG4gICAgICAgICAgaXNEdXBsaWNhdGVSZXN1bHQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmV2aW91c1Jlc3VsdFdhc0ZpbmFsT25seSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZXZpb3VzUmVzdWx0V2FzRmluYWxPbmx5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNEdXBsaWNhdGVSZXN1bHQpIHtcbiAgICAgICAgdGhpcy5lbWl0VHJhbnNjcmlwdENoYW5nZSh0aGlzLmludGVyaW1UcmFuc2NyaXB0LCB0aGlzLmZpbmFsVHJhbnNjcmlwdCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUZpbmFsVHJhbnNjcmlwdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVGaW5hbFRyYW5zY3JpcHQobmV3RmluYWxUcmFuc2NyaXB0KSB7XG4gICAgICB0aGlzLmZpbmFsVHJhbnNjcmlwdCA9ICgwLCBfdXRpbHMuY29uY2F0VHJhbnNjcmlwdHMpKHRoaXMuZmluYWxUcmFuc2NyaXB0LCBuZXdGaW5hbFRyYW5zY3JpcHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNldFRyYW5zY3JpcHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRUcmFuc2NyaXB0KCkge1xuICAgICAgdGhpcy5kaXNjb25uZWN0KCdSRVNFVCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydExpc3RlbmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3N0YXJ0TGlzdGVuaW5nID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICB2YXIgX3JlZjIsXG4gICAgICAgICAgICBfcmVmMiRjb250aW51b3VzLFxuICAgICAgICAgICAgY29udGludW91cyxcbiAgICAgICAgICAgIGxhbmd1YWdlLFxuICAgICAgICAgICAgaXNDb250aW51b3VzQ2hhbmdlZCxcbiAgICAgICAgICAgIGlzTGFuZ3VhZ2VDaGFuZ2VkLFxuICAgICAgICAgICAgX2FyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9yZWYyID0gX2FyZ3MubGVuZ3RoID4gMCAmJiBfYXJnc1swXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbMF0gOiB7fSwgX3JlZjIkY29udGludW91cyA9IF9yZWYyLmNvbnRpbnVvdXMsIGNvbnRpbnVvdXMgPSBfcmVmMiRjb250aW51b3VzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYyJGNvbnRpbnVvdXMsIGxhbmd1YWdlID0gX3JlZjIubGFuZ3VhZ2U7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWNvZ25pdGlvbikge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpc0NvbnRpbnVvdXNDaGFuZ2VkID0gY29udGludW91cyAhPT0gdGhpcy5yZWNvZ25pdGlvbi5jb250aW51b3VzO1xuICAgICAgICAgICAgICAgIGlzTGFuZ3VhZ2VDaGFuZ2VkID0gbGFuZ3VhZ2UgJiYgbGFuZ3VhZ2UgIT09IHRoaXMucmVjb2duaXRpb24ubGFuZztcblxuICAgICAgICAgICAgICAgIGlmICghKGlzQ29udGludW91c0NoYW5nZWQgfHwgaXNMYW5ndWFnZUNoYW5nZWQpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3BMaXN0ZW5pbmcoKTtcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvZ25pdGlvbi5jb250aW51b3VzID0gaXNDb250aW51b3VzQ2hhbmdlZCA/IGNvbnRpbnVvdXMgOiB0aGlzLnJlY29nbml0aW9uLmNvbnRpbnVvdXM7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvZ25pdGlvbi5sYW5nID0gaXNMYW5ndWFnZUNoYW5nZWQgPyBsYW5ndWFnZSA6IHRoaXMucmVjb2duaXRpb24ubGFuZztcblxuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlbmluZykge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlY29nbml0aW9uLmNvbnRpbnVvdXMpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRUcmFuc2NyaXB0KCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLmVtaXRDbGVhclRyYW5zY3JpcHQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTM7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE2O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0KCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRMaXN0ZW5pbmdDaGFuZ2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE5O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxMyk7XG5cbiAgICAgICAgICAgICAgICAvLyBET01FeGNlcHRpb25zIGluZGljYXRlIGEgcmVkdW5kYW50IG1pY3JvcGhvbmUgc3RhcnQgLSBzYWZlIHRvIHN3YWxsb3dcbiAgICAgICAgICAgICAgICBpZiAoIShfY29udGV4dC50MCBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdE1pY3JvcGhvbmVBdmFpbGFiaWxpdHlDaGFuZ2UoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMTMsIDE5XV0pO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzdGFydExpc3RlbmluZygpIHtcbiAgICAgICAgcmV0dXJuIF9zdGFydExpc3RlbmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhcnRMaXN0ZW5pbmc7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiYWJvcnRMaXN0ZW5pbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hYm9ydExpc3RlbmluZyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCdBQk9SVCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdExpc3RlbmluZ0NoYW5nZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXM2Lm9uU3RvcExpc3RlbmluZyA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGFib3J0TGlzdGVuaW5nKCkge1xuICAgICAgICByZXR1cm4gX2Fib3J0TGlzdGVuaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhYm9ydExpc3RlbmluZztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJzdG9wTGlzdGVuaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc3RvcExpc3RlbmluZyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoKSB7XG4gICAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCdTVE9QJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0TGlzdGVuaW5nQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczcub25TdG9wTGlzdGVuaW5nID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc3RvcExpc3RlbmluZygpIHtcbiAgICAgICAgcmV0dXJuIF9zdG9wTGlzdGVuaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdG9wTGlzdGVuaW5nO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImdldFJlY29nbml0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlY29nbml0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVjb2duaXRpb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc3RhcnQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KCkge1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICghKHRoaXMucmVjb2duaXRpb24gJiYgIXRoaXMubGlzdGVuaW5nKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY29nbml0aW9uLnN0YXJ0KCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU0LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBfc3RhcnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInN0b3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIGlmICh0aGlzLnJlY29nbml0aW9uICYmIHRoaXMubGlzdGVuaW5nKSB7XG4gICAgICAgIHRoaXMucmVjb2duaXRpb24uc3RvcCgpO1xuICAgICAgICB0aGlzLmxpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhYm9ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgIGlmICh0aGlzLnJlY29nbml0aW9uICYmIHRoaXMubGlzdGVuaW5nKSB7XG4gICAgICAgIHRoaXMucmVjb2duaXRpb24uYWJvcnQoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5pbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVjb2duaXRpb25NYW5hZ2VyO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFJlY29nbml0aW9uTWFuYWdlcjsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfaXNBbmRyb2lkIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfdXRpbHMiLCJfTmF0aXZlU3BlZWNoUmVjb2duaXRpb24iLCJvYmoiLCJfX2VzTW9kdWxlIiwiYXN5bmNHZW5lcmF0b3JTdGVwIiwiZ2VuIiwicmVzb2x2ZSIsInJlamVjdCIsIl9uZXh0IiwiX3Rocm93Iiwia2V5IiwiYXJnIiwiaW5mbyIsImVycm9yIiwiZG9uZSIsIlByb21pc2UiLCJ0aGVuIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJmbiIsInNlbGYiLCJhcmdzIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJlcnIiLCJ1bmRlZmluZWQiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwicHJvdG90eXBlIiwiUmVjb2duaXRpb25NYW5hZ2VyIiwiU3BlZWNoUmVjb2duaXRpb24iLCJyZWNvZ25pdGlvbiIsInBhdXNlQWZ0ZXJEaXNjb25uZWN0IiwiaW50ZXJpbVRyYW5zY3JpcHQiLCJmaW5hbFRyYW5zY3JpcHQiLCJsaXN0ZW5pbmciLCJpc01pY3JvcGhvbmVBdmFpbGFibGUiLCJzdWJzY3JpYmVycyIsIm9uU3RvcExpc3RlbmluZyIsInByZXZpb3VzUmVzdWx0V2FzRmluYWxPbmx5IiwicmVzZXRUcmFuc2NyaXB0IiwiYmluZCIsInN0YXJ0TGlzdGVuaW5nIiwic3RvcExpc3RlbmluZyIsImFib3J0TGlzdGVuaW5nIiwic2V0U3BlZWNoUmVjb2duaXRpb24iLCJkaXNhYmxlUmVjb2duaXRpb24iLCJ1cGRhdGVGaW5hbFRyYW5zY3JpcHQiLCJkZWJvdW5jZSIsImJyb3dzZXJTdXBwb3J0c1JlY29nbmlzZXIiLCJpc05hdGl2ZSIsImJyb3dzZXJTdXBwb3J0c1BvbHlmaWxscyIsImNvbnRpbnVvdXMiLCJpbnRlcmltUmVzdWx0cyIsIm9ucmVzdWx0IiwidXBkYXRlVHJhbnNjcmlwdCIsIm9uZW5kIiwib25SZWNvZ25pdGlvbkRpc2Nvbm5lY3QiLCJvbmVycm9yIiwib25FcnJvciIsImVtaXRCcm93c2VyU3VwcG9ydHNTcGVlY2hSZWNvZ25pdGlvbkNoYW5nZSIsInN1YnNjcmliZSIsImlkIiwiY2FsbGJhY2tzIiwidW5zdWJzY3JpYmUiLCJlbWl0TGlzdGVuaW5nQ2hhbmdlIiwiX3RoaXMiLCJrZXlzIiwiZm9yRWFjaCIsIm9uTGlzdGVuaW5nQ2hhbmdlIiwiZW1pdE1pY3JvcGhvbmVBdmFpbGFiaWxpdHlDaGFuZ2UiLCJfdGhpczIiLCJvbk1pY3JvcGhvbmVBdmFpbGFiaWxpdHlDaGFuZ2UiLCJlbWl0VHJhbnNjcmlwdENoYW5nZSIsIl90aGlzMyIsIm9uVHJhbnNjcmlwdENoYW5nZSIsImVtaXRDbGVhclRyYW5zY3JpcHQiLCJfdGhpczQiLCJvbkNsZWFyVHJhbnNjcmlwdCIsImJyb3dzZXJTdXBwb3J0c1NwZWVjaFJlY29nbml0aW9uQ2hhbmdlIiwiX3RoaXM1IiwiX3RoaXM1JHN1YnNjcmliZXJzJGlkIiwib25Ccm93c2VyU3VwcG9ydHNTcGVlY2hSZWNvZ25pdGlvbkNoYW5nZSIsIm9uQnJvd3NlclN1cHBvcnRzQ29udGludW91c0xpc3RlbmluZ0NoYW5nZSIsImRpc2Nvbm5lY3QiLCJkaXNjb25uZWN0VHlwZSIsImFib3J0Iiwic3RvcCIsImV2ZW50IiwiX3JlZiIsInJlc3VsdHMiLCJyZXN1bHRJbmRleCIsImN1cnJlbnRJbmRleCIsImlzRmluYWwiLCJjb25maWRlbmNlIiwidHJhbnNjcmlwdCIsImNvbmNhdFRyYW5zY3JpcHRzIiwiaXNEdXBsaWNhdGVSZXN1bHQiLCJuZXdGaW5hbFRyYW5zY3JpcHQiLCJfc3RhcnRMaXN0ZW5pbmciLCJyZWdlbmVyYXRvclJ1bnRpbWUiLCJtYXJrIiwiX2NhbGxlZSIsIl9yZWYyIiwiX3JlZjIkY29udGludW91cyIsImxhbmd1YWdlIiwiaXNDb250aW51b3VzQ2hhbmdlZCIsImlzTGFuZ3VhZ2VDaGFuZ2VkIiwiX2FyZ3MiLCJ3cmFwIiwiX2NhbGxlZSQiLCJfY29udGV4dCIsInByZXYiLCJuZXh0IiwiYWJydXB0IiwibGFuZyIsInN0YXJ0IiwidDAiLCJET01FeGNlcHRpb24iLCJfYWJvcnRMaXN0ZW5pbmciLCJfY2FsbGVlMiIsIl90aGlzNiIsIl9jYWxsZWUyJCIsIl9jb250ZXh0MiIsIl9zdG9wTGlzdGVuaW5nIiwiX2NhbGxlZTMiLCJfdGhpczciLCJfY2FsbGVlMyQiLCJfY29udGV4dDMiLCJnZXRSZWNvZ25pdGlvbiIsIl9zdGFydCIsIl9jYWxsZWU0IiwiX2NhbGxlZTQkIiwiX2NvbnRleHQ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-speech-recognition/lib/RecognitionManager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-speech-recognition/lib/SpeechRecognition.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-speech-recognition/lib/SpeechRecognition.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = exports.useSpeechRecognition = void 0;\nvar _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar _utils = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/react-speech-recognition/lib/utils.js\");\nvar _actions = __webpack_require__(/*! ./actions */ \"(app-pages-browser)/./node_modules/react-speech-recognition/lib/actions.js\");\nvar _reducers = __webpack_require__(/*! ./reducers */ \"(app-pages-browser)/./node_modules/react-speech-recognition/lib/reducers.js\");\nvar _RecognitionManager = _interopRequireDefault(__webpack_require__(/*! ./RecognitionManager */ \"(app-pages-browser)/./node_modules/react-speech-recognition/lib/RecognitionManager.js\"));\nvar _isAndroid = _interopRequireDefault(__webpack_require__(/*! ./isAndroid */ \"(app-pages-browser)/./node_modules/react-speech-recognition/lib/isAndroid.js\"));\nvar _NativeSpeechRecognition = _interopRequireDefault(__webpack_require__(/*! ./NativeSpeechRecognition */ \"(app-pages-browser)/./node_modules/react-speech-recognition/lib/NativeSpeechRecognition.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        \"default\": obj\n    };\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof(obj) {\n            return typeof obj;\n        };\n    } else {\n        _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n    }\n    return _typeof(obj);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nvar _browserSupportsSpeechRecognition = !!_NativeSpeechRecognition[\"default\"];\nvar _browserSupportsContinuousListening = _browserSupportsSpeechRecognition && !(0, _isAndroid[\"default\"])();\nvar recognitionManager;\nvar useSpeechRecognition = function useSpeechRecognition() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref$transcribing = _ref.transcribing, transcribing = _ref$transcribing === void 0 ? true : _ref$transcribing, _ref$clearTranscriptO = _ref.clearTranscriptOnListen, clearTranscriptOnListen = _ref$clearTranscriptO === void 0 ? true : _ref$clearTranscriptO, _ref$commands = _ref.commands, commands = _ref$commands === void 0 ? [] : _ref$commands;\n    var _useState = (0, _react.useState)(SpeechRecognition.getRecognitionManager()), _useState2 = _slicedToArray(_useState, 1), recognitionManager = _useState2[0];\n    var _useState3 = (0, _react.useState)(_browserSupportsSpeechRecognition), _useState4 = _slicedToArray(_useState3, 2), browserSupportsSpeechRecognition = _useState4[0], setBrowserSupportsSpeechRecognition = _useState4[1];\n    var _useState5 = (0, _react.useState)(_browserSupportsContinuousListening), _useState6 = _slicedToArray(_useState5, 2), browserSupportsContinuousListening = _useState6[0], setBrowserSupportsContinuousListening = _useState6[1];\n    var _useReducer = (0, _react.useReducer)(_reducers.transcriptReducer, {\n        interimTranscript: recognitionManager.interimTranscript,\n        finalTranscript: \"\"\n    }), _useReducer2 = _slicedToArray(_useReducer, 2), _useReducer2$ = _useReducer2[0], interimTranscript = _useReducer2$.interimTranscript, finalTranscript = _useReducer2$.finalTranscript, dispatch = _useReducer2[1];\n    var _useState7 = (0, _react.useState)(recognitionManager.listening), _useState8 = _slicedToArray(_useState7, 2), listening = _useState8[0], setListening = _useState8[1];\n    var _useState9 = (0, _react.useState)(recognitionManager.isMicrophoneAvailable), _useState10 = _slicedToArray(_useState9, 2), isMicrophoneAvailable = _useState10[0], setMicrophoneAvailable = _useState10[1];\n    var commandsRef = (0, _react.useRef)(commands);\n    commandsRef.current = commands;\n    var dispatchClearTranscript = function dispatchClearTranscript() {\n        dispatch((0, _actions.clearTranscript)());\n    };\n    var resetTranscript = (0, _react.useCallback)(function() {\n        recognitionManager.resetTranscript();\n        dispatchClearTranscript();\n    }, [\n        recognitionManager\n    ]);\n    var testFuzzyMatch = function testFuzzyMatch(command, input, fuzzyMatchingThreshold) {\n        var commandToString = _typeof(command) === \"object\" ? command.toString() : command;\n        var commandWithoutSpecials = commandToString.replace(/[&/\\\\#,+()!$~%.'\":*?<>{}]/g, \"\").replace(/  +/g, \" \").trim();\n        var howSimilar = (0, _utils.compareTwoStringsUsingDiceCoefficient)(commandWithoutSpecials, input);\n        if (howSimilar >= fuzzyMatchingThreshold) {\n            return {\n                command: command,\n                commandWithoutSpecials: commandWithoutSpecials,\n                howSimilar: howSimilar,\n                isFuzzyMatch: true\n            };\n        }\n        return null;\n    };\n    var testMatch = function testMatch(command, input) {\n        var pattern = (0, _utils.commandToRegExp)(command);\n        var result = pattern.exec(input);\n        if (result) {\n            return {\n                command: command,\n                parameters: result.slice(1)\n            };\n        }\n        return null;\n    };\n    var matchCommands = (0, _react.useCallback)(function(newInterimTranscript, newFinalTranscript) {\n        commandsRef.current.forEach(function(_ref2) {\n            var command = _ref2.command, callback = _ref2.callback, _ref2$matchInterim = _ref2.matchInterim, matchInterim = _ref2$matchInterim === void 0 ? false : _ref2$matchInterim, _ref2$isFuzzyMatch = _ref2.isFuzzyMatch, isFuzzyMatch = _ref2$isFuzzyMatch === void 0 ? false : _ref2$isFuzzyMatch, _ref2$fuzzyMatchingTh = _ref2.fuzzyMatchingThreshold, fuzzyMatchingThreshold = _ref2$fuzzyMatchingTh === void 0 ? 0.8 : _ref2$fuzzyMatchingTh, _ref2$bestMatchOnly = _ref2.bestMatchOnly, bestMatchOnly = _ref2$bestMatchOnly === void 0 ? false : _ref2$bestMatchOnly;\n            var input = !newFinalTranscript && matchInterim ? newInterimTranscript.trim() : newFinalTranscript.trim();\n            var subcommands = Array.isArray(command) ? command : [\n                command\n            ];\n            var results = subcommands.map(function(subcommand) {\n                if (isFuzzyMatch) {\n                    return testFuzzyMatch(subcommand, input, fuzzyMatchingThreshold);\n                }\n                return testMatch(subcommand, input);\n            }).filter(function(x) {\n                return x;\n            });\n            if (isFuzzyMatch && bestMatchOnly && results.length >= 2) {\n                results.sort(function(a, b) {\n                    return b.howSimilar - a.howSimilar;\n                });\n                var _results$ = results[0], _command = _results$.command, commandWithoutSpecials = _results$.commandWithoutSpecials, howSimilar = _results$.howSimilar;\n                callback(commandWithoutSpecials, input, howSimilar, {\n                    command: _command,\n                    resetTranscript: resetTranscript\n                });\n            } else {\n                results.forEach(function(result) {\n                    if (result.isFuzzyMatch) {\n                        var _command2 = result.command, _commandWithoutSpecials = result.commandWithoutSpecials, _howSimilar = result.howSimilar;\n                        callback(_commandWithoutSpecials, input, _howSimilar, {\n                            command: _command2,\n                            resetTranscript: resetTranscript\n                        });\n                    } else {\n                        var _command3 = result.command, parameters = result.parameters;\n                        callback.apply(void 0, _toConsumableArray(parameters).concat([\n                            {\n                                command: _command3,\n                                resetTranscript: resetTranscript\n                            }\n                        ]));\n                    }\n                });\n            }\n        });\n    }, [\n        resetTranscript\n    ]);\n    var handleTranscriptChange = (0, _react.useCallback)(function(newInterimTranscript, newFinalTranscript) {\n        if (transcribing) {\n            dispatch((0, _actions.appendTranscript)(newInterimTranscript, newFinalTranscript));\n        }\n        matchCommands(newInterimTranscript, newFinalTranscript);\n    }, [\n        matchCommands,\n        transcribing\n    ]);\n    var handleClearTranscript = (0, _react.useCallback)(function() {\n        if (clearTranscriptOnListen) {\n            dispatchClearTranscript();\n        }\n    }, [\n        clearTranscriptOnListen\n    ]);\n    (0, _react.useEffect)(function() {\n        var id = SpeechRecognition.counter;\n        SpeechRecognition.counter += 1;\n        var callbacks = {\n            onListeningChange: setListening,\n            onMicrophoneAvailabilityChange: setMicrophoneAvailable,\n            onTranscriptChange: handleTranscriptChange,\n            onClearTranscript: handleClearTranscript,\n            onBrowserSupportsSpeechRecognitionChange: setBrowserSupportsSpeechRecognition,\n            onBrowserSupportsContinuousListeningChange: setBrowserSupportsContinuousListening\n        };\n        recognitionManager.subscribe(id, callbacks);\n        return function() {\n            recognitionManager.unsubscribe(id);\n        };\n    }, [\n        transcribing,\n        clearTranscriptOnListen,\n        recognitionManager,\n        handleTranscriptChange,\n        handleClearTranscript\n    ]);\n    var transcript = (0, _utils.concatTranscripts)(finalTranscript, interimTranscript);\n    return {\n        transcript: transcript,\n        interimTranscript: interimTranscript,\n        finalTranscript: finalTranscript,\n        listening: listening,\n        isMicrophoneAvailable: isMicrophoneAvailable,\n        resetTranscript: resetTranscript,\n        browserSupportsSpeechRecognition: browserSupportsSpeechRecognition,\n        browserSupportsContinuousListening: browserSupportsContinuousListening\n    };\n};\nexports.useSpeechRecognition = useSpeechRecognition;\nvar SpeechRecognition = {\n    counter: 0,\n    applyPolyfill: function applyPolyfill(PolyfillSpeechRecognition) {\n        if (recognitionManager) {\n            recognitionManager.setSpeechRecognition(PolyfillSpeechRecognition);\n        } else {\n            recognitionManager = new _RecognitionManager[\"default\"](PolyfillSpeechRecognition);\n        }\n        var browserSupportsPolyfill = !!PolyfillSpeechRecognition && (0, _utils.browserSupportsPolyfills)();\n        _browserSupportsSpeechRecognition = browserSupportsPolyfill;\n        _browserSupportsContinuousListening = browserSupportsPolyfill;\n    },\n    removePolyfill: function removePolyfill() {\n        if (recognitionManager) {\n            recognitionManager.setSpeechRecognition(_NativeSpeechRecognition[\"default\"]);\n        } else {\n            recognitionManager = new _RecognitionManager[\"default\"](_NativeSpeechRecognition[\"default\"]);\n        }\n        _browserSupportsSpeechRecognition = !!_NativeSpeechRecognition[\"default\"];\n        _browserSupportsContinuousListening = _browserSupportsSpeechRecognition && !(0, _isAndroid[\"default\"])();\n    },\n    getRecognitionManager: function getRecognitionManager() {\n        if (!recognitionManager) {\n            recognitionManager = new _RecognitionManager[\"default\"](_NativeSpeechRecognition[\"default\"]);\n        }\n        return recognitionManager;\n    },\n    getRecognition: function getRecognition() {\n        var recognitionManager = SpeechRecognition.getRecognitionManager();\n        return recognitionManager.getRecognition();\n    },\n    startListening: function() {\n        var _startListening = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee() {\n            var _ref3, continuous, language, recognitionManager, _args = arguments;\n            return regeneratorRuntime.wrap(function _callee$(_context) {\n                while(1){\n                    switch(_context.prev = _context.next){\n                        case 0:\n                            _ref3 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, continuous = _ref3.continuous, language = _ref3.language;\n                            recognitionManager = SpeechRecognition.getRecognitionManager();\n                            _context.next = 4;\n                            return recognitionManager.startListening({\n                                continuous: continuous,\n                                language: language\n                            });\n                        case 4:\n                        case \"end\":\n                            return _context.stop();\n                    }\n                }\n            }, _callee);\n        }));\n        function startListening() {\n            return _startListening.apply(this, arguments);\n        }\n        return startListening;\n    }(),\n    stopListening: function() {\n        var _stopListening = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee2() {\n            var recognitionManager;\n            return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                while(1){\n                    switch(_context2.prev = _context2.next){\n                        case 0:\n                            recognitionManager = SpeechRecognition.getRecognitionManager();\n                            _context2.next = 3;\n                            return recognitionManager.stopListening();\n                        case 3:\n                        case \"end\":\n                            return _context2.stop();\n                    }\n                }\n            }, _callee2);\n        }));\n        function stopListening() {\n            return _stopListening.apply(this, arguments);\n        }\n        return stopListening;\n    }(),\n    abortListening: function() {\n        var _abortListening = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee3() {\n            var recognitionManager;\n            return regeneratorRuntime.wrap(function _callee3$(_context3) {\n                while(1){\n                    switch(_context3.prev = _context3.next){\n                        case 0:\n                            recognitionManager = SpeechRecognition.getRecognitionManager();\n                            _context3.next = 3;\n                            return recognitionManager.abortListening();\n                        case 3:\n                        case \"end\":\n                            return _context3.stop();\n                    }\n                }\n            }, _callee3);\n        }));\n        function abortListening() {\n            return _abortListening.apply(this, arguments);\n        }\n        return abortListening;\n    }(),\n    browserSupportsSpeechRecognition: function browserSupportsSpeechRecognition() {\n        return _browserSupportsSpeechRecognition;\n    },\n    browserSupportsContinuousListening: function browserSupportsContinuousListening() {\n        return _browserSupportsContinuousListening;\n    }\n};\nvar _default = SpeechRecognition;\nexports[\"default\"] = _default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zcGVlY2gtcmVjb2duaXRpb24vbGliL1NwZWVjaFJlY29nbml0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxrQkFBa0IsR0FBR0EsNEJBQTRCLEdBQUcsS0FBSztBQUV6RCxJQUFJRyxTQUFTQyxtQkFBT0EsQ0FBQyxtRkFBTztBQUU1QixJQUFJQyxTQUFTRCxtQkFBT0EsQ0FBQyx5RkFBUztBQUU5QixJQUFJRSxXQUFXRixtQkFBT0EsQ0FBQyw2RkFBVztBQUVsQyxJQUFJRyxZQUFZSCxtQkFBT0EsQ0FBQywrRkFBWTtBQUVwQyxJQUFJSSxzQkFBc0JDLHVCQUF1QkwsbUJBQU9BLENBQUMsbUhBQXNCO0FBRS9FLElBQUlNLGFBQWFELHVCQUF1QkwsbUJBQU9BLENBQUMsaUdBQWE7QUFFN0QsSUFBSU8sMkJBQTJCRix1QkFBdUJMLG1CQUFPQSxDQUFDLDZIQUEyQjtBQUV6RixTQUFTSyx1QkFBdUJHLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQUc7QUFFaEcsU0FBU0UsbUJBQW1CQyxHQUFHLEVBQUVDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsR0FBRyxFQUFFQyxHQUFHO0lBQUksSUFBSTtRQUFFLElBQUlDLE9BQU9QLEdBQUcsQ0FBQ0ssSUFBSSxDQUFDQztRQUFNLElBQUlwQixRQUFRcUIsS0FBS3JCLEtBQUs7SUFBRSxFQUFFLE9BQU9zQixPQUFPO1FBQUVOLE9BQU9NO1FBQVE7SUFBUTtJQUFFLElBQUlELEtBQUtFLElBQUksRUFBRTtRQUFFUixRQUFRZjtJQUFRLE9BQU87UUFBRXdCLFFBQVFULE9BQU8sQ0FBQ2YsT0FBT3lCLElBQUksQ0FBQ1IsT0FBT0M7SUFBUztBQUFFO0FBRXhRLFNBQVNR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QUNSLE9BQVFBLFVBQVVYLElBQUksR0FBR1csVUFBVTVJLElBQUk7d0JBQ3JDLEtBQUs7NEJBQ0hJLHFCQUFxQlUsa0JBQWtCQyxxQkFBcUI7NEJBQzVENkgsVUFBVTVJLElBQUksR0FBRzs0QkFDakIsT0FBT0ksbUJBQW1Cb0ksY0FBYzt3QkFFMUMsS0FBSzt3QkFDTCxLQUFLOzRCQUNILE9BQU9JLFVBQVVWLElBQUk7b0JBQ3pCO2dCQUNGO1lBQ0YsR0FBR1E7UUFDTDtRQUVBLFNBQVNGO1lBQ1AsT0FBT0MsZ0JBQWdCbkwsS0FBSyxDQUFDLElBQUksRUFBRUQ7UUFDckM7UUFFQSxPQUFPbUw7SUFDVDtJQUNBckgsa0NBQWtDLFNBQVNBO1FBQ3pDLE9BQU9qQjtJQUNUO0lBQ0FxQixvQ0FBb0MsU0FBU0E7UUFDM0MsT0FBT3BCO0lBQ1Q7QUFDRjtBQUNBLElBQUkwSSxXQUFXL0g7QUFDZnhGLGtCQUFrQixHQUFHdU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNwZWVjaC1yZWNvZ25pdGlvbi9saWIvU3BlZWNoUmVjb2duaXRpb24uanM/MTRhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZXhwb3J0cy51c2VTcGVlY2hSZWNvZ25pdGlvbiA9IHZvaWQgMDtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG52YXIgX2FjdGlvbnMgPSByZXF1aXJlKFwiLi9hY3Rpb25zXCIpO1xuXG52YXIgX3JlZHVjZXJzID0gcmVxdWlyZShcIi4vcmVkdWNlcnNcIik7XG5cbnZhciBfUmVjb2duaXRpb25NYW5hZ2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9SZWNvZ25pdGlvbk1hbmFnZXJcIikpO1xuXG52YXIgX2lzQW5kcm9pZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNBbmRyb2lkXCIpKTtcblxudmFyIF9OYXRpdmVTcGVlY2hSZWNvZ25pdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vTmF0aXZlU3BlZWNoUmVjb2duaXRpb25cIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7IH0gfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTsgZnVuY3Rpb24gX25leHQodmFsdWUpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpOyB9IGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7IH0gX25leHQodW5kZWZpbmVkKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG52YXIgX2Jyb3dzZXJTdXBwb3J0c1NwZWVjaFJlY29nbml0aW9uID0gISFfTmF0aXZlU3BlZWNoUmVjb2duaXRpb25bXCJkZWZhdWx0XCJdO1xuXG52YXIgX2Jyb3dzZXJTdXBwb3J0c0NvbnRpbnVvdXNMaXN0ZW5pbmcgPSBfYnJvd3NlclN1cHBvcnRzU3BlZWNoUmVjb2duaXRpb24gJiYgISgwLCBfaXNBbmRyb2lkW1wiZGVmYXVsdFwiXSkoKTtcblxudmFyIHJlY29nbml0aW9uTWFuYWdlcjtcblxudmFyIHVzZVNwZWVjaFJlY29nbml0aW9uID0gZnVuY3Rpb24gdXNlU3BlZWNoUmVjb2duaXRpb24oKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIF9yZWYkdHJhbnNjcmliaW5nID0gX3JlZi50cmFuc2NyaWJpbmcsXG4gICAgICB0cmFuc2NyaWJpbmcgPSBfcmVmJHRyYW5zY3JpYmluZyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkdHJhbnNjcmliaW5nLFxuICAgICAgX3JlZiRjbGVhclRyYW5zY3JpcHRPID0gX3JlZi5jbGVhclRyYW5zY3JpcHRPbkxpc3RlbixcbiAgICAgIGNsZWFyVHJhbnNjcmlwdE9uTGlzdGVuID0gX3JlZiRjbGVhclRyYW5zY3JpcHRPID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRjbGVhclRyYW5zY3JpcHRPLFxuICAgICAgX3JlZiRjb21tYW5kcyA9IF9yZWYuY29tbWFuZHMsXG4gICAgICBjb21tYW5kcyA9IF9yZWYkY29tbWFuZHMgPT09IHZvaWQgMCA/IFtdIDogX3JlZiRjb21tYW5kcztcblxuICB2YXIgX3VzZVN0YXRlID0gKDAsIF9yZWFjdC51c2VTdGF0ZSkoU3BlZWNoUmVjb2duaXRpb24uZ2V0UmVjb2duaXRpb25NYW5hZ2VyKCkpLFxuICAgICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMSksXG4gICAgICByZWNvZ25pdGlvbk1hbmFnZXIgPSBfdXNlU3RhdGUyWzBdO1xuXG4gIHZhciBfdXNlU3RhdGUzID0gKDAsIF9yZWFjdC51c2VTdGF0ZSkoX2Jyb3dzZXJTdXBwb3J0c1NwZWVjaFJlY29nbml0aW9uKSxcbiAgICAgIF91c2VTdGF0ZTQgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUzLCAyKSxcbiAgICAgIGJyb3dzZXJTdXBwb3J0c1NwZWVjaFJlY29nbml0aW9uID0gX3VzZVN0YXRlNFswXSxcbiAgICAgIHNldEJyb3dzZXJTdXBwb3J0c1NwZWVjaFJlY29nbml0aW9uID0gX3VzZVN0YXRlNFsxXTtcblxuICB2YXIgX3VzZVN0YXRlNSA9ICgwLCBfcmVhY3QudXNlU3RhdGUpKF9icm93c2VyU3VwcG9ydHNDb250aW51b3VzTGlzdGVuaW5nKSxcbiAgICAgIF91c2VTdGF0ZTYgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGU1LCAyKSxcbiAgICAgIGJyb3dzZXJTdXBwb3J0c0NvbnRpbnVvdXNMaXN0ZW5pbmcgPSBfdXNlU3RhdGU2WzBdLFxuICAgICAgc2V0QnJvd3NlclN1cHBvcnRzQ29udGludW91c0xpc3RlbmluZyA9IF91c2VTdGF0ZTZbMV07XG5cbiAgdmFyIF91c2VSZWR1Y2VyID0gKDAsIF9yZWFjdC51c2VSZWR1Y2VyKShfcmVkdWNlcnMudHJhbnNjcmlwdFJlZHVjZXIsIHtcbiAgICBpbnRlcmltVHJhbnNjcmlwdDogcmVjb2duaXRpb25NYW5hZ2VyLmludGVyaW1UcmFuc2NyaXB0LFxuICAgIGZpbmFsVHJhbnNjcmlwdDogJydcbiAgfSksXG4gICAgICBfdXNlUmVkdWNlcjIgPSBfc2xpY2VkVG9BcnJheShfdXNlUmVkdWNlciwgMiksXG4gICAgICBfdXNlUmVkdWNlcjIkID0gX3VzZVJlZHVjZXIyWzBdLFxuICAgICAgaW50ZXJpbVRyYW5zY3JpcHQgPSBfdXNlUmVkdWNlcjIkLmludGVyaW1UcmFuc2NyaXB0LFxuICAgICAgZmluYWxUcmFuc2NyaXB0ID0gX3VzZVJlZHVjZXIyJC5maW5hbFRyYW5zY3JpcHQsXG4gICAgICBkaXNwYXRjaCA9IF91c2VSZWR1Y2VyMlsxXTtcblxuICB2YXIgX3VzZVN0YXRlNyA9ICgwLCBfcmVhY3QudXNlU3RhdGUpKHJlY29nbml0aW9uTWFuYWdlci5saXN0ZW5pbmcpLFxuICAgICAgX3VzZVN0YXRlOCA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZTcsIDIpLFxuICAgICAgbGlzdGVuaW5nID0gX3VzZVN0YXRlOFswXSxcbiAgICAgIHNldExpc3RlbmluZyA9IF91c2VTdGF0ZThbMV07XG5cbiAgdmFyIF91c2VTdGF0ZTkgPSAoMCwgX3JlYWN0LnVzZVN0YXRlKShyZWNvZ25pdGlvbk1hbmFnZXIuaXNNaWNyb3Bob25lQXZhaWxhYmxlKSxcbiAgICAgIF91c2VTdGF0ZTEwID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlOSwgMiksXG4gICAgICBpc01pY3JvcGhvbmVBdmFpbGFibGUgPSBfdXNlU3RhdGUxMFswXSxcbiAgICAgIHNldE1pY3JvcGhvbmVBdmFpbGFibGUgPSBfdXNlU3RhdGUxMFsxXTtcblxuICB2YXIgY29tbWFuZHNSZWYgPSAoMCwgX3JlYWN0LnVzZVJlZikoY29tbWFuZHMpO1xuICBjb21tYW5kc1JlZi5jdXJyZW50ID0gY29tbWFuZHM7XG5cbiAgdmFyIGRpc3BhdGNoQ2xlYXJUcmFuc2NyaXB0ID0gZnVuY3Rpb24gZGlzcGF0Y2hDbGVhclRyYW5zY3JpcHQoKSB7XG4gICAgZGlzcGF0Y2goKDAsIF9hY3Rpb25zLmNsZWFyVHJhbnNjcmlwdCkoKSk7XG4gIH07XG5cbiAgdmFyIHJlc2V0VHJhbnNjcmlwdCA9ICgwLCBfcmVhY3QudXNlQ2FsbGJhY2spKGZ1bmN0aW9uICgpIHtcbiAgICByZWNvZ25pdGlvbk1hbmFnZXIucmVzZXRUcmFuc2NyaXB0KCk7XG4gICAgZGlzcGF0Y2hDbGVhclRyYW5zY3JpcHQoKTtcbiAgfSwgW3JlY29nbml0aW9uTWFuYWdlcl0pO1xuXG4gIHZhciB0ZXN0RnV6enlNYXRjaCA9IGZ1bmN0aW9uIHRlc3RGdXp6eU1hdGNoKGNvbW1hbmQsIGlucHV0LCBmdXp6eU1hdGNoaW5nVGhyZXNob2xkKSB7XG4gICAgdmFyIGNvbW1hbmRUb1N0cmluZyA9IF90eXBlb2YoY29tbWFuZCkgPT09ICdvYmplY3QnID8gY29tbWFuZC50b1N0cmluZygpIDogY29tbWFuZDtcbiAgICB2YXIgY29tbWFuZFdpdGhvdXRTcGVjaWFscyA9IGNvbW1hbmRUb1N0cmluZy5yZXBsYWNlKC9bJi9cXFxcIywrKCkhJH4lLidcIjoqPzw+e31dL2csICcnKS5yZXBsYWNlKC8gICsvZywgJyAnKS50cmltKCk7XG4gICAgdmFyIGhvd1NpbWlsYXIgPSAoMCwgX3V0aWxzLmNvbXBhcmVUd29TdHJpbmdzVXNpbmdEaWNlQ29lZmZpY2llbnQpKGNvbW1hbmRXaXRob3V0U3BlY2lhbHMsIGlucHV0KTtcblxuICAgIGlmIChob3dTaW1pbGFyID49IGZ1enp5TWF0Y2hpbmdUaHJlc2hvbGQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbW1hbmQ6IGNvbW1hbmQsXG4gICAgICAgIGNvbW1hbmRXaXRob3V0U3BlY2lhbHM6IGNvbW1hbmRXaXRob3V0U3BlY2lhbHMsXG4gICAgICAgIGhvd1NpbWlsYXI6IGhvd1NpbWlsYXIsXG4gICAgICAgIGlzRnV6enlNYXRjaDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICB2YXIgdGVzdE1hdGNoID0gZnVuY3Rpb24gdGVzdE1hdGNoKGNvbW1hbmQsIGlucHV0KSB7XG4gICAgdmFyIHBhdHRlcm4gPSAoMCwgX3V0aWxzLmNvbW1hbmRUb1JlZ0V4cCkoY29tbWFuZCk7XG4gICAgdmFyIHJlc3VsdCA9IHBhdHRlcm4uZXhlYyhpbnB1dCk7XG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb21tYW5kOiBjb21tYW5kLFxuICAgICAgICBwYXJhbWV0ZXJzOiByZXN1bHQuc2xpY2UoMSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIG1hdGNoQ29tbWFuZHMgPSAoMCwgX3JlYWN0LnVzZUNhbGxiYWNrKShmdW5jdGlvbiAobmV3SW50ZXJpbVRyYW5zY3JpcHQsIG5ld0ZpbmFsVHJhbnNjcmlwdCkge1xuICAgIGNvbW1hbmRzUmVmLmN1cnJlbnQuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgIHZhciBjb21tYW5kID0gX3JlZjIuY29tbWFuZCxcbiAgICAgICAgICBjYWxsYmFjayA9IF9yZWYyLmNhbGxiYWNrLFxuICAgICAgICAgIF9yZWYyJG1hdGNoSW50ZXJpbSA9IF9yZWYyLm1hdGNoSW50ZXJpbSxcbiAgICAgICAgICBtYXRjaEludGVyaW0gPSBfcmVmMiRtYXRjaEludGVyaW0gPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjIkbWF0Y2hJbnRlcmltLFxuICAgICAgICAgIF9yZWYyJGlzRnV6enlNYXRjaCA9IF9yZWYyLmlzRnV6enlNYXRjaCxcbiAgICAgICAgICBpc0Z1enp5TWF0Y2ggPSBfcmVmMiRpc0Z1enp5TWF0Y2ggPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjIkaXNGdXp6eU1hdGNoLFxuICAgICAgICAgIF9yZWYyJGZ1enp5TWF0Y2hpbmdUaCA9IF9yZWYyLmZ1enp5TWF0Y2hpbmdUaHJlc2hvbGQsXG4gICAgICAgICAgZnV6enlNYXRjaGluZ1RocmVzaG9sZCA9IF9yZWYyJGZ1enp5TWF0Y2hpbmdUaCA9PT0gdm9pZCAwID8gMC44IDogX3JlZjIkZnV6enlNYXRjaGluZ1RoLFxuICAgICAgICAgIF9yZWYyJGJlc3RNYXRjaE9ubHkgPSBfcmVmMi5iZXN0TWF0Y2hPbmx5LFxuICAgICAgICAgIGJlc3RNYXRjaE9ubHkgPSBfcmVmMiRiZXN0TWF0Y2hPbmx5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYyJGJlc3RNYXRjaE9ubHk7XG4gICAgICB2YXIgaW5wdXQgPSAhbmV3RmluYWxUcmFuc2NyaXB0ICYmIG1hdGNoSW50ZXJpbSA/IG5ld0ludGVyaW1UcmFuc2NyaXB0LnRyaW0oKSA6IG5ld0ZpbmFsVHJhbnNjcmlwdC50cmltKCk7XG4gICAgICB2YXIgc3ViY29tbWFuZHMgPSBBcnJheS5pc0FycmF5KGNvbW1hbmQpID8gY29tbWFuZCA6IFtjb21tYW5kXTtcbiAgICAgIHZhciByZXN1bHRzID0gc3ViY29tbWFuZHMubWFwKGZ1bmN0aW9uIChzdWJjb21tYW5kKSB7XG4gICAgICAgIGlmIChpc0Z1enp5TWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gdGVzdEZ1enp5TWF0Y2goc3ViY29tbWFuZCwgaW5wdXQsIGZ1enp5TWF0Y2hpbmdUaHJlc2hvbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRlc3RNYXRjaChzdWJjb21tYW5kLCBpbnB1dCk7XG4gICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzRnV6enlNYXRjaCAmJiBiZXN0TWF0Y2hPbmx5ICYmIHJlc3VsdHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgcmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGIuaG93U2ltaWxhciAtIGEuaG93U2ltaWxhcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfcmVzdWx0cyQgPSByZXN1bHRzWzBdLFxuICAgICAgICAgICAgX2NvbW1hbmQgPSBfcmVzdWx0cyQuY29tbWFuZCxcbiAgICAgICAgICAgIGNvbW1hbmRXaXRob3V0U3BlY2lhbHMgPSBfcmVzdWx0cyQuY29tbWFuZFdpdGhvdXRTcGVjaWFscyxcbiAgICAgICAgICAgIGhvd1NpbWlsYXIgPSBfcmVzdWx0cyQuaG93U2ltaWxhcjtcbiAgICAgICAgY2FsbGJhY2soY29tbWFuZFdpdGhvdXRTcGVjaWFscywgaW5wdXQsIGhvd1NpbWlsYXIsIHtcbiAgICAgICAgICBjb21tYW5kOiBfY29tbWFuZCxcbiAgICAgICAgICByZXNldFRyYW5zY3JpcHQ6IHJlc2V0VHJhbnNjcmlwdFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pc0Z1enp5TWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBfY29tbWFuZDIgPSByZXN1bHQuY29tbWFuZCxcbiAgICAgICAgICAgICAgICBfY29tbWFuZFdpdGhvdXRTcGVjaWFscyA9IHJlc3VsdC5jb21tYW5kV2l0aG91dFNwZWNpYWxzLFxuICAgICAgICAgICAgICAgIF9ob3dTaW1pbGFyID0gcmVzdWx0Lmhvd1NpbWlsYXI7XG4gICAgICAgICAgICBjYWxsYmFjayhfY29tbWFuZFdpdGhvdXRTcGVjaWFscywgaW5wdXQsIF9ob3dTaW1pbGFyLCB7XG4gICAgICAgICAgICAgIGNvbW1hbmQ6IF9jb21tYW5kMixcbiAgICAgICAgICAgICAgcmVzZXRUcmFuc2NyaXB0OiByZXNldFRyYW5zY3JpcHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX2NvbW1hbmQzID0gcmVzdWx0LmNvbW1hbmQsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycyA9IHJlc3VsdC5wYXJhbWV0ZXJzO1xuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkocGFyYW1ldGVycykuY29uY2F0KFt7XG4gICAgICAgICAgICAgIGNvbW1hbmQ6IF9jb21tYW5kMyxcbiAgICAgICAgICAgICAgcmVzZXRUcmFuc2NyaXB0OiByZXNldFRyYW5zY3JpcHRcbiAgICAgICAgICAgIH1dKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW3Jlc2V0VHJhbnNjcmlwdF0pO1xuICB2YXIgaGFuZGxlVHJhbnNjcmlwdENoYW5nZSA9ICgwLCBfcmVhY3QudXNlQ2FsbGJhY2spKGZ1bmN0aW9uIChuZXdJbnRlcmltVHJhbnNjcmlwdCwgbmV3RmluYWxUcmFuc2NyaXB0KSB7XG4gICAgaWYgKHRyYW5zY3JpYmluZykge1xuICAgICAgZGlzcGF0Y2goKDAsIF9hY3Rpb25zLmFwcGVuZFRyYW5zY3JpcHQpKG5ld0ludGVyaW1UcmFuc2NyaXB0LCBuZXdGaW5hbFRyYW5zY3JpcHQpKTtcbiAgICB9XG5cbiAgICBtYXRjaENvbW1hbmRzKG5ld0ludGVyaW1UcmFuc2NyaXB0LCBuZXdGaW5hbFRyYW5zY3JpcHQpO1xuICB9LCBbbWF0Y2hDb21tYW5kcywgdHJhbnNjcmliaW5nXSk7XG4gIHZhciBoYW5kbGVDbGVhclRyYW5zY3JpcHQgPSAoMCwgX3JlYWN0LnVzZUNhbGxiYWNrKShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNsZWFyVHJhbnNjcmlwdE9uTGlzdGVuKSB7XG4gICAgICBkaXNwYXRjaENsZWFyVHJhbnNjcmlwdCgpO1xuICAgIH1cbiAgfSwgW2NsZWFyVHJhbnNjcmlwdE9uTGlzdGVuXSk7XG4gICgwLCBfcmVhY3QudXNlRWZmZWN0KShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkID0gU3BlZWNoUmVjb2duaXRpb24uY291bnRlcjtcbiAgICBTcGVlY2hSZWNvZ25pdGlvbi5jb3VudGVyICs9IDE7XG4gICAgdmFyIGNhbGxiYWNrcyA9IHtcbiAgICAgIG9uTGlzdGVuaW5nQ2hhbmdlOiBzZXRMaXN0ZW5pbmcsXG4gICAgICBvbk1pY3JvcGhvbmVBdmFpbGFiaWxpdHlDaGFuZ2U6IHNldE1pY3JvcGhvbmVBdmFpbGFibGUsXG4gICAgICBvblRyYW5zY3JpcHRDaGFuZ2U6IGhhbmRsZVRyYW5zY3JpcHRDaGFuZ2UsXG4gICAgICBvbkNsZWFyVHJhbnNjcmlwdDogaGFuZGxlQ2xlYXJUcmFuc2NyaXB0LFxuICAgICAgb25Ccm93c2VyU3VwcG9ydHNTcGVlY2hSZWNvZ25pdGlvbkNoYW5nZTogc2V0QnJvd3NlclN1cHBvcnRzU3BlZWNoUmVjb2duaXRpb24sXG4gICAgICBvbkJyb3dzZXJTdXBwb3J0c0NvbnRpbnVvdXNMaXN0ZW5pbmdDaGFuZ2U6IHNldEJyb3dzZXJTdXBwb3J0c0NvbnRpbnVvdXNMaXN0ZW5pbmdcbiAgICB9O1xuICAgIHJlY29nbml0aW9uTWFuYWdlci5zdWJzY3JpYmUoaWQsIGNhbGxiYWNrcyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlY29nbml0aW9uTWFuYWdlci51bnN1YnNjcmliZShpZCk7XG4gICAgfTtcbiAgfSwgW3RyYW5zY3JpYmluZywgY2xlYXJUcmFuc2NyaXB0T25MaXN0ZW4sIHJlY29nbml0aW9uTWFuYWdlciwgaGFuZGxlVHJhbnNjcmlwdENoYW5nZSwgaGFuZGxlQ2xlYXJUcmFuc2NyaXB0XSk7XG4gIHZhciB0cmFuc2NyaXB0ID0gKDAsIF91dGlscy5jb25jYXRUcmFuc2NyaXB0cykoZmluYWxUcmFuc2NyaXB0LCBpbnRlcmltVHJhbnNjcmlwdCk7XG4gIHJldHVybiB7XG4gICAgdHJhbnNjcmlwdDogdHJhbnNjcmlwdCxcbiAgICBpbnRlcmltVHJhbnNjcmlwdDogaW50ZXJpbVRyYW5zY3JpcHQsXG4gICAgZmluYWxUcmFuc2NyaXB0OiBmaW5hbFRyYW5zY3JpcHQsXG4gICAgbGlzdGVuaW5nOiBsaXN0ZW5pbmcsXG4gICAgaXNNaWNyb3Bob25lQXZhaWxhYmxlOiBpc01pY3JvcGhvbmVBdmFpbGFibGUsXG4gICAgcmVzZXRUcmFuc2NyaXB0OiByZXNldFRyYW5zY3JpcHQsXG4gICAgYnJvd3NlclN1cHBvcnRzU3BlZWNoUmVjb2duaXRpb246IGJyb3dzZXJTdXBwb3J0c1NwZWVjaFJlY29nbml0aW9uLFxuICAgIGJyb3dzZXJTdXBwb3J0c0NvbnRpbnVvdXNMaXN0ZW5pbmc6IGJyb3dzZXJTdXBwb3J0c0NvbnRpbnVvdXNMaXN0ZW5pbmdcbiAgfTtcbn07XG5cbmV4cG9ydHMudXNlU3BlZWNoUmVjb2duaXRpb24gPSB1c2VTcGVlY2hSZWNvZ25pdGlvbjtcbnZhciBTcGVlY2hSZWNvZ25pdGlvbiA9IHtcbiAgY291bnRlcjogMCxcbiAgYXBwbHlQb2x5ZmlsbDogZnVuY3Rpb24gYXBwbHlQb2x5ZmlsbChQb2x5ZmlsbFNwZWVjaFJlY29nbml0aW9uKSB7XG4gICAgaWYgKHJlY29nbml0aW9uTWFuYWdlcikge1xuICAgICAgcmVjb2duaXRpb25NYW5hZ2VyLnNldFNwZWVjaFJlY29nbml0aW9uKFBvbHlmaWxsU3BlZWNoUmVjb2duaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNvZ25pdGlvbk1hbmFnZXIgPSBuZXcgX1JlY29nbml0aW9uTWFuYWdlcltcImRlZmF1bHRcIl0oUG9seWZpbGxTcGVlY2hSZWNvZ25pdGlvbik7XG4gICAgfVxuXG4gICAgdmFyIGJyb3dzZXJTdXBwb3J0c1BvbHlmaWxsID0gISFQb2x5ZmlsbFNwZWVjaFJlY29nbml0aW9uICYmICgwLCBfdXRpbHMuYnJvd3NlclN1cHBvcnRzUG9seWZpbGxzKSgpO1xuICAgIF9icm93c2VyU3VwcG9ydHNTcGVlY2hSZWNvZ25pdGlvbiA9IGJyb3dzZXJTdXBwb3J0c1BvbHlmaWxsO1xuICAgIF9icm93c2VyU3VwcG9ydHNDb250aW51b3VzTGlzdGVuaW5nID0gYnJvd3NlclN1cHBvcnRzUG9seWZpbGw7XG4gIH0sXG4gIHJlbW92ZVBvbHlmaWxsOiBmdW5jdGlvbiByZW1vdmVQb2x5ZmlsbCgpIHtcbiAgICBpZiAocmVjb2duaXRpb25NYW5hZ2VyKSB7XG4gICAgICByZWNvZ25pdGlvbk1hbmFnZXIuc2V0U3BlZWNoUmVjb2duaXRpb24oX05hdGl2ZVNwZWVjaFJlY29nbml0aW9uW1wiZGVmYXVsdFwiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY29nbml0aW9uTWFuYWdlciA9IG5ldyBfUmVjb2duaXRpb25NYW5hZ2VyW1wiZGVmYXVsdFwiXShfTmF0aXZlU3BlZWNoUmVjb2duaXRpb25bXCJkZWZhdWx0XCJdKTtcbiAgICB9XG5cbiAgICBfYnJvd3NlclN1cHBvcnRzU3BlZWNoUmVjb2duaXRpb24gPSAhIV9OYXRpdmVTcGVlY2hSZWNvZ25pdGlvbltcImRlZmF1bHRcIl07XG4gICAgX2Jyb3dzZXJTdXBwb3J0c0NvbnRpbnVvdXNMaXN0ZW5pbmcgPSBfYnJvd3NlclN1cHBvcnRzU3BlZWNoUmVjb2duaXRpb24gJiYgISgwLCBfaXNBbmRyb2lkW1wiZGVmYXVsdFwiXSkoKTtcbiAgfSxcbiAgZ2V0UmVjb2duaXRpb25NYW5hZ2VyOiBmdW5jdGlvbiBnZXRSZWNvZ25pdGlvbk1hbmFnZXIoKSB7XG4gICAgaWYgKCFyZWNvZ25pdGlvbk1hbmFnZXIpIHtcbiAgICAgIHJlY29nbml0aW9uTWFuYWdlciA9IG5ldyBfUmVjb2duaXRpb25NYW5hZ2VyW1wiZGVmYXVsdFwiXShfTmF0aXZlU3BlZWNoUmVjb2duaXRpb25bXCJkZWZhdWx0XCJdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjb2duaXRpb25NYW5hZ2VyO1xuICB9LFxuICBnZXRSZWNvZ25pdGlvbjogZnVuY3Rpb24gZ2V0UmVjb2duaXRpb24oKSB7XG4gICAgdmFyIHJlY29nbml0aW9uTWFuYWdlciA9IFNwZWVjaFJlY29nbml0aW9uLmdldFJlY29nbml0aW9uTWFuYWdlcigpO1xuICAgIHJldHVybiByZWNvZ25pdGlvbk1hbmFnZXIuZ2V0UmVjb2duaXRpb24oKTtcbiAgfSxcbiAgc3RhcnRMaXN0ZW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3N0YXJ0TGlzdGVuaW5nID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgdmFyIF9yZWYzLFxuICAgICAgICAgIGNvbnRpbnVvdXMsXG4gICAgICAgICAgbGFuZ3VhZ2UsXG4gICAgICAgICAgcmVjb2duaXRpb25NYW5hZ2VyLFxuICAgICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9yZWYzID0gX2FyZ3MubGVuZ3RoID4gMCAmJiBfYXJnc1swXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbMF0gOiB7fSwgY29udGludW91cyA9IF9yZWYzLmNvbnRpbnVvdXMsIGxhbmd1YWdlID0gX3JlZjMubGFuZ3VhZ2U7XG4gICAgICAgICAgICAgIHJlY29nbml0aW9uTWFuYWdlciA9IFNwZWVjaFJlY29nbml0aW9uLmdldFJlY29nbml0aW9uTWFuYWdlcigpO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlY29nbml0aW9uTWFuYWdlci5zdGFydExpc3RlbmluZyh7XG4gICAgICAgICAgICAgICAgY29udGludW91czogY29udGludW91cyxcbiAgICAgICAgICAgICAgICBsYW5ndWFnZTogbGFuZ3VhZ2VcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIHN0YXJ0TGlzdGVuaW5nKCkge1xuICAgICAgcmV0dXJuIF9zdGFydExpc3RlbmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFydExpc3RlbmluZztcbiAgfSgpLFxuICBzdG9wTGlzdGVuaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9zdG9wTGlzdGVuaW5nID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgIHZhciByZWNvZ25pdGlvbk1hbmFnZXI7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICByZWNvZ25pdGlvbk1hbmFnZXIgPSBTcGVlY2hSZWNvZ25pdGlvbi5nZXRSZWNvZ25pdGlvbk1hbmFnZXIoKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gcmVjb2duaXRpb25NYW5hZ2VyLnN0b3BMaXN0ZW5pbmcoKTtcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBzdG9wTGlzdGVuaW5nKCkge1xuICAgICAgcmV0dXJuIF9zdG9wTGlzdGVuaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0b3BMaXN0ZW5pbmc7XG4gIH0oKSxcbiAgYWJvcnRMaXN0ZW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2Fib3J0TGlzdGVuaW5nID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMygpIHtcbiAgICAgIHZhciByZWNvZ25pdGlvbk1hbmFnZXI7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICByZWNvZ25pdGlvbk1hbmFnZXIgPSBTcGVlY2hSZWNvZ25pdGlvbi5nZXRSZWNvZ25pdGlvbk1hbmFnZXIoKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gcmVjb2duaXRpb25NYW5hZ2VyLmFib3J0TGlzdGVuaW5nKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlMyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gYWJvcnRMaXN0ZW5pbmcoKSB7XG4gICAgICByZXR1cm4gX2Fib3J0TGlzdGVuaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFib3J0TGlzdGVuaW5nO1xuICB9KCksXG4gIGJyb3dzZXJTdXBwb3J0c1NwZWVjaFJlY29nbml0aW9uOiBmdW5jdGlvbiBicm93c2VyU3VwcG9ydHNTcGVlY2hSZWNvZ25pdGlvbigpIHtcbiAgICByZXR1cm4gX2Jyb3dzZXJTdXBwb3J0c1NwZWVjaFJlY29nbml0aW9uO1xuICB9LFxuICBicm93c2VyU3VwcG9ydHNDb250aW51b3VzTGlzdGVuaW5nOiBmdW5jdGlvbiBicm93c2VyU3VwcG9ydHNDb250aW51b3VzTGlzdGVuaW5nKCkge1xuICAgIHJldHVybiBfYnJvd3NlclN1cHBvcnRzQ29udGludW91c0xpc3RlbmluZztcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IFNwZWVjaFJlY29nbml0aW9uO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ1c2VTcGVlY2hSZWNvZ25pdGlvbiIsIl9yZWFjdCIsInJlcXVpcmUiLCJfdXRpbHMiLCJfYWN0aW9ucyIsIl9yZWR1Y2VycyIsIl9SZWNvZ25pdGlvbk1hbmFnZXIiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX2lzQW5kcm9pZCIsIl9OYXRpdmVTcGVlY2hSZWNvZ25pdGlvbiIsIm9iaiIsIl9fZXNNb2R1bGUiLCJhc3luY0dlbmVyYXRvclN0ZXAiLCJnZW4iLCJyZXNvbHZlIiwicmVqZWN0IiwiX25leHQiLCJfdGhyb3ciLCJrZXkiLCJhcmciLCJpbmZvIiwiZXJyb3IiLCJkb25lIiwiUHJvbWlzZSIsInRoZW4iLCJfYXN5bmNUb0dlbmVyYXRvciIsImZuIiwic2VsZiIsImFyZ3MiLCJhcmd1bWVudHMiLCJhcHBseSIsImVyciIsInVuZGVmaW5lZCIsIl90b0NvbnN1bWFibGVBcnJheSIsImFyciIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJUeXBlRXJyb3IiLCJpdGVyIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJBcnJheSIsImZyb20iLCJpc0FycmF5IiwiX2FycmF5TGlrZVRvQXJyYXkiLCJfdHlwZW9mIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfc2xpY2VkVG9BcnJheSIsImkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfbm9uSXRlcmFibGVSZXN0IiwibyIsIm1pbkxlbiIsIm4iLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsIm5hbWUiLCJ0ZXN0IiwibGVuIiwibGVuZ3RoIiwiYXJyMiIsIl9hcnIiLCJfbiIsIl9kIiwiX2UiLCJfaSIsIl9zIiwibmV4dCIsInB1c2giLCJfYnJvd3NlclN1cHBvcnRzU3BlZWNoUmVjb2duaXRpb24iLCJfYnJvd3NlclN1cHBvcnRzQ29udGludW91c0xpc3RlbmluZyIsInJlY29nbml0aW9uTWFuYWdlciIsIl9yZWYiLCJfcmVmJHRyYW5zY3JpYmluZyIsInRyYW5zY3JpYmluZyIsIl9yZWYkY2xlYXJUcmFuc2NyaXB0TyIsImNsZWFyVHJhbnNjcmlwdE9uTGlzdGVuIiwiX3JlZiRjb21tYW5kcyIsImNvbW1hbmRzIiwiX3VzZVN0YXRlIiwidXNlU3RhdGUiLCJTcGVlY2hSZWNvZ25pdGlvbiIsImdldFJlY29nbml0aW9uTWFuYWdlciIsIl91c2VTdGF0ZTIiLCJfdXNlU3RhdGUzIiwiX3VzZVN0YXRlNCIsImJyb3dzZXJTdXBwb3J0c1NwZWVjaFJlY29nbml0aW9uIiwic2V0QnJvd3NlclN1cHBvcnRzU3BlZWNoUmVjb2duaXRpb24iLCJfdXNlU3RhdGU1IiwiX3VzZVN0YXRlNiIsImJyb3dzZXJTdXBwb3J0c0NvbnRpbnVvdXNMaXN0ZW5pbmciLCJzZXRCcm93c2VyU3VwcG9ydHNDb250aW51b3VzTGlzdGVuaW5nIiwiX3VzZVJlZHVjZXIiLCJ1c2VSZWR1Y2VyIiwidHJhbnNjcmlwdFJlZHVjZXIiLCJpbnRlcmltVHJhbnNjcmlwdCIsImZpbmFsVHJhbnNjcmlwdCIsIl91c2VSZWR1Y2VyMiIsIl91c2VSZWR1Y2VyMiQiLCJkaXNwYXRjaCIsIl91c2VTdGF0ZTciLCJsaXN0ZW5pbmciLCJfdXNlU3RhdGU4Iiwic2V0TGlzdGVuaW5nIiwiX3VzZVN0YXRlOSIsImlzTWljcm9waG9uZUF2YWlsYWJsZSIsIl91c2VTdGF0ZTEwIiwic2V0TWljcm9waG9uZUF2YWlsYWJsZSIsImNvbW1hbmRzUmVmIiwidXNlUmVmIiwiY3VycmVudCIsImRpc3BhdGNoQ2xlYXJUcmFuc2NyaXB0IiwiY2xlYXJUcmFuc2NyaXB0IiwicmVzZXRUcmFuc2NyaXB0IiwidXNlQ2FsbGJhY2siLCJ0ZXN0RnV6enlNYXRjaCIsImNvbW1hbmQiLCJpbnB1dCIsImZ1enp5TWF0Y2hpbmdUaHJlc2hvbGQiLCJjb21tYW5kVG9TdHJpbmciLCJjb21tYW5kV2l0aG91dFNwZWNpYWxzIiwicmVwbGFjZSIsInRyaW0iLCJob3dTaW1pbGFyIiwiY29tcGFyZVR3b1N0cmluZ3NVc2luZ0RpY2VDb2VmZmljaWVudCIsImlzRnV6enlNYXRjaCIsInRlc3RNYXRjaCIsInBhdHRlcm4iLCJjb21tYW5kVG9SZWdFeHAiLCJyZXN1bHQiLCJleGVjIiwicGFyYW1ldGVycyIsIm1hdGNoQ29tbWFuZHMiLCJuZXdJbnRlcmltVHJhbnNjcmlwdCIsIm5ld0ZpbmFsVHJhbnNjcmlwdCIsImZvckVhY2giLCJfcmVmMiIsImNhbGxiYWNrIiwiX3JlZjIkbWF0Y2hJbnRlcmltIiwibWF0Y2hJbnRlcmltIiwiX3JlZjIkaXNGdXp6eU1hdGNoIiwiX3JlZjIkZnV6enlNYXRjaGluZ1RoIiwiX3JlZjIkYmVzdE1hdGNoT25seSIsImJlc3RNYXRjaE9ubHkiLCJzdWJjb21tYW5kcyIsInJlc3VsdHMiLCJtYXAiLCJzdWJjb21tYW5kIiwiZmlsdGVyIiwieCIsInNvcnQiLCJhIiwiYiIsIl9yZXN1bHRzJCIsIl9jb21tYW5kIiwiX2NvbW1hbmQyIiwiX2NvbW1hbmRXaXRob3V0U3BlY2lhbHMiLCJfaG93U2ltaWxhciIsIl9jb21tYW5kMyIsImNvbmNhdCIsImhhbmRsZVRyYW5zY3JpcHRDaGFuZ2UiLCJhcHBlbmRUcmFuc2NyaXB0IiwiaGFuZGxlQ2xlYXJUcmFuc2NyaXB0IiwidXNlRWZmZWN0IiwiaWQiLCJjb3VudGVyIiwiY2FsbGJhY2tzIiwib25MaXN0ZW5pbmdDaGFuZ2UiLCJvbk1pY3JvcGhvbmVBdmFpbGFiaWxpdHlDaGFuZ2UiLCJvblRyYW5zY3JpcHRDaGFuZ2UiLCJvbkNsZWFyVHJhbnNjcmlwdCIsIm9uQnJvd3NlclN1cHBvcnRzU3BlZWNoUmVjb2duaXRpb25DaGFuZ2UiLCJvbkJyb3dzZXJTdXBwb3J0c0NvbnRpbnVvdXNMaXN0ZW5pbmdDaGFuZ2UiLCJzdWJzY3JpYmUiLCJ1bnN1YnNjcmliZSIsInRyYW5zY3JpcHQiLCJjb25jYXRUcmFuc2NyaXB0cyIsImFwcGx5UG9seWZpbGwiLCJQb2x5ZmlsbFNwZWVjaFJlY29nbml0aW9uIiwic2V0U3BlZWNoUmVjb2duaXRpb24iLCJicm93c2VyU3VwcG9ydHNQb2x5ZmlsbCIsImJyb3dzZXJTdXBwb3J0c1BvbHlmaWxscyIsInJlbW92ZVBvbHlmaWxsIiwiZ2V0UmVjb2duaXRpb24iLCJzdGFydExpc3RlbmluZyIsIl9zdGFydExpc3RlbmluZyIsInJlZ2VuZXJhdG9yUnVudGltZSIsIm1hcmsiLCJfY2FsbGVlIiwiX3JlZjMiLCJjb250aW51b3VzIiwibGFuZ3VhZ2UiLCJfYXJncyIsIndyYXAiLCJfY2FsbGVlJCIsIl9jb250ZXh0IiwicHJldiIsInN0b3AiLCJzdG9wTGlzdGVuaW5nIiwiX3N0b3BMaXN0ZW5pbmciLCJfY2FsbGVlMiIsIl9jYWxsZWUyJCIsIl9jb250ZXh0MiIsImFib3J0TGlzdGVuaW5nIiwiX2Fib3J0TGlzdGVuaW5nIiwiX2NhbGxlZTMiLCJfY2FsbGVlMyQiLCJfY29udGV4dDMiLCJfZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-speech-recognition/lib/SpeechRecognition.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-speech-recognition/lib/actions.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-speech-recognition/lib/actions.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.appendTranscript = exports.clearTranscript = void 0;\nvar _constants = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./node_modules/react-speech-recognition/lib/constants.js\");\nvar clearTranscript = function clearTranscript() {\n    return {\n        type: _constants.CLEAR_TRANSCRIPT\n    };\n};\nexports.clearTranscript = clearTranscript;\nvar appendTranscript = function appendTranscript(interimTranscript, finalTranscript) {\n    return {\n        type: _constants.APPEND_TRANSCRIPT,\n        payload: {\n            interimTranscript: interimTranscript,\n            finalTranscript: finalTranscript\n        }\n    };\n};\nexports.appendTranscript = appendTranscript;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zcGVlY2gtcmVjb2duaXRpb24vbGliL2FjdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELHdCQUF3QixHQUFHQSx1QkFBdUIsR0FBRyxLQUFLO0FBRTFELElBQUlJLGFBQWFDLG1CQUFPQSxDQUFDLGlHQUFhO0FBRXRDLElBQUlGLGtCQUFrQixTQUFTQTtJQUM3QixPQUFPO1FBQ0xHLE1BQU1GLFdBQVdHLGdCQUFnQjtJQUNuQztBQUNGO0FBRUFQLHVCQUF1QixHQUFHRztBQUUxQixJQUFJRCxtQkFBbUIsU0FBU0EsaUJBQWlCTSxpQkFBaUIsRUFBRUMsZUFBZTtJQUNqRixPQUFPO1FBQ0xILE1BQU1GLFdBQVdNLGlCQUFpQjtRQUNsQ0MsU0FBUztZQUNQSCxtQkFBbUJBO1lBQ25CQyxpQkFBaUJBO1FBQ25CO0lBQ0Y7QUFDRjtBQUVBVCx3QkFBd0IsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNwZWVjaC1yZWNvZ25pdGlvbi9saWIvYWN0aW9ucy5qcz9hYzcyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hcHBlbmRUcmFuc2NyaXB0ID0gZXhwb3J0cy5jbGVhclRyYW5zY3JpcHQgPSB2b2lkIDA7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuXG52YXIgY2xlYXJUcmFuc2NyaXB0ID0gZnVuY3Rpb24gY2xlYXJUcmFuc2NyaXB0KCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IF9jb25zdGFudHMuQ0xFQVJfVFJBTlNDUklQVFxuICB9O1xufTtcblxuZXhwb3J0cy5jbGVhclRyYW5zY3JpcHQgPSBjbGVhclRyYW5zY3JpcHQ7XG5cbnZhciBhcHBlbmRUcmFuc2NyaXB0ID0gZnVuY3Rpb24gYXBwZW5kVHJhbnNjcmlwdChpbnRlcmltVHJhbnNjcmlwdCwgZmluYWxUcmFuc2NyaXB0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogX2NvbnN0YW50cy5BUFBFTkRfVFJBTlNDUklQVCxcbiAgICBwYXlsb2FkOiB7XG4gICAgICBpbnRlcmltVHJhbnNjcmlwdDogaW50ZXJpbVRyYW5zY3JpcHQsXG4gICAgICBmaW5hbFRyYW5zY3JpcHQ6IGZpbmFsVHJhbnNjcmlwdFxuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydHMuYXBwZW5kVHJhbnNjcmlwdCA9IGFwcGVuZFRyYW5zY3JpcHQ7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYXBwZW5kVHJhbnNjcmlwdCIsImNsZWFyVHJhbnNjcmlwdCIsIl9jb25zdGFudHMiLCJyZXF1aXJlIiwidHlwZSIsIkNMRUFSX1RSQU5TQ1JJUFQiLCJpbnRlcmltVHJhbnNjcmlwdCIsImZpbmFsVHJhbnNjcmlwdCIsIkFQUEVORF9UUkFOU0NSSVBUIiwicGF5bG9hZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-speech-recognition/lib/actions.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-speech-recognition/lib/constants.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-speech-recognition/lib/constants.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.APPEND_TRANSCRIPT = exports.CLEAR_TRANSCRIPT = void 0;\nvar CLEAR_TRANSCRIPT = \"CLEAR_TRANSCRIPT\";\nexports.CLEAR_TRANSCRIPT = CLEAR_TRANSCRIPT;\nvar APPEND_TRANSCRIPT = \"APPEND_TRANSCRIPT\";\nexports.APPEND_TRANSCRIPT = APPEND_TRANSCRIPT;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zcGVlY2gtcmVjb2duaXRpb24vbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQseUJBQXlCLEdBQUdBLHdCQUF3QixHQUFHLEtBQUs7QUFDNUQsSUFBSUcsbUJBQW1CO0FBQ3ZCSCx3QkFBd0IsR0FBR0c7QUFDM0IsSUFBSUQsb0JBQW9CO0FBQ3hCRix5QkFBeUIsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNwZWVjaC1yZWNvZ25pdGlvbi9saWIvY29uc3RhbnRzLmpzPzlmODEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkFQUEVORF9UUkFOU0NSSVBUID0gZXhwb3J0cy5DTEVBUl9UUkFOU0NSSVBUID0gdm9pZCAwO1xudmFyIENMRUFSX1RSQU5TQ1JJUFQgPSAnQ0xFQVJfVFJBTlNDUklQVCc7XG5leHBvcnRzLkNMRUFSX1RSQU5TQ1JJUFQgPSBDTEVBUl9UUkFOU0NSSVBUO1xudmFyIEFQUEVORF9UUkFOU0NSSVBUID0gJ0FQUEVORF9UUkFOU0NSSVBUJztcbmV4cG9ydHMuQVBQRU5EX1RSQU5TQ1JJUFQgPSBBUFBFTkRfVFJBTlNDUklQVDsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBUFBFTkRfVFJBTlNDUklQVCIsIkNMRUFSX1RSQU5TQ1JJUFQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-speech-recognition/lib/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-speech-recognition/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/react-speech-recognition/lib/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function _typeof(obj) {\n            return typeof obj;\n        };\n    } else {\n        _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n    }\n    return _typeof(obj);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useSpeechRecognition\", ({\n    enumerable: true,\n    get: function get() {\n        return _SpeechRecognition.useSpeechRecognition;\n    }\n}));\nexports[\"default\"] = void 0;\nvar _SpeechRecognition = _interopRequireWildcard(__webpack_require__(/*! ./SpeechRecognition */ \"(app-pages-browser)/./node_modules/react-speech-recognition/lib/SpeechRecognition.js\"));\nfunction _getRequireWildcardCache() {\n    if (typeof WeakMap !== \"function\") return null;\n    var cache = new WeakMap();\n    _getRequireWildcardCache = function _getRequireWildcardCache() {\n        return cache;\n    };\n    return cache;\n}\nfunction _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n        return {\n            \"default\": obj\n        };\n    }\n    var cache = _getRequireWildcardCache();\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj[\"default\"] = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nvar _default = _SpeechRecognition[\"default\"];\nexports[\"default\"] = _default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zcGVlY2gtcmVjb2duaXRpb24vbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsR0FBRztJQUFJO0lBQTJCLElBQUksT0FBT0MsV0FBVyxjQUFjLE9BQU9BLE9BQU9DLFFBQVEsS0FBSyxVQUFVO1FBQUVILFVBQVUsU0FBU0EsUUFBUUMsR0FBRztZQUFJLE9BQU8sT0FBT0E7UUFBSztJQUFHLE9BQU87UUFBRUQsVUFBVSxTQUFTQSxRQUFRQyxHQUFHO1lBQUksT0FBT0EsT0FBTyxPQUFPQyxXQUFXLGNBQWNELElBQUlHLFdBQVcsS0FBS0YsVUFBVUQsUUFBUUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7UUFBSztJQUFHO0lBQUUsT0FBT0QsUUFBUUM7QUFBTTtBQUV6WEssOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZILHdEQUF1RDtJQUNyREksWUFBWTtJQUNaQyxLQUFLLFNBQVNBO1FBQ1osT0FBT0MsbUJBQW1CQyxvQkFBb0I7SUFDaEQ7QUFDRixDQUFDLEVBQUM7QUFDRkwsa0JBQWtCLEdBQUcsS0FBSztBQUUxQixJQUFJSSxxQkFBcUJFLHdCQUF3QkMsbUJBQU9BLENBQUMsaUhBQXFCO0FBRTlFLFNBQVNDO0lBQTZCLElBQUksT0FBT0MsWUFBWSxZQUFZLE9BQU87SUFBTSxJQUFJQyxRQUFRLElBQUlEO0lBQVdELDJCQUEyQixTQUFTQTtRQUE2QixPQUFPRTtJQUFPO0lBQUcsT0FBT0E7QUFBTztBQUVqTixTQUFTSix3QkFBd0JiLEdBQUc7SUFBSSxJQUFJQSxPQUFPQSxJQUFJa0IsVUFBVSxFQUFFO1FBQUUsT0FBT2xCO0lBQUs7SUFBRSxJQUFJQSxRQUFRLFFBQVFELFFBQVFDLFNBQVMsWUFBWSxPQUFPQSxRQUFRLFlBQVk7UUFBRSxPQUFPO1lBQUUsV0FBV0E7UUFBSTtJQUFHO0lBQUUsSUFBSWlCLFFBQVFGO0lBQTRCLElBQUlFLFNBQVNBLE1BQU1FLEdBQUcsQ0FBQ25CLE1BQU07UUFBRSxPQUFPaUIsTUFBTVAsR0FBRyxDQUFDVjtJQUFNO0lBQUUsSUFBSW9CLFNBQVMsQ0FBQztJQUFHLElBQUlDLHdCQUF3QmhCLE9BQU9DLGNBQWMsSUFBSUQsT0FBT2lCLHdCQUF3QjtJQUFFLElBQUssSUFBSUMsT0FBT3ZCLElBQUs7UUFBRSxJQUFJSyxPQUFPRCxTQUFTLENBQUNvQixjQUFjLENBQUNDLElBQUksQ0FBQ3pCLEtBQUt1QixNQUFNO1lBQUUsSUFBSUcsT0FBT0wsd0JBQXdCaEIsT0FBT2lCLHdCQUF3QixDQUFDdEIsS0FBS3VCLE9BQU87WUFBTSxJQUFJRyxRQUFTQSxDQUFBQSxLQUFLaEIsR0FBRyxJQUFJZ0IsS0FBS0MsR0FBRyxHQUFHO2dCQUFFdEIsT0FBT0MsY0FBYyxDQUFDYyxRQUFRRyxLQUFLRztZQUFPLE9BQU87Z0JBQUVOLE1BQU0sQ0FBQ0csSUFBSSxHQUFHdkIsR0FBRyxDQUFDdUIsSUFBSTtZQUFFO1FBQUU7SUFBRTtJQUFFSCxNQUFNLENBQUMsVUFBVSxHQUFHcEI7SUFBSyxJQUFJaUIsT0FBTztRQUFFQSxNQUFNVSxHQUFHLENBQUMzQixLQUFLb0I7SUFBUztJQUFFLE9BQU9BO0FBQVE7QUFFN3VCLElBQUlRLFdBQVdqQixrQkFBa0IsQ0FBQyxVQUFVO0FBQzVDSixrQkFBa0IsR0FBR3FCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zcGVlY2gtcmVjb2duaXRpb24vbGliL2luZGV4LmpzP2Y1ZTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVzZVNwZWVjaFJlY29nbml0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9TcGVlY2hSZWNvZ25pdGlvbi51c2VTcGVlY2hSZWNvZ25pdGlvbjtcbiAgfVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9TcGVlY2hSZWNvZ25pdGlvbiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL1NwZWVjaFJlY29nbml0aW9uXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxudmFyIF9kZWZhdWx0ID0gX1NwZWVjaFJlY29nbml0aW9uW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX1NwZWVjaFJlY29nbml0aW9uIiwidXNlU3BlZWNoUmVjb2duaXRpb24iLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJXZWFrTWFwIiwiY2FjaGUiLCJfX2VzTW9kdWxlIiwiaGFzIiwibmV3T2JqIiwiaGFzUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZGVzYyIsInNldCIsIl9kZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-speech-recognition/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-speech-recognition/lib/isAndroid.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-speech-recognition/lib/isAndroid.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _default = function _default() {\n    return /(android)/i.test(typeof navigator !== \"undefined\" ? navigator.userAgent : \"\");\n};\nexports[\"default\"] = _default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zcGVlY2gtcmVjb2duaXRpb24vbGliL2lzQW5kcm9pZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsa0JBQWtCLEdBQUcsS0FBSztBQUUxQixJQUFJRSxXQUFXLFNBQVNBO0lBQ3RCLE9BQU8sYUFBYUMsSUFBSSxDQUFDLE9BQU9DLGNBQWMsY0FBY0EsVUFBVUMsU0FBUyxHQUFHO0FBQ3BGO0FBRUFMLGtCQUFrQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3BlZWNoLXJlY29nbml0aW9uL2xpYi9pc0FuZHJvaWQuanM/MmUyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2RlZmF1bHQgPSBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgcmV0dXJuIC8oYW5kcm9pZCkvaS50ZXN0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID8gbmF2aWdhdG9yLnVzZXJBZ2VudCA6ICcnKTtcbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX2RlZmF1bHQiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-speech-recognition/lib/isAndroid.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-speech-recognition/lib/reducers.js":
/*!***************************************************************!*\
  !*** ./node_modules/react-speech-recognition/lib/reducers.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.transcriptReducer = void 0;\nvar _constants = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./node_modules/react-speech-recognition/lib/constants.js\");\nvar _utils = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/react-speech-recognition/lib/utils.js\");\nvar transcriptReducer = function transcriptReducer(state, action) {\n    switch(action.type){\n        case _constants.CLEAR_TRANSCRIPT:\n            return {\n                interimTranscript: \"\",\n                finalTranscript: \"\"\n            };\n        case _constants.APPEND_TRANSCRIPT:\n            return {\n                interimTranscript: action.payload.interimTranscript,\n                finalTranscript: (0, _utils.concatTranscripts)(state.finalTranscript, action.payload.finalTranscript)\n            };\n        default:\n            throw new Error();\n    }\n};\nexports.transcriptReducer = transcriptReducer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zcGVlY2gtcmVjb2duaXRpb24vbGliL3JlZHVjZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCx5QkFBeUIsR0FBRyxLQUFLO0FBRWpDLElBQUlHLGFBQWFDLG1CQUFPQSxDQUFDLGlHQUFhO0FBRXRDLElBQUlDLFNBQVNELG1CQUFPQSxDQUFDLHlGQUFTO0FBRTlCLElBQUlGLG9CQUFvQixTQUFTQSxrQkFBa0JJLEtBQUssRUFBRUMsTUFBTTtJQUM5RCxPQUFRQSxPQUFPQyxJQUFJO1FBQ2pCLEtBQUtMLFdBQVdNLGdCQUFnQjtZQUM5QixPQUFPO2dCQUNMQyxtQkFBbUI7Z0JBQ25CQyxpQkFBaUI7WUFDbkI7UUFFRixLQUFLUixXQUFXUyxpQkFBaUI7WUFDL0IsT0FBTztnQkFDTEYsbUJBQW1CSCxPQUFPTSxPQUFPLENBQUNILGlCQUFpQjtnQkFDbkRDLGlCQUFpQixDQUFDLEdBQUdOLE9BQU9TLGlCQUFpQixFQUFFUixNQUFNSyxlQUFlLEVBQUVKLE9BQU9NLE9BQU8sQ0FBQ0YsZUFBZTtZQUN0RztRQUVGO1lBQ0UsTUFBTSxJQUFJSTtJQUNkO0FBQ0Y7QUFFQWYseUJBQXlCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zcGVlY2gtcmVjb2duaXRpb24vbGliL3JlZHVjZXJzLmpzPzJlNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnRyYW5zY3JpcHRSZWR1Y2VyID0gdm9pZCAwO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG52YXIgdHJhbnNjcmlwdFJlZHVjZXIgPSBmdW5jdGlvbiB0cmFuc2NyaXB0UmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIF9jb25zdGFudHMuQ0xFQVJfVFJBTlNDUklQVDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGludGVyaW1UcmFuc2NyaXB0OiAnJyxcbiAgICAgICAgZmluYWxUcmFuc2NyaXB0OiAnJ1xuICAgICAgfTtcblxuICAgIGNhc2UgX2NvbnN0YW50cy5BUFBFTkRfVFJBTlNDUklQVDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGludGVyaW1UcmFuc2NyaXB0OiBhY3Rpb24ucGF5bG9hZC5pbnRlcmltVHJhbnNjcmlwdCxcbiAgICAgICAgZmluYWxUcmFuc2NyaXB0OiAoMCwgX3V0aWxzLmNvbmNhdFRyYW5zY3JpcHRzKShzdGF0ZS5maW5hbFRyYW5zY3JpcHQsIGFjdGlvbi5wYXlsb2FkLmZpbmFsVHJhbnNjcmlwdClcbiAgICAgIH07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gIH1cbn07XG5cbmV4cG9ydHMudHJhbnNjcmlwdFJlZHVjZXIgPSB0cmFuc2NyaXB0UmVkdWNlcjsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ0cmFuc2NyaXB0UmVkdWNlciIsIl9jb25zdGFudHMiLCJyZXF1aXJlIiwiX3V0aWxzIiwic3RhdGUiLCJhY3Rpb24iLCJ0eXBlIiwiQ0xFQVJfVFJBTlNDUklQVCIsImludGVyaW1UcmFuc2NyaXB0IiwiZmluYWxUcmFuc2NyaXB0IiwiQVBQRU5EX1RSQU5TQ1JJUFQiLCJwYXlsb2FkIiwiY29uY2F0VHJhbnNjcmlwdHMiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-speech-recognition/lib/reducers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-speech-recognition/lib/utils.js":
/*!************************************************************!*\
  !*** ./node_modules/react-speech-recognition/lib/utils.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.browserSupportsPolyfills = exports.compareTwoStringsUsingDiceCoefficient = exports.commandToRegExp = exports.concatTranscripts = exports.debounce = void 0;\nvar debounce = function debounce(func, wait, immediate) {\n    var timeout;\n    return function() {\n        var context = this;\n        var args = arguments;\n        var later = function later() {\n            timeout = null;\n            if (!immediate) func.apply(context, args);\n        };\n        var callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(context, args);\n    };\n};\nexports.debounce = debounce;\nvar concatTranscripts = function concatTranscripts() {\n    for(var _len = arguments.length, transcriptParts = new Array(_len), _key = 0; _key < _len; _key++){\n        transcriptParts[_key] = arguments[_key];\n    }\n    return transcriptParts.map(function(t) {\n        return t.trim();\n    }).join(\" \").trim();\n}; // The command matching code is a modified version of Backbone.Router by Jeremy Ashkenas, under the MIT license.\nexports.concatTranscripts = concatTranscripts;\nvar optionalParam = /\\s*\\((.*?)\\)\\s*/g;\nvar optionalRegex = /(\\(\\?:[^)]+\\))\\?/g;\nvar namedParam = /(\\(\\?)?:\\w+/g;\nvar splatParam = /\\*/g;\nvar escapeRegExp = /[-{}[\\]+?.,\\\\^$|#]/g;\nvar commandToRegExp = function commandToRegExp(command) {\n    if (command instanceof RegExp) {\n        return new RegExp(command.source, \"i\");\n    }\n    command = command.replace(escapeRegExp, \"\\\\$&\").replace(optionalParam, \"(?:$1)?\").replace(namedParam, function(match, optional) {\n        return optional ? match : \"([^\\\\s]+)\";\n    }).replace(splatParam, \"(.*?)\").replace(optionalRegex, \"\\\\s*$1?\\\\s*\");\n    return new RegExp(\"^\" + command + \"$\", \"i\");\n}; // this is from https://github.com/aceakash/string-similarity\nexports.commandToRegExp = commandToRegExp;\nvar compareTwoStringsUsingDiceCoefficient = function compareTwoStringsUsingDiceCoefficient(first, second) {\n    first = first.replace(/\\s+/g, \"\").toLowerCase();\n    second = second.replace(/\\s+/g, \"\").toLowerCase();\n    if (!first.length && !second.length) return 1; // if both are empty strings\n    if (!first.length || !second.length) return 0; // if only one is empty string\n    if (first === second) return 1; // identical\n    if (first.length === 1 && second.length === 1) return 0; // both are 1-letter strings\n    if (first.length < 2 || second.length < 2) return 0; // if either is a 1-letter string\n    var firstBigrams = new Map();\n    for(var i = 0; i < first.length - 1; i++){\n        var bigram = first.substring(i, i + 2);\n        var count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) + 1 : 1;\n        firstBigrams.set(bigram, count);\n    }\n    var intersectionSize = 0;\n    for(var _i = 0; _i < second.length - 1; _i++){\n        var _bigram = second.substring(_i, _i + 2);\n        var _count = firstBigrams.has(_bigram) ? firstBigrams.get(_bigram) : 0;\n        if (_count > 0) {\n            firstBigrams.set(_bigram, _count - 1);\n            intersectionSize++;\n        }\n    }\n    return 2.0 * intersectionSize / (first.length + second.length - 2);\n};\nexports.compareTwoStringsUsingDiceCoefficient = compareTwoStringsUsingDiceCoefficient;\nvar browserSupportsPolyfills = function browserSupportsPolyfills() {\n    return  true && window.navigator !== undefined && window.navigator.mediaDevices !== undefined && window.navigator.mediaDevices.getUserMedia !== undefined && (window.AudioContext !== undefined || window.webkitAudioContext !== undefined);\n};\nexports.browserSupportsPolyfills = browserSupportsPolyfills;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zcGVlY2gtcmVjb2duaXRpb24vbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxnQ0FBZ0MsR0FBR0EsNkNBQTZDLEdBQUdBLHVCQUF1QixHQUFHQSx5QkFBeUIsR0FBR0EsZ0JBQWdCLEdBQUcsS0FBSztBQUVqSyxJQUFJTSxXQUFXLFNBQVNBLFNBQVNDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxTQUFTO0lBQ3BELElBQUlDO0lBQ0osT0FBTztRQUNMLElBQUlDLFVBQVUsSUFBSTtRQUNsQixJQUFJQyxPQUFPQztRQUVYLElBQUlDLFFBQVEsU0FBU0E7WUFDbkJKLFVBQVU7WUFDVixJQUFJLENBQUNELFdBQVdGLEtBQUtRLEtBQUssQ0FBQ0osU0FBU0M7UUFDdEM7UUFFQSxJQUFJSSxVQUFVUCxhQUFhLENBQUNDO1FBQzVCTyxhQUFhUDtRQUNiQSxVQUFVUSxXQUFXSixPQUFPTjtRQUM1QixJQUFJUSxTQUFTVCxLQUFLUSxLQUFLLENBQUNKLFNBQVNDO0lBQ25DO0FBQ0Y7QUFFQVosZ0JBQWdCLEdBQUdNO0FBRW5CLElBQUlELG9CQUFvQixTQUFTQTtJQUMvQixJQUFLLElBQUljLE9BQU9OLFVBQVVPLE1BQU0sRUFBRUMsa0JBQWtCLElBQUlDLE1BQU1ILE9BQU9JLE9BQU8sR0FBR0EsT0FBT0osTUFBTUksT0FBUTtRQUNsR0YsZUFBZSxDQUFDRSxLQUFLLEdBQUdWLFNBQVMsQ0FBQ1UsS0FBSztJQUN6QztJQUVBLE9BQU9GLGdCQUFnQkcsR0FBRyxDQUFDLFNBQVVDLENBQUM7UUFDcEMsT0FBT0EsRUFBRUMsSUFBSTtJQUNmLEdBQUdDLElBQUksQ0FBQyxLQUFLRCxJQUFJO0FBQ25CLEdBQUcsZ0hBQWdIO0FBR25IMUIseUJBQXlCLEdBQUdLO0FBQzVCLElBQUl1QixnQkFBZ0I7QUFDcEIsSUFBSUMsZ0JBQWdCO0FBQ3BCLElBQUlDLGFBQWE7QUFDakIsSUFBSUMsYUFBYTtBQUNqQixJQUFJQyxlQUFlO0FBRW5CLElBQUk1QixrQkFBa0IsU0FBU0EsZ0JBQWdCNkIsT0FBTztJQUNwRCxJQUFJQSxtQkFBbUJDLFFBQVE7UUFDN0IsT0FBTyxJQUFJQSxPQUFPRCxRQUFRRSxNQUFNLEVBQUU7SUFDcEM7SUFFQUYsVUFBVUEsUUFBUUcsT0FBTyxDQUFDSixjQUFjLFFBQVFJLE9BQU8sQ0FBQ1IsZUFBZSxXQUFXUSxPQUFPLENBQUNOLFlBQVksU0FBVU8sS0FBSyxFQUFFQyxRQUFRO1FBQzdILE9BQU9BLFdBQVdELFFBQVE7SUFDNUIsR0FBR0QsT0FBTyxDQUFDTCxZQUFZLFNBQVNLLE9BQU8sQ0FBQ1AsZUFBZTtJQUN2RCxPQUFPLElBQUlLLE9BQU8sTUFBTUQsVUFBVSxLQUFLO0FBQ3pDLEdBQUcsNkRBQTZEO0FBR2hFakMsdUJBQXVCLEdBQUdJO0FBRTFCLElBQUlELHdDQUF3QyxTQUFTQSxzQ0FBc0NvQyxLQUFLLEVBQUVDLE1BQU07SUFDdEdELFFBQVFBLE1BQU1ILE9BQU8sQ0FBQyxRQUFRLElBQUlLLFdBQVc7SUFDN0NELFNBQVNBLE9BQU9KLE9BQU8sQ0FBQyxRQUFRLElBQUlLLFdBQVc7SUFDL0MsSUFBSSxDQUFDRixNQUFNbkIsTUFBTSxJQUFJLENBQUNvQixPQUFPcEIsTUFBTSxFQUFFLE9BQU8sR0FBRyw0QkFBNEI7SUFFM0UsSUFBSSxDQUFDbUIsTUFBTW5CLE1BQU0sSUFBSSxDQUFDb0IsT0FBT3BCLE1BQU0sRUFBRSxPQUFPLEdBQUcsOEJBQThCO0lBRTdFLElBQUltQixVQUFVQyxRQUFRLE9BQU8sR0FBRyxZQUFZO0lBRTVDLElBQUlELE1BQU1uQixNQUFNLEtBQUssS0FBS29CLE9BQU9wQixNQUFNLEtBQUssR0FBRyxPQUFPLEdBQUcsNEJBQTRCO0lBRXJGLElBQUltQixNQUFNbkIsTUFBTSxHQUFHLEtBQUtvQixPQUFPcEIsTUFBTSxHQUFHLEdBQUcsT0FBTyxHQUFHLGlDQUFpQztJQUV0RixJQUFJc0IsZUFBZSxJQUFJQztJQUV2QixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUwsTUFBTW5CLE1BQU0sR0FBRyxHQUFHd0IsSUFBSztRQUN6QyxJQUFJQyxTQUFTTixNQUFNTyxTQUFTLENBQUNGLEdBQUdBLElBQUk7UUFDcEMsSUFBSUcsUUFBUUwsYUFBYU0sR0FBRyxDQUFDSCxVQUFVSCxhQUFhTyxHQUFHLENBQUNKLFVBQVUsSUFBSTtRQUN0RUgsYUFBYVEsR0FBRyxDQUFDTCxRQUFRRTtJQUMzQjtJQUVBLElBQUlJLG1CQUFtQjtJQUV2QixJQUFLLElBQUlDLEtBQUssR0FBR0EsS0FBS1osT0FBT3BCLE1BQU0sR0FBRyxHQUFHZ0MsS0FBTTtRQUM3QyxJQUFJQyxVQUFVYixPQUFPTSxTQUFTLENBQUNNLElBQUlBLEtBQUs7UUFFeEMsSUFBSUUsU0FBU1osYUFBYU0sR0FBRyxDQUFDSyxXQUFXWCxhQUFhTyxHQUFHLENBQUNJLFdBQVc7UUFFckUsSUFBSUMsU0FBUyxHQUFHO1lBQ2RaLGFBQWFRLEdBQUcsQ0FBQ0csU0FBU0MsU0FBUztZQUNuQ0g7UUFDRjtJQUNGO0lBRUEsT0FBTyxNQUFNQSxtQkFBb0JaLENBQUFBLE1BQU1uQixNQUFNLEdBQUdvQixPQUFPcEIsTUFBTSxHQUFHO0FBQ2xFO0FBRUFwQiw2Q0FBNkMsR0FBR0c7QUFFaEQsSUFBSUQsMkJBQTJCLFNBQVNBO0lBQ3RDLE9BQU8sS0FBa0IsSUFBZXFELE9BQU9DLFNBQVMsS0FBS0MsYUFBYUYsT0FBT0MsU0FBUyxDQUFDRSxZQUFZLEtBQUtELGFBQWFGLE9BQU9DLFNBQVMsQ0FBQ0UsWUFBWSxDQUFDQyxZQUFZLEtBQUtGLGFBQWNGLENBQUFBLE9BQU9LLFlBQVksS0FBS0gsYUFBYUYsT0FBT00sa0JBQWtCLEtBQUtKLFNBQVE7QUFDblE7QUFFQXpELGdDQUFnQyxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3BlZWNoLXJlY29nbml0aW9uL2xpYi91dGlscy5qcz8yZTZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5icm93c2VyU3VwcG9ydHNQb2x5ZmlsbHMgPSBleHBvcnRzLmNvbXBhcmVUd29TdHJpbmdzVXNpbmdEaWNlQ29lZmZpY2llbnQgPSBleHBvcnRzLmNvbW1hbmRUb1JlZ0V4cCA9IGV4cG9ydHMuY29uY2F0VHJhbnNjcmlwdHMgPSBleHBvcnRzLmRlYm91bmNlID0gdm9pZCAwO1xuXG52YXIgZGVib3VuY2UgPSBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgdmFyIHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24gbGF0ZXIoKSB7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGlmICghaW1tZWRpYXRlKSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH07XG5cbiAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgIGlmIChjYWxsTm93KSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICB9O1xufTtcblxuZXhwb3J0cy5kZWJvdW5jZSA9IGRlYm91bmNlO1xuXG52YXIgY29uY2F0VHJhbnNjcmlwdHMgPSBmdW5jdGlvbiBjb25jYXRUcmFuc2NyaXB0cygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHRyYW5zY3JpcHRQYXJ0cyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB0cmFuc2NyaXB0UGFydHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gdHJhbnNjcmlwdFBhcnRzLm1hcChmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0LnRyaW0oKTtcbiAgfSkuam9pbignICcpLnRyaW0oKTtcbn07IC8vIFRoZSBjb21tYW5kIG1hdGNoaW5nIGNvZGUgaXMgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIEJhY2tib25lLlJvdXRlciBieSBKZXJlbXkgQXNoa2VuYXMsIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuXG5leHBvcnRzLmNvbmNhdFRyYW5zY3JpcHRzID0gY29uY2F0VHJhbnNjcmlwdHM7XG52YXIgb3B0aW9uYWxQYXJhbSA9IC9cXHMqXFwoKC4qPylcXClcXHMqL2c7XG52YXIgb3B0aW9uYWxSZWdleCA9IC8oXFwoXFw/OlteKV0rXFwpKVxcPy9nO1xudmFyIG5hbWVkUGFyYW0gPSAvKFxcKFxcPyk/OlxcdysvZztcbnZhciBzcGxhdFBhcmFtID0gL1xcKi9nO1xudmFyIGVzY2FwZVJlZ0V4cCA9IC9bLXt9W1xcXSs/LixcXFxcXiR8I10vZztcblxudmFyIGNvbW1hbmRUb1JlZ0V4cCA9IGZ1bmN0aW9uIGNvbW1hbmRUb1JlZ0V4cChjb21tYW5kKSB7XG4gIGlmIChjb21tYW5kIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoY29tbWFuZC5zb3VyY2UsICdpJyk7XG4gIH1cblxuICBjb21tYW5kID0gY29tbWFuZC5yZXBsYWNlKGVzY2FwZVJlZ0V4cCwgJ1xcXFwkJicpLnJlcGxhY2Uob3B0aW9uYWxQYXJhbSwgJyg/OiQxKT8nKS5yZXBsYWNlKG5hbWVkUGFyYW0sIGZ1bmN0aW9uIChtYXRjaCwgb3B0aW9uYWwpIHtcbiAgICByZXR1cm4gb3B0aW9uYWwgPyBtYXRjaCA6ICcoW15cXFxcc10rKSc7XG4gIH0pLnJlcGxhY2Uoc3BsYXRQYXJhbSwgJyguKj8pJykucmVwbGFjZShvcHRpb25hbFJlZ2V4LCAnXFxcXHMqJDE/XFxcXHMqJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIGNvbW1hbmQgKyAnJCcsICdpJyk7XG59OyAvLyB0aGlzIGlzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FjZWFrYXNoL3N0cmluZy1zaW1pbGFyaXR5XG5cblxuZXhwb3J0cy5jb21tYW5kVG9SZWdFeHAgPSBjb21tYW5kVG9SZWdFeHA7XG5cbnZhciBjb21wYXJlVHdvU3RyaW5nc1VzaW5nRGljZUNvZWZmaWNpZW50ID0gZnVuY3Rpb24gY29tcGFyZVR3b1N0cmluZ3NVc2luZ0RpY2VDb2VmZmljaWVudChmaXJzdCwgc2Vjb25kKSB7XG4gIGZpcnN0ID0gZmlyc3QucmVwbGFjZSgvXFxzKy9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgc2Vjb25kID0gc2Vjb25kLnJlcGxhY2UoL1xccysvZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghZmlyc3QubGVuZ3RoICYmICFzZWNvbmQubGVuZ3RoKSByZXR1cm4gMTsgLy8gaWYgYm90aCBhcmUgZW1wdHkgc3RyaW5nc1xuXG4gIGlmICghZmlyc3QubGVuZ3RoIHx8ICFzZWNvbmQubGVuZ3RoKSByZXR1cm4gMDsgLy8gaWYgb25seSBvbmUgaXMgZW1wdHkgc3RyaW5nXG5cbiAgaWYgKGZpcnN0ID09PSBzZWNvbmQpIHJldHVybiAxOyAvLyBpZGVudGljYWxcblxuICBpZiAoZmlyc3QubGVuZ3RoID09PSAxICYmIHNlY29uZC5sZW5ndGggPT09IDEpIHJldHVybiAwOyAvLyBib3RoIGFyZSAxLWxldHRlciBzdHJpbmdzXG5cbiAgaWYgKGZpcnN0Lmxlbmd0aCA8IDIgfHwgc2Vjb25kLmxlbmd0aCA8IDIpIHJldHVybiAwOyAvLyBpZiBlaXRoZXIgaXMgYSAxLWxldHRlciBzdHJpbmdcblxuICB2YXIgZmlyc3RCaWdyYW1zID0gbmV3IE1hcCgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmlyc3QubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgdmFyIGJpZ3JhbSA9IGZpcnN0LnN1YnN0cmluZyhpLCBpICsgMik7XG4gICAgdmFyIGNvdW50ID0gZmlyc3RCaWdyYW1zLmhhcyhiaWdyYW0pID8gZmlyc3RCaWdyYW1zLmdldChiaWdyYW0pICsgMSA6IDE7XG4gICAgZmlyc3RCaWdyYW1zLnNldChiaWdyYW0sIGNvdW50KTtcbiAgfVxuXG4gIHZhciBpbnRlcnNlY3Rpb25TaXplID0gMDtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgc2Vjb25kLmxlbmd0aCAtIDE7IF9pKyspIHtcbiAgICB2YXIgX2JpZ3JhbSA9IHNlY29uZC5zdWJzdHJpbmcoX2ksIF9pICsgMik7XG5cbiAgICB2YXIgX2NvdW50ID0gZmlyc3RCaWdyYW1zLmhhcyhfYmlncmFtKSA/IGZpcnN0QmlncmFtcy5nZXQoX2JpZ3JhbSkgOiAwO1xuXG4gICAgaWYgKF9jb3VudCA+IDApIHtcbiAgICAgIGZpcnN0QmlncmFtcy5zZXQoX2JpZ3JhbSwgX2NvdW50IC0gMSk7XG4gICAgICBpbnRlcnNlY3Rpb25TaXplKys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDIuMCAqIGludGVyc2VjdGlvblNpemUgLyAoZmlyc3QubGVuZ3RoICsgc2Vjb25kLmxlbmd0aCAtIDIpO1xufTtcblxuZXhwb3J0cy5jb21wYXJlVHdvU3RyaW5nc1VzaW5nRGljZUNvZWZmaWNpZW50ID0gY29tcGFyZVR3b1N0cmluZ3NVc2luZ0RpY2VDb2VmZmljaWVudDtcblxudmFyIGJyb3dzZXJTdXBwb3J0c1BvbHlmaWxscyA9IGZ1bmN0aW9uIGJyb3dzZXJTdXBwb3J0c1BvbHlmaWxscygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uYXZpZ2F0b3IgIT09IHVuZGVmaW5lZCAmJiB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAhPT0gdW5kZWZpbmVkICYmIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSAhPT0gdW5kZWZpbmVkICYmICh3aW5kb3cuQXVkaW9Db250ZXh0ICE9PSB1bmRlZmluZWQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCAhPT0gdW5kZWZpbmVkKTtcbn07XG5cbmV4cG9ydHMuYnJvd3NlclN1cHBvcnRzUG9seWZpbGxzID0gYnJvd3NlclN1cHBvcnRzUG9seWZpbGxzOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImJyb3dzZXJTdXBwb3J0c1BvbHlmaWxscyIsImNvbXBhcmVUd29TdHJpbmdzVXNpbmdEaWNlQ29lZmZpY2llbnQiLCJjb21tYW5kVG9SZWdFeHAiLCJjb25jYXRUcmFuc2NyaXB0cyIsImRlYm91bmNlIiwiZnVuYyIsIndhaXQiLCJpbW1lZGlhdGUiLCJ0aW1lb3V0IiwiY29udGV4dCIsImFyZ3MiLCJhcmd1bWVudHMiLCJsYXRlciIsImFwcGx5IiwiY2FsbE5vdyIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJfbGVuIiwibGVuZ3RoIiwidHJhbnNjcmlwdFBhcnRzIiwiQXJyYXkiLCJfa2V5IiwibWFwIiwidCIsInRyaW0iLCJqb2luIiwib3B0aW9uYWxQYXJhbSIsIm9wdGlvbmFsUmVnZXgiLCJuYW1lZFBhcmFtIiwic3BsYXRQYXJhbSIsImVzY2FwZVJlZ0V4cCIsImNvbW1hbmQiLCJSZWdFeHAiLCJzb3VyY2UiLCJyZXBsYWNlIiwibWF0Y2giLCJvcHRpb25hbCIsImZpcnN0Iiwic2Vjb25kIiwidG9Mb3dlckNhc2UiLCJmaXJzdEJpZ3JhbXMiLCJNYXAiLCJpIiwiYmlncmFtIiwic3Vic3RyaW5nIiwiY291bnQiLCJoYXMiLCJnZXQiLCJzZXQiLCJpbnRlcnNlY3Rpb25TaXplIiwiX2kiLCJfYmlncmFtIiwiX2NvdW50Iiwid2luZG93IiwibmF2aWdhdG9yIiwidW5kZWZpbmVkIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwiQXVkaW9Db250ZXh0Iiwid2Via2l0QXVkaW9Db250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-speech-recognition/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-use-clipboard/dist/react-use-clipboard.module.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/react-use-clipboard/dist/react-use-clipboard.module.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var copy_to_clipboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! copy-to-clipboard */ \"(app-pages-browser)/./node_modules/copy-to-clipboard/index.js\");\n/* harmony import */ var copy_to_clipboard__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(copy_to_clipboard__WEBPACK_IMPORTED_MODULE_1__);\n\n\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(n, i) {\n    var u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), c = u[0], e = u[1], f = i && i.successDuration;\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        if (c && f) {\n            var t = setTimeout(function() {\n                e(!1);\n            }, f);\n            return function() {\n                clearTimeout(t);\n            };\n        }\n    }, [\n        c,\n        f\n    ]), [\n        c,\n        function() {\n            var t = copy_to_clipboard__WEBPACK_IMPORTED_MODULE_1___default()(n);\n            e(t);\n        }\n    ];\n} //# sourceMappingURL=react-use-clipboard.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC11c2UtY2xpcGJvYXJkL2Rpc3QvcmVhY3QtdXNlLWNsaXBib2FyZC5tb2R1bGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBZ0Q7QUFBaUM7QUFBQSw2QkFBZSxvQ0FBU0ssQ0FBQyxFQUFDQyxDQUFDO0lBQUUsSUFBSUMsSUFBRU4sK0NBQUNBLENBQUMsQ0FBQyxJQUFHTyxJQUFFRCxDQUFDLENBQUMsRUFBRSxFQUFDRSxJQUFFRixDQUFDLENBQUMsRUFBRSxFQUFDRyxJQUFFSixLQUFHQSxFQUFFSyxlQUFlO0lBQUMsT0FBT1IsZ0RBQUNBLENBQUM7UUFBVyxJQUFHSyxLQUFHRSxHQUFFO1lBQUMsSUFBSVQsSUFBRVcsV0FBVztnQkFBV0gsRUFBRSxDQUFDO1lBQUUsR0FBRUM7WUFBRyxPQUFPO2dCQUFXRyxhQUFhWjtZQUFFO1FBQUM7SUFBQyxHQUFFO1FBQUNPO1FBQUVFO0tBQUUsR0FBRTtRQUFDRjtRQUFFO1lBQVcsSUFBSVAsSUFBRUcsd0RBQUNBLENBQUNDO1lBQUdJLEVBQUVSO1FBQUU7S0FBRTtBQUFBLEVBQzdTLHNEQUFzRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtdXNlLWNsaXBib2FyZC9kaXN0L3JlYWN0LXVzZS1jbGlwYm9hcmQubW9kdWxlLmpzPzlmOTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0e3VzZVN0YXRlIGFzIHQsdXNlRWZmZWN0IGFzIG99ZnJvbVwicmVhY3RcIjtpbXBvcnQgciBmcm9tXCJjb3B5LXRvLWNsaXBib2FyZFwiO2V4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG4saSl7dmFyIHU9dCghMSksYz11WzBdLGU9dVsxXSxmPWkmJmkuc3VjY2Vzc0R1cmF0aW9uO3JldHVybiBvKGZ1bmN0aW9uKCl7aWYoYyYmZil7dmFyIHQ9c2V0VGltZW91dChmdW5jdGlvbigpe2UoITEpfSxmKTtyZXR1cm4gZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQodCl9fX0sW2MsZl0pLFtjLGZ1bmN0aW9uKCl7dmFyIHQ9cihuKTtlKHQpfV19XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC11c2UtY2xpcGJvYXJkLm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInQiLCJ1c2VFZmZlY3QiLCJvIiwiciIsIm4iLCJpIiwidSIsImMiLCJlIiwiZiIsInN1Y2Nlc3NEdXJhdGlvbiIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-use-clipboard/dist/react-use-clipboard.module.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var runtime = function(exports) {\n    \"use strict\";\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    var defineProperty = Object.defineProperty || function(obj, key, desc) {\n        obj[key] = desc.value;\n    };\n    var undefined; // More compressible than void 0.\n    var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n    var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n    var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n    var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n    function define(obj, key, value) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n        return obj[key];\n    }\n    try {\n        // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n        define({}, \"\");\n    } catch (err) {\n        define = function(obj, key, value) {\n            return obj[key] = value;\n        };\n    }\n    function wrap(innerFn, outerFn, self, tryLocsList) {\n        // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n        var generator = Object.create(protoGenerator.prototype);\n        var context = new Context(tryLocsList || []);\n        // The ._invoke method unifies the implementations of the .next,\n        // .throw, and .return methods.\n        defineProperty(generator, \"_invoke\", {\n            value: makeInvokeMethod(innerFn, self, context)\n        });\n        return generator;\n    }\n    exports.wrap = wrap;\n    // Try/catch helper to minimize deoptimizations. Returns a completion\n    // record like context.tryEntries[i].completion. This interface could\n    // have been (and was previously) designed to take a closure to be\n    // invoked without arguments, but in all the cases we care about we\n    // already have an existing method we want to call, so there's no need\n    // to create a new function object. We can even get away with assuming\n    // the method takes exactly one argument, since that happens to be true\n    // in every case, so we don't have to touch the arguments object. The\n    // only additional allocation required is the completion record, which\n    // has a stable shape and so hopefully should be cheap to allocate.\n    function tryCatch(fn, obj, arg) {\n        try {\n            return {\n                type: \"normal\",\n                arg: fn.call(obj, arg)\n            };\n        } catch (err) {\n            return {\n                type: \"throw\",\n                arg: err\n            };\n        }\n    }\n    var GenStateSuspendedStart = \"suspendedStart\";\n    var GenStateSuspendedYield = \"suspendedYield\";\n    var GenStateExecuting = \"executing\";\n    var GenStateCompleted = \"completed\";\n    // Returning this object from the innerFn has the same effect as\n    // breaking out of the dispatch switch statement.\n    var ContinueSentinel = {};\n    // Dummy constructor functions that we use as the .constructor and\n    // .constructor.prototype properties for functions that return Generator\n    // objects. For full spec compliance, you may wish to configure your\n    // minifier not to mangle the names of these two functions.\n    function Generator() {}\n    function GeneratorFunction() {}\n    function GeneratorFunctionPrototype() {}\n    // This is a polyfill for %IteratorPrototype% for environments that\n    // don't natively support it.\n    var IteratorPrototype = {};\n    define(IteratorPrototype, iteratorSymbol, function() {\n        return this;\n    });\n    var getProto = Object.getPrototypeOf;\n    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n        // This environment has a native %IteratorPrototype%; use it instead\n        // of the polyfill.\n        IteratorPrototype = NativeIteratorPrototype;\n    }\n    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n    GeneratorFunction.prototype = GeneratorFunctionPrototype;\n    defineProperty(Gp, \"constructor\", {\n        value: GeneratorFunctionPrototype,\n        configurable: true\n    });\n    defineProperty(GeneratorFunctionPrototype, \"constructor\", {\n        value: GeneratorFunction,\n        configurable: true\n    });\n    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\");\n    // Helper for defining the .next, .throw, and .return methods of the\n    // Iterator interface in terms of a single ._invoke method.\n    function defineIteratorMethods(prototype) {\n        [\n            \"next\",\n            \"throw\",\n            \"return\"\n        ].forEach(function(method) {\n            define(prototype, method, function(arg) {\n                return this._invoke(method, arg);\n            });\n        });\n    }\n    exports.isGeneratorFunction = function(genFun) {\n        var ctor = typeof genFun === \"function\" && genFun.constructor;\n        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n    };\n    exports.mark = function(genFun) {\n        if (Object.setPrototypeOf) {\n            Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n        } else {\n            genFun.__proto__ = GeneratorFunctionPrototype;\n            define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n        }\n        genFun.prototype = Object.create(Gp);\n        return genFun;\n    };\n    // Within the body of any async function, `await x` is transformed to\n    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n    // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n    // meant to be awaited.\n    exports.awrap = function(arg) {\n        return {\n            __await: arg\n        };\n    };\n    function AsyncIterator(generator, PromiseImpl) {\n        function invoke(method, arg, resolve, reject) {\n            var record = tryCatch(generator[method], generator, arg);\n            if (record.type === \"throw\") {\n                reject(record.arg);\n            } else {\n                var result = record.arg;\n                var value = result.value;\n                if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n                    return PromiseImpl.resolve(value.__await).then(function(value) {\n                        invoke(\"next\", value, resolve, reject);\n                    }, function(err) {\n                        invoke(\"throw\", err, resolve, reject);\n                    });\n                }\n                return PromiseImpl.resolve(value).then(function(unwrapped) {\n                    // When a yielded Promise is resolved, its final value becomes\n                    // the .value of the Promise<{value,done}> result for the\n                    // current iteration.\n                    result.value = unwrapped;\n                    resolve(result);\n                }, function(error) {\n                    // If a rejected Promise was yielded, throw the rejection back\n                    // into the async generator function so it can be handled there.\n                    return invoke(\"throw\", error, resolve, reject);\n                });\n            }\n        }\n        var previousPromise;\n        function enqueue(method, arg) {\n            function callInvokeWithMethodAndArg() {\n                return new PromiseImpl(function(resolve, reject) {\n                    invoke(method, arg, resolve, reject);\n                });\n            }\n            return previousPromise = // If enqueue has been called before, then we want to wait until\n            // all previous Promises have been resolved before calling invoke,\n            // so that results are always delivered in the correct order. If\n            // enqueue has not been called before, then it is important to\n            // call invoke immediately, without waiting on a callback to fire,\n            // so that the async generator function has the opportunity to do\n            // any necessary setup in a predictable way. This predictability\n            // is why the Promise constructor synchronously invokes its\n            // executor callback, and why async functions synchronously\n            // execute code before the first await. Since we implement simple\n            // async functions in terms of async generators, it is especially\n            // important to get this right, even though it requires care.\n            previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n            // invocations of the iterator.\n            callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n        }\n        // Define the unified helper method that is used to implement .next,\n        // .throw, and .return (see defineIteratorMethods).\n        defineProperty(this, \"_invoke\", {\n            value: enqueue\n        });\n    }\n    defineIteratorMethods(AsyncIterator.prototype);\n    define(AsyncIterator.prototype, asyncIteratorSymbol, function() {\n        return this;\n    });\n    exports.AsyncIterator = AsyncIterator;\n    // Note that simple async functions are implemented on top of\n    // AsyncIterator objects; they just return a Promise for the value of\n    // the final result produced by the iterator.\n    exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n        if (PromiseImpl === void 0) PromiseImpl = Promise;\n        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n        return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n         : iter.next().then(function(result) {\n            return result.done ? result.value : iter.next();\n        });\n    };\n    function makeInvokeMethod(innerFn, self, context) {\n        var state = GenStateSuspendedStart;\n        return function invoke(method, arg) {\n            if (state === GenStateExecuting) {\n                throw new Error(\"Generator is already running\");\n            }\n            if (state === GenStateCompleted) {\n                if (method === \"throw\") {\n                    throw arg;\n                }\n                // Be forgiving, per GeneratorResume behavior specified since ES2015:\n                // ES2015 spec, step 3: https://262.ecma-international.org/6.0/#sec-generatorresume\n                // Latest spec, step 2: https://tc39.es/ecma262/#sec-generatorresume\n                return doneResult();\n            }\n            context.method = method;\n            context.arg = arg;\n            while(true){\n                var delegate = context.delegate;\n                if (delegate) {\n                    var delegateResult = maybeInvokeDelegate(delegate, context);\n                    if (delegateResult) {\n                        if (delegateResult === ContinueSentinel) continue;\n                        return delegateResult;\n                    }\n                }\n                if (context.method === \"next\") {\n                    // Setting context._sent for legacy support of Babel's\n                    // function.sent implementation.\n                    context.sent = context._sent = context.arg;\n                } else if (context.method === \"throw\") {\n                    if (state === GenStateSuspendedStart) {\n                        state = GenStateCompleted;\n                        throw context.arg;\n                    }\n                    context.dispatchException(context.arg);\n                } else if (context.method === \"return\") {\n                    context.abrupt(\"return\", context.arg);\n                }\n                state = GenStateExecuting;\n                var record = tryCatch(innerFn, self, context);\n                if (record.type === \"normal\") {\n                    // If an exception is thrown from innerFn, we leave state ===\n                    // GenStateExecuting and loop back for another invocation.\n                    state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n                    if (record.arg === ContinueSentinel) {\n                        continue;\n                    }\n                    return {\n                        value: record.arg,\n                        done: context.done\n                    };\n                } else if (record.type === \"throw\") {\n                    state = GenStateCompleted;\n                    // Dispatch the exception by looping back around to the\n                    // context.dispatchException(context.arg) call above.\n                    context.method = \"throw\";\n                    context.arg = record.arg;\n                }\n            }\n        };\n    }\n    // Call delegate.iterator[context.method](context.arg) and handle the\n    // result, either by returning a { value, done } result from the\n    // delegate iterator, or by modifying context.method and context.arg,\n    // setting context.delegate to null, and returning the ContinueSentinel.\n    function maybeInvokeDelegate(delegate, context) {\n        var methodName = context.method;\n        var method = delegate.iterator[methodName];\n        if (method === undefined) {\n            // A .throw or .return when the delegate iterator has no .throw\n            // method, or a missing .next method, always terminate the\n            // yield* loop.\n            context.delegate = null;\n            // Note: [\"return\"] must be used for ES3 parsing compatibility.\n            if (methodName === \"throw\" && delegate.iterator[\"return\"]) {\n                // If the delegate iterator has a return method, give it a\n                // chance to clean up.\n                context.method = \"return\";\n                context.arg = undefined;\n                maybeInvokeDelegate(delegate, context);\n                if (context.method === \"throw\") {\n                    // If maybeInvokeDelegate(context) changed context.method from\n                    // \"return\" to \"throw\", let that override the TypeError below.\n                    return ContinueSentinel;\n                }\n            }\n            if (methodName !== \"return\") {\n                context.method = \"throw\";\n                context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\");\n            }\n            return ContinueSentinel;\n        }\n        var record = tryCatch(method, delegate.iterator, context.arg);\n        if (record.type === \"throw\") {\n            context.method = \"throw\";\n            context.arg = record.arg;\n            context.delegate = null;\n            return ContinueSentinel;\n        }\n        var info = record.arg;\n        if (!info) {\n            context.method = \"throw\";\n            context.arg = new TypeError(\"iterator result is not an object\");\n            context.delegate = null;\n            return ContinueSentinel;\n        }\n        if (info.done) {\n            // Assign the result of the finished delegate to the temporary\n            // variable specified by delegate.resultName (see delegateYield).\n            context[delegate.resultName] = info.value;\n            // Resume execution at the desired location (see delegateYield).\n            context.next = delegate.nextLoc;\n            // If context.method was \"throw\" but the delegate handled the\n            // exception, let the outer generator proceed normally. If\n            // context.method was \"next\", forget context.arg since it has been\n            // \"consumed\" by the delegate iterator. If context.method was\n            // \"return\", allow the original .return call to continue in the\n            // outer generator.\n            if (context.method !== \"return\") {\n                context.method = \"next\";\n                context.arg = undefined;\n            }\n        } else {\n            // Re-yield the result returned by the delegate method.\n            return info;\n        }\n        // The delegate iterator is finished, so forget it and continue with\n        // the outer generator.\n        context.delegate = null;\n        return ContinueSentinel;\n    }\n    // Define Generator.prototype.{next,throw,return} in terms of the\n    // unified ._invoke helper method.\n    defineIteratorMethods(Gp);\n    define(Gp, toStringTagSymbol, \"Generator\");\n    // A Generator should always return itself as the iterator object when the\n    // @@iterator function is called on it. Some browsers' implementations of the\n    // iterator prototype chain incorrectly implement this, causing the Generator\n    // object to not be returned from this call. This ensures that doesn't happen.\n    // See https://github.com/facebook/regenerator/issues/274 for more details.\n    define(Gp, iteratorSymbol, function() {\n        return this;\n    });\n    define(Gp, \"toString\", function() {\n        return \"[object Generator]\";\n    });\n    function pushTryEntry(locs) {\n        var entry = {\n            tryLoc: locs[0]\n        };\n        if (1 in locs) {\n            entry.catchLoc = locs[1];\n        }\n        if (2 in locs) {\n            entry.finallyLoc = locs[2];\n            entry.afterLoc = locs[3];\n        }\n        this.tryEntries.push(entry);\n    }\n    function resetTryEntry(entry) {\n        var record = entry.completion || {};\n        record.type = \"normal\";\n        delete record.arg;\n        entry.completion = record;\n    }\n    function Context(tryLocsList) {\n        // The root entry object (effectively a try statement without a catch\n        // or a finally block) gives us a place to store values thrown from\n        // locations where there is no enclosing try statement.\n        this.tryEntries = [\n            {\n                tryLoc: \"root\"\n            }\n        ];\n        tryLocsList.forEach(pushTryEntry, this);\n        this.reset(true);\n    }\n    exports.keys = function(val) {\n        var object = Object(val);\n        var keys = [];\n        for(var key in object){\n            keys.push(key);\n        }\n        keys.reverse();\n        // Rather than returning an object with a next method, we keep\n        // things simple and return the next function itself.\n        return function next() {\n            while(keys.length){\n                var key = keys.pop();\n                if (key in object) {\n                    next.value = key;\n                    next.done = false;\n                    return next;\n                }\n            }\n            // To avoid creating an additional object, we just hang the .value\n            // and .done properties off the next function object itself. This\n            // also ensures that the minifier will not anonymize the function.\n            next.done = true;\n            return next;\n        };\n    };\n    function values(iterable) {\n        if (iterable != null) {\n            var iteratorMethod = iterable[iteratorSymbol];\n            if (iteratorMethod) {\n                return iteratorMethod.call(iterable);\n            }\n            if (typeof iterable.next === \"function\") {\n                return iterable;\n            }\n            if (!isNaN(iterable.length)) {\n                var i = -1, next = function next() {\n                    while(++i < iterable.length){\n                        if (hasOwn.call(iterable, i)) {\n                            next.value = iterable[i];\n                            next.done = false;\n                            return next;\n                        }\n                    }\n                    next.value = undefined;\n                    next.done = true;\n                    return next;\n                };\n                return next.next = next;\n            }\n        }\n        throw new TypeError(typeof iterable + \" is not iterable\");\n    }\n    exports.values = values;\n    function doneResult() {\n        return {\n            value: undefined,\n            done: true\n        };\n    }\n    Context.prototype = {\n        constructor: Context,\n        reset: function(skipTempReset) {\n            this.prev = 0;\n            this.next = 0;\n            // Resetting context._sent for legacy support of Babel's\n            // function.sent implementation.\n            this.sent = this._sent = undefined;\n            this.done = false;\n            this.delegate = null;\n            this.method = \"next\";\n            this.arg = undefined;\n            this.tryEntries.forEach(resetTryEntry);\n            if (!skipTempReset) {\n                for(var name in this){\n                    // Not sure about the optimal order of these conditions:\n                    if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n                        this[name] = undefined;\n                    }\n                }\n            }\n        },\n        stop: function() {\n            this.done = true;\n            var rootEntry = this.tryEntries[0];\n            var rootRecord = rootEntry.completion;\n            if (rootRecord.type === \"throw\") {\n                throw rootRecord.arg;\n            }\n            return this.rval;\n        },\n        dispatchException: function(exception) {\n            if (this.done) {\n                throw exception;\n            }\n            var context = this;\n            function handle(loc, caught) {\n                record.type = \"throw\";\n                record.arg = exception;\n                context.next = loc;\n                if (caught) {\n                    // If the dispatched exception was caught by a catch block,\n                    // then let that catch block handle the exception normally.\n                    context.method = \"next\";\n                    context.arg = undefined;\n                }\n                return !!caught;\n            }\n            for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                var entry = this.tryEntries[i];\n                var record = entry.completion;\n                if (entry.tryLoc === \"root\") {\n                    // Exception thrown outside of any try block that could handle\n                    // it, so set the completion value of the entire function to\n                    // throw the exception.\n                    return handle(\"end\");\n                }\n                if (entry.tryLoc <= this.prev) {\n                    var hasCatch = hasOwn.call(entry, \"catchLoc\");\n                    var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n                    if (hasCatch && hasFinally) {\n                        if (this.prev < entry.catchLoc) {\n                            return handle(entry.catchLoc, true);\n                        } else if (this.prev < entry.finallyLoc) {\n                            return handle(entry.finallyLoc);\n                        }\n                    } else if (hasCatch) {\n                        if (this.prev < entry.catchLoc) {\n                            return handle(entry.catchLoc, true);\n                        }\n                    } else if (hasFinally) {\n                        if (this.prev < entry.finallyLoc) {\n                            return handle(entry.finallyLoc);\n                        }\n                    } else {\n                        throw new Error(\"try statement without catch or finally\");\n                    }\n                }\n            }\n        },\n        abrupt: function(type, arg) {\n            for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                var entry = this.tryEntries[i];\n                if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n                    var finallyEntry = entry;\n                    break;\n                }\n            }\n            if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n                // Ignore the finally entry if control is not jumping to a\n                // location outside the try/catch block.\n                finallyEntry = null;\n            }\n            var record = finallyEntry ? finallyEntry.completion : {};\n            record.type = type;\n            record.arg = arg;\n            if (finallyEntry) {\n                this.method = \"next\";\n                this.next = finallyEntry.finallyLoc;\n                return ContinueSentinel;\n            }\n            return this.complete(record);\n        },\n        complete: function(record, afterLoc) {\n            if (record.type === \"throw\") {\n                throw record.arg;\n            }\n            if (record.type === \"break\" || record.type === \"continue\") {\n                this.next = record.arg;\n            } else if (record.type === \"return\") {\n                this.rval = this.arg = record.arg;\n                this.method = \"return\";\n                this.next = \"end\";\n            } else if (record.type === \"normal\" && afterLoc) {\n                this.next = afterLoc;\n            }\n            return ContinueSentinel;\n        },\n        finish: function(finallyLoc) {\n            for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                var entry = this.tryEntries[i];\n                if (entry.finallyLoc === finallyLoc) {\n                    this.complete(entry.completion, entry.afterLoc);\n                    resetTryEntry(entry);\n                    return ContinueSentinel;\n                }\n            }\n        },\n        \"catch\": function(tryLoc) {\n            for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                var entry = this.tryEntries[i];\n                if (entry.tryLoc === tryLoc) {\n                    var record = entry.completion;\n                    if (record.type === \"throw\") {\n                        var thrown = record.arg;\n                        resetTryEntry(entry);\n                    }\n                    return thrown;\n                }\n            }\n            // The context.catch method must only be called with a location\n            // argument that corresponds to a known catch block.\n            throw new Error(\"illegal catch attempt\");\n        },\n        delegateYield: function(iterable, resultName, nextLoc) {\n            this.delegate = {\n                iterator: values(iterable),\n                resultName: resultName,\n                nextLoc: nextLoc\n            };\n            if (this.method === \"next\") {\n                // Deliberately forget the last sent value so that we don't\n                // accidentally pass it on to the delegate.\n                this.arg = undefined;\n            }\n            return ContinueSentinel;\n        }\n    };\n    // Regardless of whether this script is executing as a CommonJS module\n    // or not, return the runtime object so that we can declare the variable\n    // regeneratorRuntime in the outer scope, which allows this module to be\n    // injected easily by `bin/regenerator --include-runtime script.js`.\n    return exports;\n}(// If this script is executing as a CommonJS module, use module.exports\n// as the regeneratorRuntime namespace. Otherwise create a new empty\n// object. Either way, the resulting object will be used to initialize\n// the regeneratorRuntime variable at the top of this file.\n true ? module.exports : 0);\ntry {\n    regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n    // This module should not be running in strict mode, so the above\n    // assignment should always work unless something is misconfigured. Just\n    // in case runtime.js accidentally runs in strict mode, in modern engines\n    // we can explicitly access globalThis. In older engines we can escape\n    // strict mode using a global Function call. This could conceivably fail\n    // if a Content Security Policy forbids using Function, but in that case\n    // the proper solution is to fix the accidental strict mode problem. If\n    // you've misconfigured your bundler to force strict mode and applied a\n    // CSP to forbid Function, and you're not willing to fix either of those\n    // problems, please detail your unique predicament in a GitHub issue.\n    if (typeof globalThis === \"object\") {\n        globalThis.regeneratorRuntime = runtime;\n    } else {\n        Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0MsR0FFRCxJQUFJQSxVQUFXLFNBQVVDLE9BQU87SUFDOUI7SUFFQSxJQUFJQyxLQUFLQyxPQUFPQyxTQUFTO0lBQ3pCLElBQUlDLFNBQVNILEdBQUdJLGNBQWM7SUFDOUIsSUFBSUMsaUJBQWlCSixPQUFPSSxjQUFjLElBQUksU0FBVUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLElBQUk7UUFBSUYsR0FBRyxDQUFDQyxJQUFJLEdBQUdDLEtBQUtDLEtBQUs7SUFBRTtJQUNqRyxJQUFJQyxXQUFXLGlDQUFpQztJQUNoRCxJQUFJQyxVQUFVLE9BQU9DLFdBQVcsYUFBYUEsU0FBUyxDQUFDO0lBQ3ZELElBQUlDLGlCQUFpQkYsUUFBUUcsUUFBUSxJQUFJO0lBQ3pDLElBQUlDLHNCQUFzQkosUUFBUUssYUFBYSxJQUFJO0lBQ25ELElBQUlDLG9CQUFvQk4sUUFBUU8sV0FBVyxJQUFJO0lBRS9DLFNBQVNDLE9BQU9iLEdBQUcsRUFBRUMsR0FBRyxFQUFFRSxLQUFLO1FBQzdCUixPQUFPSSxjQUFjLENBQUNDLEtBQUtDLEtBQUs7WUFDOUJFLE9BQU9BO1lBQ1BXLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1FBQ1o7UUFDQSxPQUFPaEIsR0FBRyxDQUFDQyxJQUFJO0lBQ2pCO0lBQ0EsSUFBSTtRQUNGLDBFQUEwRTtRQUMxRVksT0FBTyxDQUFDLEdBQUc7SUFDYixFQUFFLE9BQU9JLEtBQUs7UUFDWkosU0FBUyxTQUFTYixHQUFHLEVBQUVDLEdBQUcsRUFBRUUsS0FBSztZQUMvQixPQUFPSCxHQUFHLENBQUNDLElBQUksR0FBR0U7UUFDcEI7SUFDRjtJQUVBLFNBQVNlLEtBQUtDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxJQUFJLEVBQUVDLFdBQVc7UUFDL0MseUdBQXlHO1FBQ3pHLElBQUlDLGlCQUFpQkgs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O2dCQUNqQnBCLFlBQVlBO2dCQUNaQyxTQUFTQTtZQUNYO1lBRUEsSUFBSSxJQUFJLENBQUM1QyxNQUFNLEtBQUssUUFBUTtnQkFDMUIsMkRBQTJEO2dCQUMzRCwyQ0FBMkM7Z0JBQzNDLElBQUksQ0FBQ25CLEdBQUcsR0FBRzVCO1lBQ2I7WUFFQSxPQUFPbUM7UUFDVDtJQUNGO0lBRUEsc0VBQXNFO0lBQ3RFLHdFQUF3RTtJQUN4RSx3RUFBd0U7SUFDeEUsb0VBQW9FO0lBQ3BFLE9BQU85QztBQUVULEVBQ0UsdUVBQXVFO0FBQ3ZFLG9FQUFvRTtBQUNwRSxzRUFBc0U7QUFDdEUsMkRBQTJEO0FBQzNELEtBQTBCLEdBQUdnSixPQUFPaEosT0FBTyxHQUFHLENBQUU7QUFHbEQsSUFBSTtJQUNGaUoscUJBQXFCbEo7QUFDdkIsRUFBRSxPQUFPbUosc0JBQXNCO0lBQzdCLGlFQUFpRTtJQUNqRSx3RUFBd0U7SUFDeEUseUVBQXlFO0lBQ3pFLHNFQUFzRTtJQUN0RSx3RUFBd0U7SUFDeEUsd0VBQXdFO0lBQ3hFLHVFQUF1RTtJQUN2RSx1RUFBdUU7SUFDdkUsd0VBQXdFO0lBQ3hFLHFFQUFxRTtJQUNyRSxJQUFJLE9BQU9DLGVBQWUsVUFBVTtRQUNsQ0EsV0FBV0Ysa0JBQWtCLEdBQUdsSjtJQUNsQyxPQUFPO1FBQ0xxSixTQUFTLEtBQUssMEJBQTBCcko7SUFDMUM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzP2M1NmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbiAob2JqLCBrZXksIGRlc2MpIHsgb2JqW2tleV0gPSBkZXNjLnZhbHVlOyB9O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBJRSA4IGhhcyBhIGJyb2tlbiBPYmplY3QuZGVmaW5lUHJvcGVydHkgdGhhdCBvbmx5IHdvcmtzIG9uIERPTSBvYmplY3RzLlxuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBkZWZpbmVQcm9wZXJ0eShnZW5lcmF0b3IsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIH0pO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIGRlZmluZVByb3BlcnR5KEdwLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIGRlZmluZVByb3BlcnR5KFxuICAgIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLFxuICAgIFwiY29uc3RydWN0b3JcIixcbiAgICB7IHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvbiwgY29uZmlndXJhYmxlOiB0cnVlIH1cbiAgKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIGRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBlbnF1ZXVlIH0pO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcblxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcbiAgICAgIFByb21pc2VJbXBsXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgR2VuZXJhdG9yUmVzdW1lIGJlaGF2aW9yIHNwZWNpZmllZCBzaW5jZSBFUzIwMTU6XG4gICAgICAgIC8vIEVTMjAxNSBzcGVjLCBzdGVwIDM6IGh0dHBzOi8vMjYyLmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvNi4wLyNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIC8vIExhdGVzdCBzcGVjLCBzdGVwIDI6IGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kTmFtZSA9IGNvbnRleHQubWV0aG9kO1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2ROYW1lXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kLCBvciBhIG1pc3NpbmcgLm5leHQgbWV0aG9kLCBhbHdheXMgdGVybWluYXRlIHRoZVxuICAgICAgLy8geWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgIGlmIChtZXRob2ROYW1lID09PSBcInRocm93XCIgJiYgZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1ldGhvZE5hbWUgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ1wiICsgbWV0aG9kTmFtZSArIFwiJyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9KTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhciBvYmplY3QgPSBPYmplY3QodmFsKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlICE9IG51bGwpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcih0eXBlb2YgaXRlcmFibGUgKyBcIiBpcyBub3QgaXRlcmFibGVcIik7XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgaW4gbW9kZXJuIGVuZ2luZXNcbiAgLy8gd2UgY2FuIGV4cGxpY2l0bHkgYWNjZXNzIGdsb2JhbFRoaXMuIEluIG9sZGVyIGVuZ2luZXMgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiKSB7XG4gICAgZ2xvYmFsVGhpcy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xuICB9IGVsc2Uge1xuICAgIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiZXhwb3J0cyIsIk9wIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duIiwiaGFzT3duUHJvcGVydHkiLCJkZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsImRlc2MiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsIiRTeW1ib2wiLCJTeW1ib2wiLCJpdGVyYXRvclN5bWJvbCIsIml0ZXJhdG9yIiwiYXN5bmNJdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJ0b1N0cmluZ1RhZ1N5bWJvbCIsInRvU3RyaW5nVGFnIiwiZGVmaW5lIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiZXJyIiwid3JhcCIsImlubmVyRm4iLCJvdXRlckZuIiwic2VsZiIsInRyeUxvY3NMaXN0IiwicHJvdG9HZW5lcmF0b3IiLCJHZW5lcmF0b3IiLCJnZW5lcmF0b3IiLCJjcmVhdGUiLCJjb250ZXh0IiwiQ29udGV4dCIsIm1ha2VJbnZva2VNZXRob2QiLCJ0cnlDYXRjaCIsImZuIiwiYXJnIiwidHlwZSIsImNhbGwiLCJHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0IiwiR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCIsIkdlblN0YXRlRXhlY3V0aW5nIiwiR2VuU3RhdGVDb21wbGV0ZWQiLCJDb250aW51ZVNlbnRpbmVsIiwiR2VuZXJhdG9yRnVuY3Rpb24iLCJHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsIk5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlIiwidmFsdWVzIiwiR3AiLCJkaXNwbGF5TmFtZSIsImRlZmluZUl0ZXJhdG9yTWV0aG9kcyIsImZvckVhY2giLCJtZXRob2QiLCJfaW52b2tlIiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsImdlbkZ1biIsImN0b3IiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJtYXJrIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJhd3JhcCIsIl9fYXdhaXQiLCJBc3luY0l0ZXJhdG9yIiwiUHJvbWlzZUltcGwiLCJpbnZva2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVjb3JkIiwicmVzdWx0IiwidGhlbiIsInVud3JhcHBlZCIsImVycm9yIiwicHJldmlvdXNQcm9taXNlIiwiZW5xdWV1ZSIsImNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnIiwiYXN5bmMiLCJQcm9taXNlIiwiaXRlciIsIm5leHQiLCJkb25lIiwic3RhdGUiLCJFcnJvciIsImRvbmVSZXN1bHQiLCJkZWxlZ2F0ZSIsImRlbGVnYXRlUmVzdWx0IiwibWF5YmVJbnZva2VEZWxlZ2F0ZSIsInNlbnQiLCJfc2VudCIsImRpc3BhdGNoRXhjZXB0aW9uIiwiYWJydXB0IiwibWV0aG9kTmFtZSIsIlR5cGVFcnJvciIsImluZm8iLCJyZXN1bHROYW1lIiwibmV4dExvYyIsInB1c2hUcnlFbnRyeSIsImxvY3MiLCJlbnRyeSIsInRyeUxvYyIsImNhdGNoTG9jIiwiZmluYWxseUxvYyIsImFmdGVyTG9jIiwidHJ5RW50cmllcyIsInB1c2giLCJyZXNldFRyeUVudHJ5IiwiY29tcGxldGlvbiIsInJlc2V0Iiwia2V5cyIsInZhbCIsIm9iamVjdCIsInJldmVyc2UiLCJsZW5ndGgiLCJwb3AiLCJpdGVyYWJsZSIsIml0ZXJhdG9yTWV0aG9kIiwiaXNOYU4iLCJpIiwic2tpcFRlbXBSZXNldCIsInByZXYiLCJjaGFyQXQiLCJzbGljZSIsInN0b3AiLCJyb290RW50cnkiLCJyb290UmVjb3JkIiwicnZhbCIsImV4Y2VwdGlvbiIsImhhbmRsZSIsImxvYyIsImNhdWdodCIsImhhc0NhdGNoIiwiaGFzRmluYWxseSIsImZpbmFsbHlFbnRyeSIsImNvbXBsZXRlIiwiZmluaXNoIiwidGhyb3duIiwiZGVsZWdhdGVZaWVsZCIsIm1vZHVsZSIsInJlZ2VuZXJhdG9yUnVudGltZSIsImFjY2lkZW50YWxTdHJpY3RNb2RlIiwiZ2xvYmFsVGhpcyIsIkZ1bmN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/regenerator-runtime/runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/toggle-selection/index.js":
/*!************************************************!*\
  !*** ./node_modules/toggle-selection/index.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nmodule.exports = function() {\n    var selection = document.getSelection();\n    if (!selection.rangeCount) {\n        return function() {};\n    }\n    var active = document.activeElement;\n    var ranges = [];\n    for(var i = 0; i < selection.rangeCount; i++){\n        ranges.push(selection.getRangeAt(i));\n    }\n    switch(active.tagName.toUpperCase()){\n        case \"INPUT\":\n        case \"TEXTAREA\":\n            active.blur();\n            break;\n        default:\n            active = null;\n            break;\n    }\n    selection.removeAllRanges();\n    return function() {\n        selection.type === \"Caret\" && selection.removeAllRanges();\n        if (!selection.rangeCount) {\n            ranges.forEach(function(range) {\n                selection.addRange(range);\n            });\n        }\n        active && active.focus();\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b2dnbGUtc2VsZWN0aW9uL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFDQUEsT0FBT0MsT0FBTyxHQUFHO0lBQ2YsSUFBSUMsWUFBWUMsU0FBU0MsWUFBWTtJQUNyQyxJQUFJLENBQUNGLFVBQVVHLFVBQVUsRUFBRTtRQUN6QixPQUFPLFlBQWE7SUFDdEI7SUFDQSxJQUFJQyxTQUFTSCxTQUFTSSxhQUFhO0lBRW5DLElBQUlDLFNBQVMsRUFBRTtJQUNmLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJUCxVQUFVRyxVQUFVLEVBQUVJLElBQUs7UUFDN0NELE9BQU9FLElBQUksQ0FBQ1IsVUFBVVMsVUFBVSxDQUFDRjtJQUNuQztJQUVBLE9BQVFILE9BQU9NLE9BQU8sQ0FBQ0MsV0FBVztRQUNoQyxLQUFLO1FBQ0wsS0FBSztZQUNIUCxPQUFPUSxJQUFJO1lBQ1g7UUFFRjtZQUNFUixTQUFTO1lBQ1Q7SUFDSjtJQUVBSixVQUFVYSxlQUFlO0lBQ3pCLE9BQU87UUFDTGIsVUFBVWMsSUFBSSxLQUFLLFdBQ25CZCxVQUFVYSxlQUFlO1FBRXpCLElBQUksQ0FBQ2IsVUFBVUcsVUFBVSxFQUFFO1lBQ3pCRyxPQUFPUyxPQUFPLENBQUMsU0FBU0MsS0FBSztnQkFDM0JoQixVQUFVaUIsUUFBUSxDQUFDRDtZQUNyQjtRQUNGO1FBRUFaLFVBQ0FBLE9BQU9jLEtBQUs7SUFDZDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90b2dnbGUtc2VsZWN0aW9uL2luZGV4LmpzPzViYWUiXSwic291cmNlc0NvbnRlbnQiOlsiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICBpZiAoIXNlbGVjdGlvbi5yYW5nZUNvdW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICB9XG4gIHZhciBhY3RpdmUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gIHZhciByYW5nZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3Rpb24ucmFuZ2VDb3VudDsgaSsrKSB7XG4gICAgcmFuZ2VzLnB1c2goc2VsZWN0aW9uLmdldFJhbmdlQXQoaSkpO1xuICB9XG5cbiAgc3dpdGNoIChhY3RpdmUudGFnTmFtZS50b1VwcGVyQ2FzZSgpKSB7IC8vIC50b1VwcGVyQ2FzZSBoYW5kbGVzIFhIVE1MXG4gICAgY2FzZSAnSU5QVVQnOlxuICAgIGNhc2UgJ1RFWFRBUkVBJzpcbiAgICAgIGFjdGl2ZS5ibHVyKCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBhY3RpdmUgPSBudWxsO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZWN0aW9uLnR5cGUgPT09ICdDYXJldCcgJiZcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBpZiAoIXNlbGVjdGlvbi5yYW5nZUNvdW50KSB7XG4gICAgICByYW5nZXMuZm9yRWFjaChmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYWN0aXZlICYmXG4gICAgYWN0aXZlLmZvY3VzKCk7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJzZWxlY3Rpb24iLCJkb2N1bWVudCIsImdldFNlbGVjdGlvbiIsInJhbmdlQ291bnQiLCJhY3RpdmUiLCJhY3RpdmVFbGVtZW50IiwicmFuZ2VzIiwiaSIsInB1c2giLCJnZXRSYW5nZUF0IiwidGFnTmFtZSIsInRvVXBwZXJDYXNlIiwiYmx1ciIsInJlbW92ZUFsbFJhbmdlcyIsInR5cGUiLCJmb3JFYWNoIiwicmFuZ2UiLCJhZGRSYW5nZSIsImZvY3VzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/toggle-selection/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/components/SpeechSetup.tsx":
/*!****************************************!*\
  !*** ./app/components/SpeechSetup.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SpeechSetup: function() { return /* binding */ SpeechSetup; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! regenerator-runtime/runtime */ \"(app-pages-browser)/./node_modules/regenerator-runtime/runtime.js\");\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_1__);\n// This file properly sets up regenerator-runtime and browser speech recognition API\n/* __next_internal_client_entry_do_not_use__ SpeechSetup auto */ var _s = $RefreshSig$();\n\n// Import regenerator-runtime directly at top level\n\nfunction SpeechSetup() {\n    _s();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (true) {\n            try {\n                // Ensure regenerator-runtime is available globally\n                if (!window.regeneratorRuntime) {\n                    window.regeneratorRuntime = __webpack_require__(/*! regenerator-runtime */ \"(app-pages-browser)/./node_modules/regenerator-runtime/runtime.js\");\n                    console.log(\"Regenerator runtime initialized successfully\");\n                }\n                // Set up browser-specific speech recognition\n                window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n                if (!window.SpeechRecognition) {\n                    console.warn(\"Speech Recognition API is not supported in this browser. Please use Chrome, Edge, or Safari.\");\n                } else {\n                    console.log(\"Speech Recognition API initialized successfully\");\n                }\n            } catch (error) {\n                console.error(\"Failed to initialize speech recognition:\", error);\n            }\n        }\n    }, []);\n    return null; // This component doesn't render anything\n}\n_s(SpeechSetup, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = SpeechSetup;\nvar _c;\n$RefreshReg$(_c, \"SpeechSetup\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL1NwZWVjaFNldHVwLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLG9GQUFvRjs7QUFHbEQ7QUFFbEMsbURBQW1EO0FBQ2Q7QUFXOUIsU0FBU0M7O0lBQ2RELGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxJQUFrQixFQUFhO1lBQ2pDLElBQUk7Z0JBQ0YsbURBQW1EO2dCQUNuRCxJQUFJLENBQUNFLE9BQU9DLGtCQUFrQixFQUFFO29CQUM5QkQsT0FBT0Msa0JBQWtCLEdBQUdDLG1CQUFPQSxDQUFDO29CQUNwQ0MsUUFBUUMsR0FBRyxDQUFDO2dCQUNkO2dCQUVBLDZDQUE2QztnQkFDN0NKLE9BQU9LLGlCQUFpQixHQUFHTCxPQUFPSyxpQkFBaUIsSUFDekJMLE9BQU9NLHVCQUF1QjtnQkFFeEQsSUFBSSxDQUFDTixPQUFPSyxpQkFBaUIsRUFBRTtvQkFDN0JGLFFBQVFJLElBQUksQ0FBQztnQkFDZixPQUFPO29CQUNMSixRQUFRQyxHQUFHLENBQUM7Z0JBQ2Q7WUFDRixFQUFFLE9BQU9JLE9BQU87Z0JBQ2RMLFFBQVFLLEtBQUssQ0FBQyw0Q0FBNENBO1lBQzVEO1FBQ0Y7SUFDRixHQUFHLEVBQUU7SUFFTCxPQUFPLE1BQU0seUNBQXlDO0FBQ3hEO0dBMUJnQlQ7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2NvbXBvbmVudHMvU3BlZWNoU2V0dXAudHN4P2Y5N2EiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBmaWxlIHByb3Blcmx5IHNldHMgdXAgcmVnZW5lcmF0b3ItcnVudGltZSBhbmQgYnJvd3NlciBzcGVlY2ggcmVjb2duaXRpb24gQVBJXG4ndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcblxuLy8gSW1wb3J0IHJlZ2VuZXJhdG9yLXJ1bnRpbWUgZGlyZWN0bHkgYXQgdG9wIGxldmVsXG5pbXBvcnQgJ3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZSc7XG5cbi8vIEFkZCBhIGdsb2JhbCBkZWNsYXJhdGlvbiBmb3IgVHlwZVNjcmlwdFxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICB3ZWJraXRTcGVlY2hSZWNvZ25pdGlvbjogYW55O1xuICAgIFNwZWVjaFJlY29nbml0aW9uOiBhbnk7XG4gICAgcmVnZW5lcmF0b3JSdW50aW1lOiBhbnk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFNwZWVjaFNldHVwKCkge1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRW5zdXJlIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgaXMgYXZhaWxhYmxlIGdsb2JhbGx5XG4gICAgICAgIGlmICghd2luZG93LnJlZ2VuZXJhdG9yUnVudGltZSkge1xuICAgICAgICAgIHdpbmRvdy5yZWdlbmVyYXRvclJ1bnRpbWUgPSByZXF1aXJlKCdyZWdlbmVyYXRvci1ydW50aW1lJyk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1JlZ2VuZXJhdG9yIHJ1bnRpbWUgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNldCB1cCBicm93c2VyLXNwZWNpZmljIHNwZWVjaCByZWNvZ25pdGlvblxuICAgICAgICB3aW5kb3cuU3BlZWNoUmVjb2duaXRpb24gPSB3aW5kb3cuU3BlZWNoUmVjb2duaXRpb24gfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LndlYmtpdFNwZWVjaFJlY29nbml0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBpZiAoIXdpbmRvdy5TcGVlY2hSZWNvZ25pdGlvbikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignU3BlZWNoIFJlY29nbml0aW9uIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4gUGxlYXNlIHVzZSBDaHJvbWUsIEVkZ2UsIG9yIFNhZmFyaS4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnU3BlZWNoIFJlY29nbml0aW9uIEFQSSBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgc3BlZWNoIHJlY29nbml0aW9uOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKTtcbiAgXG4gIHJldHVybiBudWxsOyAvLyBUaGlzIGNvbXBvbmVudCBkb2Vzbid0IHJlbmRlciBhbnl0aGluZ1xufSAiXSwibmFtZXMiOlsidXNlRWZmZWN0IiwiU3BlZWNoU2V0dXAiLCJ3aW5kb3ciLCJyZWdlbmVyYXRvclJ1bnRpbWUiLCJyZXF1aXJlIiwiY29uc29sZSIsImxvZyIsIlNwZWVjaFJlY29nbml0aW9uIiwid2Via2l0U3BlZWNoUmVjb2duaXRpb24iLCJ3YXJuIiwiZXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/SpeechSetup.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/page.client.tsx":
/*!*****************************!*\
  !*** ./app/page.client.tsx ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ClientHome; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! regenerator-runtime/runtime */ \"(app-pages-browser)/./node_modules/regenerator-runtime/runtime.js\");\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_speech_recognition__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-speech-recognition */ \"(app-pages-browser)/./node_modules/react-speech-recognition/lib/index.js\");\n/* harmony import */ var react_use_clipboard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-use-clipboard */ \"(app-pages-browser)/./node_modules/react-use-clipboard/dist/react-use-clipboard.module.js\");\n/* harmony import */ var _app_components_SpeechSetup__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../app/components/SpeechSetup */ \"(app-pages-browser)/./app/components/SpeechSetup.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\nfunction ClientHome() {\n    _s();\n    const [speechInitialized, setSpeechInitialized] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [isListening, setIsListening] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [response, setResponse] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [textInput, setTextInput] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [conversation, setConversation] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n    const [textToCopy, setTextToCopy] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [isCopied, setCopyToClipboard] = (0,react_use_clipboard__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(textToCopy, {\n        successDuration: 2000\n    });\n    const [microphoneError, setMicrophoneError] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const inputRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    const chatContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        try {\n            if ( true && !window.regeneratorRuntime) {\n                window.regeneratorRuntime = __webpack_require__(/*! regenerator-runtime */ \"(app-pages-browser)/./node_modules/regenerator-runtime/runtime.js\");\n            }\n            setSpeechInitialized(true);\n        } catch (error) {\n            console.error(\"Failed to initialize regenerator-runtime:\", error);\n        }\n    }, []);\n    // RevX business information database\n    const businessInfo = {\n        name: \"RevX\",\n        description: \"RevX is a comprehensive technology and digital solutions provider specializing in software development, digital marketing, data science, AI solutions, and OTA (Online Travel Agency) revenue optimization. We help businesses maximize their revenue through strategic partnerships with major OTAs and enhanced digital presence.\",\n        services: [\n            \"Software Development\",\n            \"SEO\",\n            \"Digital Marketing\",\n            \"OTA Solutions\",\n            \"Revenue Optimization\",\n            \"Brand Enhancement\",\n            \"Meta Search Optimization\"\n        ],\n        specialization: \"RevX specializes in comprehensive digital solutions with a strong focus on OTA partnerships and revenue optimization. We help businesses maximize their presence across major travel platforms while strengthening their brand identity.\",\n        experience: \"With years of experience in the travel and hospitality industry, RevX has successfully helped numerous businesses optimize their OTA presence and increase revenue through strategic partnerships and digital optimization.\",\n        expertise: {\n            softwareDevelopment: {\n                services: [\n                    \"Custom Software Solutions\",\n                    \"Web Applications\",\n                    \"Mobile Apps\",\n                    \"API Development\",\n                    \"Cloud Solutions\",\n                    \"Legacy System Modernization\"\n                ],\n                benefits: [\n                    \"Scalable and maintainable solutions\",\n                    \"Improved operational efficiency\",\n                    \"Enhanced user experience\",\n                    \"Cost-effective development\"\n                ]\n            },\n            digitalMarketing: {\n                services: [\n                    \"Search Engine Optimization (SEO)\",\n                    \"Social Media Marketing\",\n                    \"Content Marketing\",\n                    \"Email Marketing\",\n                    \"PPC Advertising\",\n                    \"Brand Strategy\"\n                ],\n                benefits: [\n                    \"Increased online visibility\",\n                    \"Higher conversion rates\",\n                    \"Better customer engagement\",\n                    \"Improved brand recognition\"\n                ]\n            },\n            dataScience: {\n                services: [\n                    \"Data Analytics\",\n                    \"Business Intelligence\",\n                    \"Predictive Modeling\",\n                    \"Performance Analytics\",\n                    \"Market Research\",\n                    \"Competitive Analysis\"\n                ],\n                benefits: [\n                    \"Data-driven decision making\",\n                    \"Improved business insights\",\n                    \"Better market understanding\",\n                    \"Enhanced performance tracking\"\n                ]\n            },\n            aiSolutions: {\n                services: [\n                    \"AI Integration\",\n                    \"Machine Learning\",\n                    \"Natural Language Processing\",\n                    \"Computer Vision\",\n                    \"Predictive Analytics\",\n                    \"Automation Solutions\"\n                ],\n                benefits: [\n                    \"Automated processes\",\n                    \"Enhanced efficiency\",\n                    \"Improved accuracy\",\n                    \"Cost reduction\"\n                ]\n            },\n            otaSolutions: {\n                services: [\n                    \"OTA Channel Management\",\n                    \"Revenue Optimization\",\n                    \"Rate Parity Management\",\n                    \"Inventory Distribution\",\n                    \"Booking Engine Integration\",\n                    \"Performance Analytics\"\n                ],\n                benefits: [\n                    \"Maximized OTA revenue\",\n                    \"Optimized pricing strategy\",\n                    \"Enhanced market presence\",\n                    \"Improved booking conversion\"\n                ]\n            }\n        },\n        caseStudies: [\n            {\n                title: \"OTA Revenue Optimization\",\n                description: \"Successfully helped a hotel chain increase their OTA revenue by 40% through strategic partnerships with major platforms like Booking.com, Agoda, and Expedia.\",\n                results: \"40% revenue increase, improved market presence, enhanced brand visibility\"\n            },\n            {\n                title: \"Digital Transformation\",\n                description: \"Implemented comprehensive digital solutions for a hospitality group, including OTA integration and revenue management systems.\",\n                results: \"25% increase in direct bookings, 35% improvement in OTA performance\"\n            }\n        ],\n        contact: {\n            email: \"info@revx.pro\",\n            phone: \"+1 5107340774\",\n            address: \"Richmond California, USA\",\n            website: \"https://revx.pro\",\n            nepalOffice: {\n                address: \"Sherpa Mall, Durbarmarg, Kathmandu, Nepal\",\n                phone: \"+9779820151343\",\n                mobile: \"+9779856031513\",\n                whatsapp: \"+977985031513\"\n            }\n        },\n        blogs: [\n            \"OTA Revenue Optimization Strategies\",\n            \"Maximizing Your Presence on Booking.com\",\n            \"Effective Rate Parity Management\",\n            \"Digital Marketing for Hospitality\",\n            \"AI in Travel Industry\",\n            \"Meta Search Optimization\"\n        ],\n        otaPartners: [\n            \"Booking.com\",\n            \"Agoda\",\n            \"Ctrip\",\n            \"Trip.com\",\n            \"MakeMyTrip\",\n            \"Expedia\"\n        ],\n        metaSearchPlatforms: [\n            \"Google Hotel Ads\",\n            \"TripAdvisor\",\n            \"Kayak\",\n            \"Skyscanner\",\n            \"Trivago\"\n        ]\n    };\n    const handleQuery = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(async (query)=>{\n        let response = \"\";\n        const lowercaseQuery = query.toLowerCase();\n        // Add user message to conversation\n        setConversation((prev)=>[\n                ...prev,\n                {\n                    type: \"user\",\n                    content: query\n                }\n            ]);\n        // Enhanced greetings and common phrases handling with more variations\n        if (lowercaseQuery.match(/(hello|hi|hey|greetings|good\\s+(morning|afternoon|evening|day)|howdy|yo|sup)/i)) {\n            const timeOfDay = new Date().getHours();\n            let greeting = \"Hello\";\n            if (timeOfDay < 12) greeting = \"Good morning\";\n            else if (timeOfDay < 17) greeting = \"Good afternoon\";\n            else greeting = \"Good evening\";\n            response = \"\".concat(greeting, \"! I'm Spu, RevX's AI assistant. How can I help you today? Feel free to ask about our services, success stories, or how to get in touch with us.\");\n        } else if (lowercaseQuery.match(/(how\\s+are\\s+you|how're\\s+you|how\\s+you\\s+doing|how's\\s+it\\s+going|what's\\s+up|what\\s+is\\s+up|what\\s+are\\s+you\\s+up\\s+to)/i)) {\n            response = \"I'm doing great, thank you for asking! I'm here to help you learn more about RevX. What would you like to know?\";\n        } else if (lowercaseQuery.match(/(thank\\s+you|thanks|appreciate\\s+it|thank\\s+you\\s+so\\s+much|thanks\\s+a\\s+lot|grateful)/i)) {\n            response = \"You're welcome! Is there anything else you'd like to know about RevX?\";\n        } else if (lowercaseQuery.match(/(bye|goodbye|see\\s+you|talk\\s+to\\s+you\\s+later|have\\s+a\\s+good\\s+day|take\\s+care)/i)) {\n            response = \"Thank you for your interest in RevX! If you need any further assistance, don't hesitate to reach out. Have a great day!\";\n        } else if (lowercaseQuery.match(/(who\\s+is\\s+revx|about\\s+revx|what\\s+is\\s+revx|tell\\s+me\\s+about|what\\s+does\\s+revx\\s+do|revx\\s+company|revx\\s+services|revx\\s+description)/i)) {\n            response = businessInfo.description;\n        } else if (lowercaseQuery.match(/(services|what\\s+do\\s+you\\s+offer|offer|provide|what\\s+can\\s+you\\s+do|what\\s+are\\s+your\\s+services|what\\s+services\\s+do\\s+you\\s+provide)/i)) {\n            response = \"RevX offers a comprehensive suite of services including: \".concat(businessInfo.services.join(\", \"), \".\");\n        } else if (lowercaseQuery.match(/(specialization|specialize|industry|what\\s+do\\s+you\\s+specialize\\s+in|what's\\s+your\\s+specialty|what\\s+is\\s+your\\s+expertise)/i)) {\n            response = \"RevX specializes in enhancing digital presence and revenue of businesses, particularly in the \".concat(businessInfo.specialization, \".\");\n        } else if (lowercaseQuery.match(/(experience|how\\s+long|years\\s+of\\s+experience|how\\s+many\\s+years|how\\s+long\\s+have\\s+you\\s+been)/i)) {\n            response = \"RevX has \".concat(businessInfo.experience, \" of experience in the digital consulting industry.\");\n        } else if (lowercaseQuery.match(/(case\\s+stud|success\\s+stor|client\\s+success|testimonial|portfolio|projects|work\\s+examples|previous\\s+work)/i)) {\n            const caseStudiesText = businessInfo.caseStudies.map((cs)=>\"\".concat(cs.title, \": \").concat(cs.description, \". Results: \").concat(cs.results, \".\")).join(\"\\n\\n\");\n            response = \"Here are some of RevX's success stories:\\n\\n\".concat(caseStudiesText);\n        } else if (lowercaseQuery.match(/(contact|reach|get\\s+in\\s+touch|call|phone|email|where\\s+are\\s+you|how\\s+to\\s+contact|contact\\s+information)/i)) {\n            response = \"You can contact RevX at:\\n\\nHeadquarters:\\nEmail: \".concat(businessInfo.contact.email, \"\\nPhone: \").concat(businessInfo.contact.phone, \"\\nAddress: \").concat(businessInfo.contact.address, \"\\n\\nNepal Office:\\nPhone: \").concat(businessInfo.contact.nepalOffice.phone, \"\\nMobile: \").concat(businessInfo.contact.nepalOffice.mobile, \"\\nWhatsApp: \").concat(businessInfo.contact.nepalOffice.whatsapp, \"\\nAddress: \").concat(businessInfo.contact.nepalOffice.address);\n        } else if (lowercaseQuery.match(/(usa|us\\s+office|united\\s+states|california|richmond)/i)) {\n            response = \"RevX's office is located in \".concat(businessInfo.contact.address, \". You can reach them at \").concat(businessInfo.contact.phone, \".\");\n        } else if (lowercaseQuery.match(/(blog|insight|article|thought\\s+leadership|resources|content|publications)/i)) {\n            response = \"RevX shares insights through their blog, covering topics such as:\\n\\n- \".concat(businessInfo.blogs.join(\"\\n- \"));\n        } else if (lowercaseQuery.match(/(revenue\\s+maximization|increase\\s+revenue|boost\\s+revenue|improve\\s+revenue|revenue\\s+optimization|revenue\\s+management)/i)) {\n            response = \"RevX's revenue maximization strategies focus on optimizing pricing, improving operational efficiency, and enhancing customer experience. We help businesses identify new revenue streams, reduce costs, and implement data-driven decision-making processes.\";\n        } else if (lowercaseQuery.match(/(website|site|url|web\\s+address|online\\s+presence|web\\s+presence)/i)) {\n            response = \"You can visit RevX's website at \".concat(businessInfo.contact.website);\n        } else if (lowercaseQuery.match(/(digital\\s+marketing|marketing\\s+services|seo|social\\s+media|online\\s+marketing|digital\\s+advertising|content\\s+marketing)/i)) {\n            const dm = businessInfo.expertise.digitalMarketing;\n            response = \"RevX offers comprehensive digital marketing services including \".concat(dm.services.join(\", \"), \". These services help businesses achieve \").concat(dm.benefits.join(\", \"), \".\");\n        } else if (lowercaseQuery.match(/(ecommerce|online\\s+store|digital\\s+commerce|online\\s+retail|e-commerce|electronic\\s+commerce|online\\s+shopping)/i)) {\n            response = \"RevX provides comprehensive e-commerce solutions including custom platform development, payment integration, inventory management, and customer analytics. Our solutions help businesses create successful online stores with enhanced user experience and increased sales.\";\n        } else if (lowercaseQuery.match(/(development|programming|coding|app\\s+development|website\\s+development|software\\s+development|web\\s+development|mobile\\s+development)/i)) {\n            const sd = businessInfo.expertise.softwareDevelopment;\n            response = \"RevX provides comprehensive development services including \".concat(sd.services.join(\", \"), \". These solutions offer \").concat(sd.benefits.join(\", \"), \".\");\n        } else if (lowercaseQuery.match(/(ai|artificial\\s+intelligence|machine\\s+learning|deep\\s+learning|smart\\s+technology|automation)/i)) {\n            response = \"RevX specializes in AI integration and development, helping businesses leverage artificial intelligence for improved efficiency, customer experience, and decision-making. Our AI solutions include predictive analytics, automated processes, and intelligent customer service systems.\";\n        } else if (lowercaseQuery.match(/(revenue|profit|income|earnings|financial|business\\s+growth|profitability|monetization)/i)) {\n            response = \"RevX's revenue maximization strategies focus on optimizing pricing, improving operational efficiency, and enhancing customer experience. We help businesses identify new revenue streams, reduce costs, and implement data-driven decision-making processes.\";\n        } else if (lowercaseQuery.match(/(software\\s+development|web\\s+development|app\\s+development|programming|coding|development\\s+services)/i)) {\n            const sd = businessInfo.expertise.softwareDevelopment;\n            response = \"RevX provides software development services including \".concat(sd.services.join(\", \"), \". These solutions offer \").concat(sd.benefits.join(\", \"), \".\");\n        } else if (lowercaseQuery.match(/(data\\s+science|data\\s+analytics|big\\s+data|machine\\s+learning|predictive\\s+analytics|business\\s+intelligence)/i)) {\n            const ds = businessInfo.expertise.dataScience;\n            response = \"RevX's data science solutions include \".concat(ds.services.join(\", \"), \". These services help businesses achieve \").concat(ds.benefits.join(\", \"), \".\");\n        } else if (lowercaseQuery.match(/(ai|artificial\\s+intelligence|machine\\s+learning|nlp|computer\\s+vision|ai\\s+solutions)/i)) {\n            const ai = businessInfo.expertise.aiSolutions;\n            response = \"RevX offers AI solutions including \".concat(ai.services.join(\", \"), \". These services provide \").concat(ai.benefits.join(\", \"), \".\");\n        } else if (lowercaseQuery.match(/(ota|online\\s+travel|booking\\.com|agoda|ctrip|trip\\.com|makemytrip|expedia|travel\\s+platform|booking\\s+platform)/i)) {\n            const otaServices = businessInfo.expertise.otaSolutions.services.join(\", \");\n            const otaBenefits = businessInfo.expertise.otaSolutions.benefits.join(\", \");\n            const otaPartners = businessInfo.otaPartners.join(\", \");\n            response = \"RevX provides comprehensive OTA solutions including \".concat(otaServices, \". We work with major platforms like \").concat(otaPartners, \" to help businesses maximize their revenue. Our solutions offer \").concat(otaBenefits, \".\");\n        } else if (lowercaseQuery.match(/(revenue\\s+optimization|boost\\s+revenue|increase\\s+revenue|maximize\\s+revenue|revenue\\s+management|pricing\\s+strategy)/i)) {\n            response = \"RevX specializes in revenue optimization through strategic OTA partnerships and digital solutions. We help businesses maximize their revenue by optimizing pricing strategies, managing rate parity, and enhancing their presence across major travel platforms.\";\n        } else if (lowercaseQuery.match(/(meta\\s+search|google\\s+hotel|tripadvisor|kayak|skyscanner|trivago|travel\\s+search)/i)) {\n            const metaPlatforms = businessInfo.metaSearchPlatforms.join(\", \");\n            response = \"RevX helps businesses optimize their presence on major meta-search platforms including \".concat(metaPlatforms, \". We implement strategies to improve visibility and conversion rates across these platforms.\");\n        } else if (lowercaseQuery.match(/(brand\\s+enhancement|branding|brand\\s+visibility|brand\\s+presence|brand\\s+recognition)/i)) {\n            response = \"RevX provides comprehensive brand enhancement services to improve your presence across OTAs and meta-search platforms. We help businesses strengthen their brand identity and increase visibility to potential customers.\";\n        } else if (lowercaseQuery.match(/(website|web\\s+site|web\\s+development|web\\s+design|web\\s+presence|online\\s+presence)/i)) {\n            response = \"RevX offers comprehensive website development services including custom web applications, responsive design, e-commerce solutions, and web optimization. Our solutions are built with modern technologies and best practices to ensure high performance and user experience.\";\n        } else if (lowercaseQuery.match(/(mobile\\s+app|mobile\\s+application|app\\s+development|ios|android|cross\\s+platform)/i)) {\n            response = \"RevX develops mobile applications for both iOS and Android platforms, as well as cross-platform solutions. Our mobile app development services include native app development, hybrid app development, and progressive web apps (PWAs).\";\n        } else if (lowercaseQuery.match(/(it\\s+consulting|consulting\\s+services|technology\\s+consulting|digital\\s+transformation|tech\\s+consulting)/i)) {\n            response = \"RevX provides IT consulting services to help businesses navigate digital transformation, optimize their technology stack, and implement innovative solutions. Our consulting team offers expertise in software architecture, cloud solutions, and technology strategy.\";\n        } else if (lowercaseQuery.match(/(software\\s+architecture|architecture\\s+design|system\\s+design|technical\\s+architecture|solution\\s+architecture)/i)) {\n            response = \"RevX offers software architecture design services to create scalable, maintainable, and efficient systems. Our architects design robust solutions that align with business goals and technical requirements.\";\n        } else if (lowercaseQuery.match(/(cloud|cloud\\s+computing|cloud\\s+solutions|aws|azure|google\\s+cloud)/i)) {\n            response = \"RevX provides cloud solutions and services, including cloud migration, cloud-native development, and cloud infrastructure management. We work with major cloud providers like AWS, Azure, and Google Cloud.\";\n        } else if (lowercaseQuery.match(/(api|api\\s+development|rest\\s+api|graphql|api\\s+integration|web\\s+services)/i)) {\n            response = \"RevX develops and integrates APIs using modern technologies and best practices. Our API services include RESTful APIs, GraphQL, microservices architecture, and API security implementation.\";\n        } else if (lowercaseQuery.match(/(ui|ux|user\\s+interface|user\\s+experience|design|interface\\s+design)/i)) {\n            response = \"RevX offers UI/UX design services to create intuitive, user-friendly interfaces. Our design team focuses on creating engaging experiences that enhance user satisfaction and drive business goals.\";\n        } else if (lowercaseQuery.match(/(qa|quality\\s+assurance|testing|software\\s+testing|test\\s+automation|quality\\s+testing)/i)) {\n            response = \"RevX provides comprehensive quality assurance services, including manual testing, automated testing, performance testing, and security testing. We ensure high-quality software delivery through rigorous testing processes.\";\n        } else if (lowercaseQuery.match(/(devops|continuous\\s+integration|continuous\\s+deployment|ci|cd|automation)/i)) {\n            response = \"RevX offers DevOps services to streamline software development and deployment processes. Our services include CI/CD pipeline setup, infrastructure automation, containerization, and monitoring solutions.\";\n        } else if (lowercaseQuery.match(/(business\\s+intelligence|bi|analytics|reporting|data\\s+visualization|dashboard)/i)) {\n            response = \"RevX provides business intelligence solutions to help organizations make data-driven decisions. Our services include data visualization, dashboard development, reporting systems, and analytics platforms.\";\n        } else if (lowercaseQuery.match(/(machine\\s+learning|ml|deep\\s+learning|neural\\s+networks|predictive\\s+modeling)/i)) {\n            response = \"RevX develops machine learning solutions for various business applications. Our services include predictive modeling, natural language processing, computer vision, and custom ML model development.\";\n        } else if (lowercaseQuery.match(/(big\\s+data|data\\s+processing|data\\s+warehouse|data\\s+lake|data\\s+analytics)/i)) {\n            response = \"RevX offers big data solutions to help organizations process and analyze large volumes of data. Our services include data warehousing, data lake implementation, real-time analytics, and data processing pipelines.\";\n        } else if (lowercaseQuery.match(/(digital\\s+transformation|digital\\s+strategy|digital\\s+initiative|digital\\s+change|digital\\s+modernization)/i)) {\n            response = \"RevX helps businesses navigate digital transformation by developing comprehensive strategies and implementing modern solutions. Our services include digital strategy consulting, process optimization, and technology modernization.\";\n        } else {\n            response = \"I'm not sure I understand your question. You can ask me about RevX's services, case studies, contact information, or specific topics like digital marketing, e-commerce, development, or revenue optimization. How else can I assist you?\";\n        }\n        setResponse(response);\n        // Add assistant response to conversation\n        setConversation((prev)=>[\n                ...prev,\n                {\n                    type: \"assistant\",\n                    content: response\n                }\n            ]);\n    }, []);\n    const commands = [\n        {\n            command: [\n                \"hello\",\n                \"hi\",\n                \"hey\",\n                \"good morning\",\n                \"good afternoon\",\n                \"good evening\",\n                \"howdy\"\n            ],\n            callback: ()=>handleQuery(\"hello\")\n        },\n        {\n            command: [\n                \"how are you\",\n                \"how's it going\",\n                \"how you doing\"\n            ],\n            callback: ()=>handleQuery(\"how are you\")\n        },\n        {\n            command: [\n                \"thank you\",\n                \"thanks\",\n                \"appreciate it\"\n            ],\n            callback: ()=>handleQuery(\"thank you\")\n        },\n        {\n            command: [\n                \"goodbye\",\n                \"bye\",\n                \"see you\",\n                \"talk to you later\"\n            ],\n            callback: ()=>handleQuery(\"goodbye\")\n        },\n        {\n            command: [\n                \"what is RevX\",\n                \"who is RevX\",\n                \"tell me about RevX\"\n            ],\n            callback: ()=>handleQuery(\"about revx\")\n        },\n        {\n            command: \"what services do you offer\",\n            callback: ()=>handleQuery(\"services\")\n        },\n        {\n            command: [\n                \"how can I contact you\",\n                \"contact information\"\n            ],\n            callback: ()=>handleQuery(\"contact\")\n        },\n        {\n            command: [\n                \"case studies\",\n                \"success stories\"\n            ],\n            callback: ()=>handleQuery(\"case studies\")\n        },\n        {\n            command: [\n                \"digital marketing\",\n                \"marketing services\",\n                \"seo\",\n                \"social media\"\n            ],\n            callback: ()=>handleQuery(\"digital marketing\")\n        },\n        {\n            command: [\n                \"ecommerce\",\n                \"online store\",\n                \"digital commerce\",\n                \"online retail\"\n            ],\n            callback: ()=>handleQuery(\"ecommerce\")\n        },\n        {\n            command: [\n                \"development\",\n                \"programming\",\n                \"coding\",\n                \"app development\",\n                \"website development\"\n            ],\n            callback: ()=>handleQuery(\"development\")\n        },\n        {\n            command: [\n                \"ai\",\n                \"artificial intelligence\",\n                \"machine learning\"\n            ],\n            callback: ()=>handleQuery(\"ai\")\n        },\n        {\n            command: [\n                \"revenue\",\n                \"profit\",\n                \"income\",\n                \"earnings\"\n            ],\n            callback: ()=>handleQuery(\"revenue\")\n        }\n    ];\n    const { transcript, listening, resetTranscript, browserSupportsSpeechRecognition } = (0,react_speech_recognition__WEBPACK_IMPORTED_MODULE_3__.useSpeechRecognition)();\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        if (transcript) {\n            setTextInput(transcript);\n            handleQuery(transcript);\n        }\n    }, [\n        transcript\n    ]);\n    const toggleListening = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(()=>{\n        if (listening) {\n            react_speech_recognition__WEBPACK_IMPORTED_MODULE_3__[\"default\"].stopListening();\n            setIsListening(false);\n        } else {\n            resetTranscript();\n            react_speech_recognition__WEBPACK_IMPORTED_MODULE_3__[\"default\"].startListening({\n                continuous: true\n            });\n            setIsListening(true);\n        }\n    }, [\n        listening,\n        resetTranscript\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        try {\n            if (typeof navigator !== \"undefined\" && navigator.mediaDevices) {\n                console.log(\"Requesting microphone permission...\");\n                navigator.mediaDevices.getUserMedia({\n                    audio: true\n                }).then(()=>{\n                    console.log(\"Microphone permission granted\");\n                    setMicrophoneError(null);\n                }).catch((error)=>{\n                    console.error(\"Microphone error:\", error);\n                    setMicrophoneError(error.message || \"Microphone permission denied\");\n                });\n            } else {\n                console.warn(\"MediaDevices API not available in this browser\");\n                setMicrophoneError(\"MediaDevices API not available in this browser. Please use a modern browser.\");\n            }\n        } catch (error) {\n            console.error(\"Error requesting microphone permissions:\", error);\n            setMicrophoneError(\"Error requesting microphone permissions: \" + (error instanceof Error ? error.message : \"Unknown error\"));\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        setIsListening(listening);\n        console.log(\"Speech recognition listening state:\", listening);\n        if (!browserSupportsSpeechRecognition) {\n            console.error(\"Speech recognition is not supported in this browser\");\n            setMicrophoneError(\"Speech recognition is not supported in this browser. Please use Chrome, Edge, or Safari.\");\n        }\n    }, [\n        listening,\n        browserSupportsSpeechRecognition\n    ]);\n    const handleTextSubmit = (e)=>{\n        e.preventDefault();\n        if (textInput.trim()) {\n            handleQuery(textInput);\n            setTextInput(\"\");\n        }\n    };\n    // Auto-scroll to bottom of chat when conversation updates\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        if (chatContainerRef.current) {\n            chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;\n        }\n    }, [\n        conversation\n    ]);\n    if (!speechInitialized) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"p-4 text-center\",\n            children: \"Initializing speech recognition...\"\n        }, void 0, false, {\n            fileName: \"/Users/santoshbaral/Documents/REVX/helpdex/spu-ai/app/page.client.tsx\",\n            lineNumber: 469,\n            columnNumber: 12\n        }, this);\n    }\n    if (!browserSupportsSpeechRecognition) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"p-4 bg-yellow-50 border border-yellow-200 rounded-lg\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                className: \"text-yellow-700\",\n                children: \"Speech recognition is not supported in this browser. Please try Chrome, Edge, or Safari.\"\n            }, void 0, false, {\n                fileName: \"/Users/santoshbaral/Documents/REVX/helpdex/spu-ai/app/page.client.tsx\",\n                lineNumber: 475,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/santoshbaral/Documents/REVX/helpdex/spu-ai/app/page.client.tsx\",\n            lineNumber: 474,\n            columnNumber: 7\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"min-h-screen bg-gray-100\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_app_components_SpeechSetup__WEBPACK_IMPORTED_MODULE_5__.SpeechSetup, {}, void 0, false, {\n                fileName: \"/Users/santoshbaral/Documents/REVX/helpdex/spu-ai/app/page.client.tsx\",\n                lineNumber: 485,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"container mx-auto px-4 py-8\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"max-w-4xl mx-auto\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                            className: \"text-3xl font-bold text-center mb-8\",\n                            children: \"RevX AI Assistant\"\n                        }, void 0, false, {\n                            fileName: \"/Users/santoshbaral/Documents/REVX/helpdex/spu-ai/app/page.client.tsx\",\n                            lineNumber: 488,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            ref: chatContainerRef,\n                            className: \"bg-white rounded-lg shadow-lg p-6 mb-6 h-[60vh] overflow-y-auto\",\n                            children: conversation.map((message, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"mb-4 \".concat(message.type === \"user\" ? \"text-right\" : \"text-left\"),\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"inline-block p-3 rounded-lg \".concat(message.type === \"user\" ? \"bg-blue-500 text-white\" : \"bg-gray-200 text-gray-800\"),\n                                        children: message.content\n                                    }, void 0, false, {\n                                        fileName: \"/Users/santoshbaral/Documents/REVX/helpdex/spu-ai/app/page.client.tsx\",\n                                        lineNumber: 502,\n                                        columnNumber: 17\n                                    }, this)\n                                }, index, false, {\n                                    fileName: \"/Users/santoshbaral/Documents/REVX/helpdex/spu-ai/app/page.client.tsx\",\n                                    lineNumber: 496,\n                                    columnNumber: 15\n                                }, this))\n                        }, void 0, false, {\n                            fileName: \"/Users/santoshbaral/Documents/REVX/helpdex/spu-ai/app/page.client.tsx\",\n                            lineNumber: 491,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"relative\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex items-center\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                            ref: inputRef,\n                                            type: \"text\",\n                                            value: textInput,\n                                            onChange: (e)=>setTextInput(e.target.value),\n                                            onKeyPress: (e)=>{\n                                                if (e.key === \"Enter\" && textInput.trim()) {\n                                                    handleQuery(textInput.trim());\n                                                    setTextInput(\"\");\n                                                }\n                                            },\n                                            placeholder: \"Type your message or click the microphone to speak...\",\n                                            className: \"flex-1 p-4 border border-gray-300 rounded-l-lg focus:outline-none focus:ring-2 focus:ring-blue-500\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/santoshbaral/Documents/REVX/helpdex/spu-ai/app/page.client.tsx\",\n                                            lineNumber: 518,\n                                            columnNumber: 15\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            onClick: toggleListening,\n                                            disabled: !browserSupportsSpeechRecognition,\n                                            className: \"p-4 rounded-r-lg \".concat(isListening ? \"bg-red-500 hover:bg-red-600\" : \"bg-blue-500 hover:bg-blue-600\", \" text-white transition-colors duration-200\"),\n                                            title: isListening ? \"Stop Recording\" : \"Start Recording\",\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                                                xmlns: \"http://www.w3.org/2000/svg\",\n                                                className: \"h-6 w-6\",\n                                                fill: \"none\",\n                                                viewBox: \"0 0 24 24\",\n                                                stroke: \"currentColor\",\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                                                    strokeLinecap: \"round\",\n                                                    strokeLinejoin: \"round\",\n                                                    strokeWidth: 2,\n                                                    d: \"M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/santoshbaral/Documents/REVX/helpdex/spu-ai/app/page.client.tsx\",\n                                                    lineNumber: 549,\n                                                    columnNumber: 19\n                                                }, this)\n                                            }, void 0, false, {\n                                                fileName: \"/Users/santoshbaral/Documents/REVX/helpdex/spu-ai/app/page.client.tsx\",\n                                                lineNumber: 542,\n                                                columnNumber: 17\n                                            }, this)\n                                        }, void 0, false, {\n                                            fileName: \"/Users/santoshbaral/Documents/REVX/helpdex/spu-ai/app/page.client.tsx\",\n                                            lineNumber: 532,\n                                            columnNumber: 15\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/santoshbaral/Documents/REVX/helpdex/spu-ai/app/page.client.tsx\",\n                                    lineNumber: 517,\n                                    columnNumber: 13\n                                }, this),\n                                microphoneError && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"text-red-500 text-sm mt-2\",\n                                    children: microphoneError\n                                }, void 0, false, {\n                                    fileName: \"/Users/santoshbaral/Documents/REVX/helpdex/spu-ai/app/page.client.tsx\",\n                                    lineNumber: 559,\n                                    columnNumber: 15\n                                }, this),\n                                !browserSupportsSpeechRecognition && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"text-yellow-500 text-sm mt-2\",\n                                    children: \"Speech recognition is not supported in your browser. Please use Chrome, Edge, or Safari.\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/santoshbaral/Documents/REVX/helpdex/spu-ai/app/page.client.tsx\",\n                                    lineNumber: 562,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/santoshbaral/Documents/REVX/helpdex/spu-ai/app/page.client.tsx\",\n                            lineNumber: 516,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/santoshbaral/Documents/REVX/helpdex/spu-ai/app/page.client.tsx\",\n                    lineNumber: 487,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/santoshbaral/Documents/REVX/helpdex/spu-ai/app/page.client.tsx\",\n                lineNumber: 486,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/santoshbaral/Documents/REVX/helpdex/spu-ai/app/page.client.tsx\",\n        lineNumber: 484,\n        columnNumber: 5\n    }, this);\n}\n_s(ClientHome, \"cvy3CZMizrjfGOwHjsjdgrtriws=\", false, function() {\n    return [\n        react_use_clipboard__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n        react_speech_recognition__WEBPACK_IMPORTED_MODULE_3__.useSpeechRecognition\n    ];\n});\n_c = ClientHome;\nvar _c;\n$RefreshReg$(_c, \"ClientHome\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTs7O0tBL1hGRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvcGFnZS5jbGllbnQudHN4P2NjYzIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgJ3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZSc7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFNwZWVjaFJlY29nbml0aW9uLCB7IHVzZVNwZWVjaFJlY29nbml0aW9uIH0gZnJvbSAncmVhY3Qtc3BlZWNoLXJlY29nbml0aW9uJztcbmltcG9ydCB1c2VDbGlwYm9hcmQgZnJvbSAncmVhY3QtdXNlLWNsaXBib2FyZCc7XG5pbXBvcnQgeyBTcGVlY2hTZXR1cCB9IGZyb20gJy4uL2FwcC9jb21wb25lbnRzL1NwZWVjaFNldHVwJztcblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICB3ZWJraXRTcGVlY2hSZWNvZ25pdGlvbjogYW55O1xuICAgIFNwZWVjaFJlY29nbml0aW9uOiBhbnk7XG4gICAgcmVnZW5lcmF0b3JSdW50aW1lOiBhbnk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2xpZW50SG9tZSgpIHtcbiAgY29uc3QgW3NwZWVjaEluaXRpYWxpemVkLCBzZXRTcGVlY2hJbml0aWFsaXplZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc0xpc3RlbmluZywgc2V0SXNMaXN0ZW5pbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbcmVzcG9uc2UsIHNldFJlc3BvbnNlXSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW3RleHRJbnB1dCwgc2V0VGV4dElucHV0XSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW2NvbnZlcnNhdGlvbiwgc2V0Q29udmVyc2F0aW9uXSA9IHVzZVN0YXRlPHt0eXBlOiAndXNlcicgfCAnYXNzaXN0YW50JywgY29udGVudDogc3RyaW5nfVtdPihbXSk7XG4gIGNvbnN0IFt0ZXh0VG9Db3B5LCBzZXRUZXh0VG9Db3B5XSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW2lzQ29waWVkLCBzZXRDb3B5VG9DbGlwYm9hcmRdID0gdXNlQ2xpcGJvYXJkKHRleHRUb0NvcHksIHtcbiAgICBzdWNjZXNzRHVyYXRpb246IDIwMDAsXG4gIH0pO1xuICBjb25zdCBbbWljcm9waG9uZUVycm9yLCBzZXRNaWNyb3Bob25lRXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGlucHV0UmVmID0gdXNlUmVmPEhUTUxJbnB1dEVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBjaGF0Q29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy5yZWdlbmVyYXRvclJ1bnRpbWUpIHtcbiAgICAgICAgd2luZG93LnJlZ2VuZXJhdG9yUnVudGltZSA9IHJlcXVpcmUoJ3JlZ2VuZXJhdG9yLXJ1bnRpbWUnKTtcbiAgICAgIH1cbiAgICAgIHNldFNwZWVjaEluaXRpYWxpemVkKHRydWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSByZWdlbmVyYXRvci1ydW50aW1lOicsIGVycm9yKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBSZXZYIGJ1c2luZXNzIGluZm9ybWF0aW9uIGRhdGFiYXNlXG4gIGNvbnN0IGJ1c2luZXNzSW5mbyA9IHtcbiAgICBuYW1lOiBcIlJldlhcIixcbiAgICBkZXNjcmlwdGlvbjogXCJSZXZYIGlzIGEgY29tcHJlaGVuc2l2ZSB0ZWNobm9sb2d5IGFuZCBkaWdpdGFsIHNvbHV0aW9ucyBwcm92aWRlciBzcGVjaWFsaXppbmcgaW4gc29mdHdhcmUgZGV2ZWxvcG1lbnQsIGRpZ2l0YWwgbWFya2V0aW5nLCBkYXRhIHNjaWVuY2UsIEFJIHNvbHV0aW9ucywgYW5kIE9UQSAoT25saW5lIFRyYXZlbCBBZ2VuY3kpIHJldmVudWUgb3B0aW1pemF0aW9uLiBXZSBoZWxwIGJ1c2luZXNzZXMgbWF4aW1pemUgdGhlaXIgcmV2ZW51ZSB0aHJvdWdoIHN0cmF0ZWdpYyBwYXJ0bmVyc2hpcHMgd2l0aCBtYWpvciBPVEFzIGFuZCBlbmhhbmNlZCBkaWdpdGFsIHByZXNlbmNlLlwiLFxuICAgIHNlcnZpY2VzOiBbXG4gICAgICBcIlNvZnR3YXJlIERldmVsb3BtZW50XCIsXG4gICAgICBcIlNFT1wiLFxuICAgICAgXCJEaWdpdGFsIE1hcmtldGluZ1wiLFxuICAgICAgXCJPVEEgU29sdXRpb25zXCIsXG4gICAgICBcIlJldmVudWUgT3B0aW1pemF0aW9uXCIsXG4gICAgICBcIkJyYW5kIEVuaGFuY2VtZW50XCIsXG4gICAgICBcIk1ldGEgU2VhcmNoIE9wdGltaXphdGlvblwiXG4gICAgXSxcbiAgICBzcGVjaWFsaXphdGlvbjogXCJSZXZYIHNwZWNpYWxpemVzIGluIGNvbXByZWhlbnNpdmUgZGlnaXRhbCBzb2x1dGlvbnMgd2l0aCBhIHN0cm9uZyBmb2N1cyBvbiBPVEEgcGFydG5lcnNoaXBzIGFuZCByZXZlbnVlIG9wdGltaXphdGlvbi4gV2UgaGVscCBidXNpbmVzc2VzIG1heGltaXplIHRoZWlyIHByZXNlbmNlIGFjcm9zcyBtYWpvciB0cmF2ZWwgcGxhdGZvcm1zIHdoaWxlIHN0cmVuZ3RoZW5pbmcgdGhlaXIgYnJhbmQgaWRlbnRpdHkuXCIsXG4gICAgZXhwZXJpZW5jZTogXCJXaXRoIHllYXJzIG9mIGV4cGVyaWVuY2UgaW4gdGhlIHRyYXZlbCBhbmQgaG9zcGl0YWxpdHkgaW5kdXN0cnksIFJldlggaGFzIHN1Y2Nlc3NmdWxseSBoZWxwZWQgbnVtZXJvdXMgYnVzaW5lc3NlcyBvcHRpbWl6ZSB0aGVpciBPVEEgcHJlc2VuY2UgYW5kIGluY3JlYXNlIHJldmVudWUgdGhyb3VnaCBzdHJhdGVnaWMgcGFydG5lcnNoaXBzIGFuZCBkaWdpdGFsIG9wdGltaXphdGlvbi5cIixcbiAgICBleHBlcnRpc2U6IHtcbiAgICAgIHNvZnR3YXJlRGV2ZWxvcG1lbnQ6IHtcbiAgICAgICAgc2VydmljZXM6IFtcbiAgICAgICAgICBcIkN1c3RvbSBTb2Z0d2FyZSBTb2x1dGlvbnNcIixcbiAgICAgICAgICBcIldlYiBBcHBsaWNhdGlvbnNcIixcbiAgICAgICAgICBcIk1vYmlsZSBBcHBzXCIsXG4gICAgICAgICAgXCJBUEkgRGV2ZWxvcG1lbnRcIixcbiAgICAgICAgICBcIkNsb3VkIFNvbHV0aW9uc1wiLFxuICAgICAgICAgIFwiTGVnYWN5IFN5c3RlbSBNb2Rlcm5pemF0aW9uXCJcbiAgICAgICAgXSxcbiAgICAgICAgYmVuZWZpdHM6IFtcbiAgICAgICAgICBcIlNjYWxhYmxlIGFuZCBtYWludGFpbmFibGUgc29sdXRpb25zXCIsXG4gICAgICAgICAgXCJJbXByb3ZlZCBvcGVyYXRpb25hbCBlZmZpY2llbmN5XCIsXG4gICAgICAgICAgXCJFbmhhbmNlZCB1c2VyIGV4cGVyaWVuY2VcIixcbiAgICAgICAgICBcIkNvc3QtZWZmZWN0aXZlIGRldmVsb3BtZW50XCJcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIGRpZ2l0YWxNYXJrZXRpbmc6IHtcbiAgICAgICAgc2VydmljZXM6IFtcbiAgICAgICAgICBcIlNlYXJjaCBFbmdpbmUgT3B0aW1pemF0aW9uIChTRU8pXCIsXG4gICAgICAgICAgXCJTb2NpYWwgTWVkaWEgTWFya2V0aW5nXCIsXG4gICAgICAgICAgXCJDb250ZW50IE1hcmtldGluZ1wiLFxuICAgICAgICAgIFwiRW1haWwgTWFya2V0aW5nXCIsXG4gICAgICAgICAgXCJQUEMgQWR2ZXJ0aXNpbmdcIixcbiAgICAgICAgICBcIkJyYW5kIFN0cmF0ZWd5XCJcbiAgICAgICAgXSxcbiAgICAgICAgYmVuZWZpdHM6IFtcbiAgICAgICAgICBcIkluY3JlYXNlZCBvbmxpbmUgdmlzaWJpbGl0eVwiLFxuICAgICAgICAgIFwiSGlnaGVyIGNvbnZlcnNpb24gcmF0ZXNcIixcbiAgICAgICAgICBcIkJldHRlciBjdXN0b21lciBlbmdhZ2VtZW50XCIsXG4gICAgICAgICAgXCJJbXByb3ZlZCBicmFuZCByZWNvZ25pdGlvblwiXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBkYXRhU2NpZW5jZToge1xuICAgICAgICBzZXJ2aWNlczogW1xuICAgICAgICAgIFwiRGF0YSBBbmFseXRpY3NcIixcbiAgICAgICAgICBcIkJ1c2luZXNzIEludGVsbGlnZW5jZVwiLFxuICAgICAgICAgIFwiUHJlZGljdGl2ZSBNb2RlbGluZ1wiLFxuICAgICAgICAgIFwiUGVyZm9ybWFuY2UgQW5hbHl0aWNzXCIsXG4gICAgICAgICAgXCJNYXJrZXQgUmVzZWFyY2hcIixcbiAgICAgICAgICBcIkNvbXBldGl0aXZlIEFuYWx5c2lzXCJcbiAgICAgICAgXSxcbiAgICAgICAgYmVuZWZpdHM6IFtcbiAgICAgICAgICBcIkRhdGEtZHJpdmVuIGRlY2lzaW9uIG1ha2luZ1wiLFxuICAgICAgICAgIFwiSW1wcm92ZWQgYnVzaW5lc3MgaW5zaWdodHNcIixcbiAgICAgICAgICBcIkJldHRlciBtYXJrZXQgdW5kZXJzdGFuZGluZ1wiLFxuICAgICAgICAgIFwiRW5oYW5jZWQgcGVyZm9ybWFuY2UgdHJhY2tpbmdcIlxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgYWlTb2x1dGlvbnM6IHtcbiAgICAgICAgc2VydmljZXM6IFtcbiAgICAgICAgICBcIkFJIEludGVncmF0aW9uXCIsXG4gICAgICAgICAgXCJNYWNoaW5lIExlYXJuaW5nXCIsXG4gICAgICAgICAgXCJOYXR1cmFsIExhbmd1YWdlIFByb2Nlc3NpbmdcIixcbiAgICAgICAgICBcIkNvbXB1dGVyIFZpc2lvblwiLFxuICAgICAgICAgIFwiUHJlZGljdGl2ZSBBbmFseXRpY3NcIixcbiAgICAgICAgICBcIkF1dG9tYXRpb24gU29sdXRpb25zXCJcbiAgICAgICAgXSxcbiAgICAgICAgYmVuZWZpdHM6IFtcbiAgICAgICAgICBcIkF1dG9tYXRlZCBwcm9jZXNzZXNcIixcbiAgICAgICAgICBcIkVuaGFuY2VkIGVmZmljaWVuY3lcIixcbiAgICAgICAgICBcIkltcHJvdmVkIGFjY3VyYWN5XCIsXG4gICAgICAgICAgXCJDb3N0IHJlZHVjdGlvblwiXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBvdGFTb2x1dGlvbnM6IHtcbiAgICAgICAgc2VydmljZXM6IFtcbiAgICAgICAgICBcIk9UQSBDaGFubmVsIE1hbmFnZW1lbnRcIixcbiAgICAgICAgICBcIlJldmVudWUgT3B0aW1pemF0aW9uXCIsXG4gICAgICAgICAgXCJSYXRlIFBhcml0eSBNYW5hZ2VtZW50XCIsXG4gICAgICAgICAgXCJJbnZlbnRvcnkgRGlzdHJpYnV0aW9uXCIsXG4gICAgICAgICAgXCJCb29raW5nIEVuZ2luZSBJbnRlZ3JhdGlvblwiLFxuICAgICAgICAgIFwiUGVyZm9ybWFuY2UgQW5hbHl0aWNzXCJcbiAgICAgICAgXSxcbiAgICAgICAgYmVuZWZpdHM6IFtcbiAgICAgICAgICBcIk1heGltaXplZCBPVEEgcmV2ZW51ZVwiLFxuICAgICAgICAgIFwiT3B0aW1pemVkIHByaWNpbmcgc3RyYXRlZ3lcIixcbiAgICAgICAgICBcIkVuaGFuY2VkIG1hcmtldCBwcmVzZW5jZVwiLFxuICAgICAgICAgIFwiSW1wcm92ZWQgYm9va2luZyBjb252ZXJzaW9uXCJcbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0sXG4gICAgY2FzZVN0dWRpZXM6IFtcbiAgICAgIHtcbiAgICAgICAgdGl0bGU6IFwiT1RBIFJldmVudWUgT3B0aW1pemF0aW9uXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlN1Y2Nlc3NmdWxseSBoZWxwZWQgYSBob3RlbCBjaGFpbiBpbmNyZWFzZSB0aGVpciBPVEEgcmV2ZW51ZSBieSA0MCUgdGhyb3VnaCBzdHJhdGVnaWMgcGFydG5lcnNoaXBzIHdpdGggbWFqb3IgcGxhdGZvcm1zIGxpa2UgQm9va2luZy5jb20sIEFnb2RhLCBhbmQgRXhwZWRpYS5cIixcbiAgICAgICAgcmVzdWx0czogXCI0MCUgcmV2ZW51ZSBpbmNyZWFzZSwgaW1wcm92ZWQgbWFya2V0IHByZXNlbmNlLCBlbmhhbmNlZCBicmFuZCB2aXNpYmlsaXR5XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRpdGxlOiBcIkRpZ2l0YWwgVHJhbnNmb3JtYXRpb25cIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiSW1wbGVtZW50ZWQgY29tcHJlaGVuc2l2ZSBkaWdpdGFsIHNvbHV0aW9ucyBmb3IgYSBob3NwaXRhbGl0eSBncm91cCwgaW5jbHVkaW5nIE9UQSBpbnRlZ3JhdGlvbiBhbmQgcmV2ZW51ZSBtYW5hZ2VtZW50IHN5c3RlbXMuXCIsXG4gICAgICAgIHJlc3VsdHM6IFwiMjUlIGluY3JlYXNlIGluIGRpcmVjdCBib29raW5ncywgMzUlIGltcHJvdmVtZW50IGluIE9UQSBwZXJmb3JtYW5jZVwiXG4gICAgICB9XG4gICAgXSxcbiAgICBjb250YWN0OiB7XG4gICAgICBlbWFpbDogXCJpbmZvQHJldngucHJvXCIsXG4gICAgICBwaG9uZTogXCIrMSA1MTA3MzQwNzc0XCIsXG4gICAgICBhZGRyZXNzOiBcIlJpY2htb25kIENhbGlmb3JuaWEsIFVTQVwiLFxuICAgICAgd2Vic2l0ZTogXCJodHRwczovL3JldngucHJvXCIsXG4gICAgICBuZXBhbE9mZmljZToge1xuICAgICAgICBhZGRyZXNzOiBcIlNoZXJwYSBNYWxsLCBEdXJiYXJtYXJnLCBLYXRobWFuZHUsIE5lcGFsXCIsXG4gICAgICAgIHBob25lOiBcIis5Nzc5ODIwMTUxMzQzXCIsXG4gICAgICAgIG1vYmlsZTogXCIrOTc3OTg1NjAzMTUxM1wiLFxuICAgICAgICB3aGF0c2FwcDogXCIrOTc3OTg1MDMxNTEzXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGJsb2dzOiBbXG4gICAgICBcIk9UQSBSZXZlbnVlIE9wdGltaXphdGlvbiBTdHJhdGVnaWVzXCIsXG4gICAgICBcIk1heGltaXppbmcgWW91ciBQcmVzZW5jZSBvbiBCb29raW5nLmNvbVwiLFxuICAgICAgXCJFZmZlY3RpdmUgUmF0ZSBQYXJpdHkgTWFuYWdlbWVudFwiLFxuICAgICAgXCJEaWdpdGFsIE1hcmtldGluZyBmb3IgSG9zcGl0YWxpdHlcIixcbiAgICAgIFwiQUkgaW4gVHJhdmVsIEluZHVzdHJ5XCIsXG4gICAgICBcIk1ldGEgU2VhcmNoIE9wdGltaXphdGlvblwiXG4gICAgXSxcbiAgICBvdGFQYXJ0bmVyczogW1xuICAgICAgXCJCb29raW5nLmNvbVwiLFxuICAgICAgXCJBZ29kYVwiLFxuICAgICAgXCJDdHJpcFwiLFxuICAgICAgXCJUcmlwLmNvbVwiLFxuICAgICAgXCJNYWtlTXlUcmlwXCIsXG4gICAgICBcIkV4cGVkaWFcIlxuICAgIF0sXG4gICAgbWV0YVNlYXJjaFBsYXRmb3JtczogW1xuICAgICAgXCJHb29nbGUgSG90ZWwgQWRzXCIsXG4gICAgICBcIlRyaXBBZHZpc29yXCIsXG4gICAgICBcIktheWFrXCIsXG4gICAgICBcIlNreXNjYW5uZXJcIixcbiAgICAgIFwiVHJpdmFnb1wiXG4gICAgXVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVF1ZXJ5ID0gdXNlQ2FsbGJhY2soYXN5bmMgKHF1ZXJ5OiBzdHJpbmcpID0+IHtcbiAgICBsZXQgcmVzcG9uc2UgPSBcIlwiO1xuICAgIGNvbnN0IGxvd2VyY2FzZVF1ZXJ5ID0gcXVlcnkudG9Mb3dlckNhc2UoKTtcbiAgICBcbiAgICAvLyBBZGQgdXNlciBtZXNzYWdlIHRvIGNvbnZlcnNhdGlvblxuICAgIHNldENvbnZlcnNhdGlvbihwcmV2ID0+IFsuLi5wcmV2LCB7dHlwZTogJ3VzZXInLCBjb250ZW50OiBxdWVyeX1dKTtcbiAgICBcbiAgICAvLyBFbmhhbmNlZCBncmVldGluZ3MgYW5kIGNvbW1vbiBwaHJhc2VzIGhhbmRsaW5nIHdpdGggbW9yZSB2YXJpYXRpb25zXG4gICAgaWYgKGxvd2VyY2FzZVF1ZXJ5Lm1hdGNoKC8oaGVsbG98aGl8aGV5fGdyZWV0aW5nc3xnb29kXFxzKyhtb3JuaW5nfGFmdGVybm9vbnxldmVuaW5nfGRheSl8aG93ZHl8eW98c3VwKS9pKSkge1xuICAgICAgY29uc3QgdGltZU9mRGF5ID0gbmV3IERhdGUoKS5nZXRIb3VycygpO1xuICAgICAgbGV0IGdyZWV0aW5nID0gXCJIZWxsb1wiO1xuICAgICAgaWYgKHRpbWVPZkRheSA8IDEyKSBncmVldGluZyA9IFwiR29vZCBtb3JuaW5nXCI7XG4gICAgICBlbHNlIGlmICh0aW1lT2ZEYXkgPCAxNykgZ3JlZXRpbmcgPSBcIkdvb2QgYWZ0ZXJub29uXCI7XG4gICAgICBlbHNlIGdyZWV0aW5nID0gXCJHb29kIGV2ZW5pbmdcIjtcbiAgICAgIFxuICAgICAgcmVzcG9uc2UgPSBgJHtncmVldGluZ30hIEknbSBTcHUsIFJldlgncyBBSSBhc3Npc3RhbnQuIEhvdyBjYW4gSSBoZWxwIHlvdSB0b2RheT8gRmVlbCBmcmVlIHRvIGFzayBhYm91dCBvdXIgc2VydmljZXMsIHN1Y2Nlc3Mgc3Rvcmllcywgb3IgaG93IHRvIGdldCBpbiB0b3VjaCB3aXRoIHVzLmA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxvd2VyY2FzZVF1ZXJ5Lm1hdGNoKC8oaG93XFxzK2FyZVxccyt5b3V8aG93J3JlXFxzK3lvdXxob3dcXHMreW91XFxzK2RvaW5nfGhvdydzXFxzK2l0XFxzK2dvaW5nfHdoYXQnc1xccyt1cHx3aGF0XFxzK2lzXFxzK3VwfHdoYXRcXHMrYXJlXFxzK3lvdVxccyt1cFxccyt0bykvaSkpIHtcbiAgICAgIHJlc3BvbnNlID0gXCJJJ20gZG9pbmcgZ3JlYXQsIHRoYW5rIHlvdSBmb3IgYXNraW5nISBJJ20gaGVyZSB0byBoZWxwIHlvdSBsZWFybiBtb3JlIGFib3V0IFJldlguIFdoYXQgd291bGQgeW91IGxpa2UgdG8ga25vdz9cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAobG93ZXJjYXNlUXVlcnkubWF0Y2goLyh0aGFua1xccyt5b3V8dGhhbmtzfGFwcHJlY2lhdGVcXHMraXR8dGhhbmtcXHMreW91XFxzK3NvXFxzK211Y2h8dGhhbmtzXFxzK2FcXHMrbG90fGdyYXRlZnVsKS9pKSkge1xuICAgICAgcmVzcG9uc2UgPSBcIllvdSdyZSB3ZWxjb21lISBJcyB0aGVyZSBhbnl0aGluZyBlbHNlIHlvdSdkIGxpa2UgdG8ga25vdyBhYm91dCBSZXZYP1wiO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb3dlcmNhc2VRdWVyeS5tYXRjaCgvKGJ5ZXxnb29kYnllfHNlZVxccyt5b3V8dGFsa1xccyt0b1xccyt5b3VcXHMrbGF0ZXJ8aGF2ZVxccythXFxzK2dvb2RcXHMrZGF5fHRha2VcXHMrY2FyZSkvaSkpIHtcbiAgICAgIHJlc3BvbnNlID0gXCJUaGFuayB5b3UgZm9yIHlvdXIgaW50ZXJlc3QgaW4gUmV2WCEgSWYgeW91IG5lZWQgYW55IGZ1cnRoZXIgYXNzaXN0YW5jZSwgZG9uJ3QgaGVzaXRhdGUgdG8gcmVhY2ggb3V0LiBIYXZlIGEgZ3JlYXQgZGF5IVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb3dlcmNhc2VRdWVyeS5tYXRjaCgvKHdob1xccytpc1xccytyZXZ4fGFib3V0XFxzK3Jldnh8d2hhdFxccytpc1xccytyZXZ4fHRlbGxcXHMrbWVcXHMrYWJvdXR8d2hhdFxccytkb2VzXFxzK3JldnhcXHMrZG98cmV2eFxccytjb21wYW55fHJldnhcXHMrc2VydmljZXN8cmV2eFxccytkZXNjcmlwdGlvbikvaSkpIHtcbiAgICAgIHJlc3BvbnNlID0gYnVzaW5lc3NJbmZvLmRlc2NyaXB0aW9uO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb3dlcmNhc2VRdWVyeS5tYXRjaCgvKHNlcnZpY2VzfHdoYXRcXHMrZG9cXHMreW91XFxzK29mZmVyfG9mZmVyfHByb3ZpZGV8d2hhdFxccytjYW5cXHMreW91XFxzK2RvfHdoYXRcXHMrYXJlXFxzK3lvdXJcXHMrc2VydmljZXN8d2hhdFxccytzZXJ2aWNlc1xccytkb1xccyt5b3VcXHMrcHJvdmlkZSkvaSkpIHtcbiAgICAgIHJlc3BvbnNlID0gYFJldlggb2ZmZXJzIGEgY29tcHJlaGVuc2l2ZSBzdWl0ZSBvZiBzZXJ2aWNlcyBpbmNsdWRpbmc6ICR7YnVzaW5lc3NJbmZvLnNlcnZpY2VzLmpvaW4oXCIsIFwiKX0uYDtcbiAgICB9XG4gICAgZWxzZSBpZiAobG93ZXJjYXNlUXVlcnkubWF0Y2goLyhzcGVjaWFsaXphdGlvbnxzcGVjaWFsaXplfGluZHVzdHJ5fHdoYXRcXHMrZG9cXHMreW91XFxzK3NwZWNpYWxpemVcXHMraW58d2hhdCdzXFxzK3lvdXJcXHMrc3BlY2lhbHR5fHdoYXRcXHMraXNcXHMreW91clxccytleHBlcnRpc2UpL2kpKSB7XG4gICAgICByZXNwb25zZSA9IGBSZXZYIHNwZWNpYWxpemVzIGluIGVuaGFuY2luZyBkaWdpdGFsIHByZXNlbmNlIGFuZCByZXZlbnVlIG9mIGJ1c2luZXNzZXMsIHBhcnRpY3VsYXJseSBpbiB0aGUgJHtidXNpbmVzc0luZm8uc3BlY2lhbGl6YXRpb259LmA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxvd2VyY2FzZVF1ZXJ5Lm1hdGNoKC8oZXhwZXJpZW5jZXxob3dcXHMrbG9uZ3x5ZWFyc1xccytvZlxccytleHBlcmllbmNlfGhvd1xccyttYW55XFxzK3llYXJzfGhvd1xccytsb25nXFxzK2hhdmVcXHMreW91XFxzK2JlZW4pL2kpKSB7XG4gICAgICByZXNwb25zZSA9IGBSZXZYIGhhcyAke2J1c2luZXNzSW5mby5leHBlcmllbmNlfSBvZiBleHBlcmllbmNlIGluIHRoZSBkaWdpdGFsIGNvbnN1bHRpbmcgaW5kdXN0cnkuYDtcbiAgICB9XG4gICAgZWxzZSBpZiAobG93ZXJjYXNlUXVlcnkubWF0Y2goLyhjYXNlXFxzK3N0dWR8c3VjY2Vzc1xccytzdG9yfGNsaWVudFxccytzdWNjZXNzfHRlc3RpbW9uaWFsfHBvcnRmb2xpb3xwcm9qZWN0c3x3b3JrXFxzK2V4YW1wbGVzfHByZXZpb3VzXFxzK3dvcmspL2kpKSB7XG4gICAgICBjb25zdCBjYXNlU3R1ZGllc1RleHQgPSBidXNpbmVzc0luZm8uY2FzZVN0dWRpZXMubWFwKGNzID0+IFxuICAgICAgICBgJHtjcy50aXRsZX06ICR7Y3MuZGVzY3JpcHRpb259LiBSZXN1bHRzOiAke2NzLnJlc3VsdHN9LmBcbiAgICAgICkuam9pbihcIlxcblxcblwiKTtcbiAgICAgIHJlc3BvbnNlID0gYEhlcmUgYXJlIHNvbWUgb2YgUmV2WCdzIHN1Y2Nlc3Mgc3RvcmllczpcXG5cXG4ke2Nhc2VTdHVkaWVzVGV4dH1gO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb3dlcmNhc2VRdWVyeS5tYXRjaCgvKGNvbnRhY3R8cmVhY2h8Z2V0XFxzK2luXFxzK3RvdWNofGNhbGx8cGhvbmV8ZW1haWx8d2hlcmVcXHMrYXJlXFxzK3lvdXxob3dcXHMrdG9cXHMrY29udGFjdHxjb250YWN0XFxzK2luZm9ybWF0aW9uKS9pKSkge1xuICAgICAgcmVzcG9uc2UgPSBgWW91IGNhbiBjb250YWN0IFJldlggYXQ6XFxuXFxuSGVhZHF1YXJ0ZXJzOlxcbkVtYWlsOiAke2J1c2luZXNzSW5mby5jb250YWN0LmVtYWlsfVxcblBob25lOiAke2J1c2luZXNzSW5mby5jb250YWN0LnBob25lfVxcbkFkZHJlc3M6ICR7YnVzaW5lc3NJbmZvLmNvbnRhY3QuYWRkcmVzc31cXG5cXG5OZXBhbCBPZmZpY2U6XFxuUGhvbmU6ICR7YnVzaW5lc3NJbmZvLmNvbnRhY3QubmVwYWxPZmZpY2UucGhvbmV9XFxuTW9iaWxlOiAke2J1c2luZXNzSW5mby5jb250YWN0Lm5lcGFsT2ZmaWNlLm1vYmlsZX1cXG5XaGF0c0FwcDogJHtidXNpbmVzc0luZm8uY29udGFjdC5uZXBhbE9mZmljZS53aGF0c2FwcH1cXG5BZGRyZXNzOiAke2J1c2luZXNzSW5mby5jb250YWN0Lm5lcGFsT2ZmaWNlLmFkZHJlc3N9YDtcbiAgICB9XG4gICAgZWxzZSBpZiAobG93ZXJjYXNlUXVlcnkubWF0Y2goLyh1c2F8dXNcXHMrb2ZmaWNlfHVuaXRlZFxccytzdGF0ZXN8Y2FsaWZvcm5pYXxyaWNobW9uZCkvaSkpIHtcbiAgICAgIHJlc3BvbnNlID0gYFJldlgncyBvZmZpY2UgaXMgbG9jYXRlZCBpbiAke2J1c2luZXNzSW5mby5jb250YWN0LmFkZHJlc3N9LiBZb3UgY2FuIHJlYWNoIHRoZW0gYXQgJHtidXNpbmVzc0luZm8uY29udGFjdC5waG9uZX0uYDtcbiAgICB9XG4gICAgZWxzZSBpZiAobG93ZXJjYXNlUXVlcnkubWF0Y2goLyhibG9nfGluc2lnaHR8YXJ0aWNsZXx0aG91Z2h0XFxzK2xlYWRlcnNoaXB8cmVzb3VyY2VzfGNvbnRlbnR8cHVibGljYXRpb25zKS9pKSkge1xuICAgICAgcmVzcG9uc2UgPSBgUmV2WCBzaGFyZXMgaW5zaWdodHMgdGhyb3VnaCB0aGVpciBibG9nLCBjb3ZlcmluZyB0b3BpY3Mgc3VjaCBhczpcXG5cXG4tICR7YnVzaW5lc3NJbmZvLmJsb2dzLmpvaW4oJ1xcbi0gJyl9YDtcbiAgICB9XG4gICAgZWxzZSBpZiAobG93ZXJjYXNlUXVlcnkubWF0Y2goLyhyZXZlbnVlXFxzK21heGltaXphdGlvbnxpbmNyZWFzZVxccytyZXZlbnVlfGJvb3N0XFxzK3JldmVudWV8aW1wcm92ZVxccytyZXZlbnVlfHJldmVudWVcXHMrb3B0aW1pemF0aW9ufHJldmVudWVcXHMrbWFuYWdlbWVudCkvaSkpIHtcbiAgICAgIHJlc3BvbnNlID0gXCJSZXZYJ3MgcmV2ZW51ZSBtYXhpbWl6YXRpb24gc3RyYXRlZ2llcyBmb2N1cyBvbiBvcHRpbWl6aW5nIHByaWNpbmcsIGltcHJvdmluZyBvcGVyYXRpb25hbCBlZmZpY2llbmN5LCBhbmQgZW5oYW5jaW5nIGN1c3RvbWVyIGV4cGVyaWVuY2UuIFdlIGhlbHAgYnVzaW5lc3NlcyBpZGVudGlmeSBuZXcgcmV2ZW51ZSBzdHJlYW1zLCByZWR1Y2UgY29zdHMsIGFuZCBpbXBsZW1lbnQgZGF0YS1kcml2ZW4gZGVjaXNpb24tbWFraW5nIHByb2Nlc3Nlcy5cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAobG93ZXJjYXNlUXVlcnkubWF0Y2goLyh3ZWJzaXRlfHNpdGV8dXJsfHdlYlxccythZGRyZXNzfG9ubGluZVxccytwcmVzZW5jZXx3ZWJcXHMrcHJlc2VuY2UpL2kpKSB7XG4gICAgICByZXNwb25zZSA9IGBZb3UgY2FuIHZpc2l0IFJldlgncyB3ZWJzaXRlIGF0ICR7YnVzaW5lc3NJbmZvLmNvbnRhY3Qud2Vic2l0ZX1gO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb3dlcmNhc2VRdWVyeS5tYXRjaCgvKGRpZ2l0YWxcXHMrbWFya2V0aW5nfG1hcmtldGluZ1xccytzZXJ2aWNlc3xzZW98c29jaWFsXFxzK21lZGlhfG9ubGluZVxccyttYXJrZXRpbmd8ZGlnaXRhbFxccythZHZlcnRpc2luZ3xjb250ZW50XFxzK21hcmtldGluZykvaSkpIHtcbiAgICAgIGNvbnN0IGRtID0gYnVzaW5lc3NJbmZvLmV4cGVydGlzZS5kaWdpdGFsTWFya2V0aW5nO1xuICAgICAgcmVzcG9uc2UgPSBgUmV2WCBvZmZlcnMgY29tcHJlaGVuc2l2ZSBkaWdpdGFsIG1hcmtldGluZyBzZXJ2aWNlcyBpbmNsdWRpbmcgJHtkbS5zZXJ2aWNlcy5qb2luKFwiLCBcIil9LiBUaGVzZSBzZXJ2aWNlcyBoZWxwIGJ1c2luZXNzZXMgYWNoaWV2ZSAke2RtLmJlbmVmaXRzLmpvaW4oXCIsIFwiKX0uYDtcbiAgICB9XG4gICAgZWxzZSBpZiAobG93ZXJjYXNlUXVlcnkubWF0Y2goLyhlY29tbWVyY2V8b25saW5lXFxzK3N0b3JlfGRpZ2l0YWxcXHMrY29tbWVyY2V8b25saW5lXFxzK3JldGFpbHxlLWNvbW1lcmNlfGVsZWN0cm9uaWNcXHMrY29tbWVyY2V8b25saW5lXFxzK3Nob3BwaW5nKS9pKSkge1xuICAgICAgcmVzcG9uc2UgPSBcIlJldlggcHJvdmlkZXMgY29tcHJlaGVuc2l2ZSBlLWNvbW1lcmNlIHNvbHV0aW9ucyBpbmNsdWRpbmcgY3VzdG9tIHBsYXRmb3JtIGRldmVsb3BtZW50LCBwYXltZW50IGludGVncmF0aW9uLCBpbnZlbnRvcnkgbWFuYWdlbWVudCwgYW5kIGN1c3RvbWVyIGFuYWx5dGljcy4gT3VyIHNvbHV0aW9ucyBoZWxwIGJ1c2luZXNzZXMgY3JlYXRlIHN1Y2Nlc3NmdWwgb25saW5lIHN0b3JlcyB3aXRoIGVuaGFuY2VkIHVzZXIgZXhwZXJpZW5jZSBhbmQgaW5jcmVhc2VkIHNhbGVzLlwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb3dlcmNhc2VRdWVyeS5tYXRjaCgvKGRldmVsb3BtZW50fHByb2dyYW1taW5nfGNvZGluZ3xhcHBcXHMrZGV2ZWxvcG1lbnR8d2Vic2l0ZVxccytkZXZlbG9wbWVudHxzb2Z0d2FyZVxccytkZXZlbG9wbWVudHx3ZWJcXHMrZGV2ZWxvcG1lbnR8bW9iaWxlXFxzK2RldmVsb3BtZW50KS9pKSkge1xuICAgICAgY29uc3Qgc2QgPSBidXNpbmVzc0luZm8uZXhwZXJ0aXNlLnNvZnR3YXJlRGV2ZWxvcG1lbnQ7XG4gICAgICByZXNwb25zZSA9IGBSZXZYIHByb3ZpZGVzIGNvbXByZWhlbnNpdmUgZGV2ZWxvcG1lbnQgc2VydmljZXMgaW5jbHVkaW5nICR7c2Quc2VydmljZXMuam9pbihcIiwgXCIpfS4gVGhlc2Ugc29sdXRpb25zIG9mZmVyICR7c2QuYmVuZWZpdHMuam9pbihcIiwgXCIpfS5gO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb3dlcmNhc2VRdWVyeS5tYXRjaCgvKGFpfGFydGlmaWNpYWxcXHMraW50ZWxsaWdlbmNlfG1hY2hpbmVcXHMrbGVhcm5pbmd8ZGVlcFxccytsZWFybmluZ3xzbWFydFxccyt0ZWNobm9sb2d5fGF1dG9tYXRpb24pL2kpKSB7XG4gICAgICByZXNwb25zZSA9IFwiUmV2WCBzcGVjaWFsaXplcyBpbiBBSSBpbnRlZ3JhdGlvbiBhbmQgZGV2ZWxvcG1lbnQsIGhlbHBpbmcgYnVzaW5lc3NlcyBsZXZlcmFnZSBhcnRpZmljaWFsIGludGVsbGlnZW5jZSBmb3IgaW1wcm92ZWQgZWZmaWNpZW5jeSwgY3VzdG9tZXIgZXhwZXJpZW5jZSwgYW5kIGRlY2lzaW9uLW1ha2luZy4gT3VyIEFJIHNvbHV0aW9ucyBpbmNsdWRlIHByZWRpY3RpdmUgYW5hbHl0aWNzLCBhdXRvbWF0ZWQgcHJvY2Vzc2VzLCBhbmQgaW50ZWxsaWdlbnQgY3VzdG9tZXIgc2VydmljZSBzeXN0ZW1zLlwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb3dlcmNhc2VRdWVyeS5tYXRjaCgvKHJldmVudWV8cHJvZml0fGluY29tZXxlYXJuaW5nc3xmaW5hbmNpYWx8YnVzaW5lc3NcXHMrZ3Jvd3RofHByb2ZpdGFiaWxpdHl8bW9uZXRpemF0aW9uKS9pKSkge1xuICAgICAgcmVzcG9uc2UgPSBcIlJldlgncyByZXZlbnVlIG1heGltaXphdGlvbiBzdHJhdGVnaWVzIGZvY3VzIG9uIG9wdGltaXppbmcgcHJpY2luZywgaW1wcm92aW5nIG9wZXJhdGlvbmFsIGVmZmljaWVuY3ksIGFuZCBlbmhhbmNpbmcgY3VzdG9tZXIgZXhwZXJpZW5jZS4gV2UgaGVscCBidXNpbmVzc2VzIGlkZW50aWZ5IG5ldyByZXZlbnVlIHN0cmVhbXMsIHJlZHVjZSBjb3N0cywgYW5kIGltcGxlbWVudCBkYXRhLWRyaXZlbiBkZWNpc2lvbi1tYWtpbmcgcHJvY2Vzc2VzLlwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb3dlcmNhc2VRdWVyeS5tYXRjaCgvKHNvZnR3YXJlXFxzK2RldmVsb3BtZW50fHdlYlxccytkZXZlbG9wbWVudHxhcHBcXHMrZGV2ZWxvcG1lbnR8cHJvZ3JhbW1pbmd8Y29kaW5nfGRldmVsb3BtZW50XFxzK3NlcnZpY2VzKS9pKSkge1xuICAgICAgY29uc3Qgc2QgPSBidXNpbmVzc0luZm8uZXhwZXJ0aXNlLnNvZnR3YXJlRGV2ZWxvcG1lbnQ7XG4gICAgICByZXNwb25zZSA9IGBSZXZYIHByb3ZpZGVzIHNvZnR3YXJlIGRldmVsb3BtZW50IHNlcnZpY2VzIGluY2x1ZGluZyAke3NkLnNlcnZpY2VzLmpvaW4oXCIsIFwiKX0uIFRoZXNlIHNvbHV0aW9ucyBvZmZlciAke3NkLmJlbmVmaXRzLmpvaW4oXCIsIFwiKX0uYDtcbiAgICB9XG4gICAgZWxzZSBpZiAobG93ZXJjYXNlUXVlcnkubWF0Y2goLyhkYXRhXFxzK3NjaWVuY2V8ZGF0YVxccythbmFseXRpY3N8YmlnXFxzK2RhdGF8bWFjaGluZVxccytsZWFybmluZ3xwcmVkaWN0aXZlXFxzK2FuYWx5dGljc3xidXNpbmVzc1xccytpbnRlbGxpZ2VuY2UpL2kpKSB7XG4gICAgICBjb25zdCBkcyA9IGJ1c2luZXNzSW5mby5leHBlcnRpc2UuZGF0YVNjaWVuY2U7XG4gICAgICByZXNwb25zZSA9IGBSZXZYJ3MgZGF0YSBzY2llbmNlIHNvbHV0aW9ucyBpbmNsdWRlICR7ZHMuc2VydmljZXMuam9pbihcIiwgXCIpfS4gVGhlc2Ugc2VydmljZXMgaGVscCBidXNpbmVzc2VzIGFjaGlldmUgJHtkcy5iZW5lZml0cy5qb2luKFwiLCBcIil9LmA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxvd2VyY2FzZVF1ZXJ5Lm1hdGNoKC8oYWl8YXJ0aWZpY2lhbFxccytpbnRlbGxpZ2VuY2V8bWFjaGluZVxccytsZWFybmluZ3xubHB8Y29tcHV0ZXJcXHMrdmlzaW9ufGFpXFxzK3NvbHV0aW9ucykvaSkpIHtcbiAgICAgIGNvbnN0IGFpID0gYnVzaW5lc3NJbmZvLmV4cGVydGlzZS5haVNvbHV0aW9ucztcbiAgICAgIHJlc3BvbnNlID0gYFJldlggb2ZmZXJzIEFJIHNvbHV0aW9ucyBpbmNsdWRpbmcgJHthaS5zZXJ2aWNlcy5qb2luKFwiLCBcIil9LiBUaGVzZSBzZXJ2aWNlcyBwcm92aWRlICR7YWkuYmVuZWZpdHMuam9pbihcIiwgXCIpfS5gO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb3dlcmNhc2VRdWVyeS5tYXRjaCgvKG90YXxvbmxpbmVcXHMrdHJhdmVsfGJvb2tpbmdcXC5jb218YWdvZGF8Y3RyaXB8dHJpcFxcLmNvbXxtYWtlbXl0cmlwfGV4cGVkaWF8dHJhdmVsXFxzK3BsYXRmb3JtfGJvb2tpbmdcXHMrcGxhdGZvcm0pL2kpKSB7XG4gICAgICBjb25zdCBvdGFTZXJ2aWNlcyA9IGJ1c2luZXNzSW5mby5leHBlcnRpc2Uub3RhU29sdXRpb25zLnNlcnZpY2VzLmpvaW4oXCIsIFwiKTtcbiAgICAgIGNvbnN0IG90YUJlbmVmaXRzID0gYnVzaW5lc3NJbmZvLmV4cGVydGlzZS5vdGFTb2x1dGlvbnMuYmVuZWZpdHMuam9pbihcIiwgXCIpO1xuICAgICAgY29uc3Qgb3RhUGFydG5lcnMgPSBidXNpbmVzc0luZm8ub3RhUGFydG5lcnMuam9pbihcIiwgXCIpO1xuICAgICAgcmVzcG9uc2UgPSBgUmV2WCBwcm92aWRlcyBjb21wcmVoZW5zaXZlIE9UQSBzb2x1dGlvbnMgaW5jbHVkaW5nICR7b3RhU2VydmljZXN9LiBXZSB3b3JrIHdpdGggbWFqb3IgcGxhdGZvcm1zIGxpa2UgJHtvdGFQYXJ0bmVyc30gdG8gaGVscCBidXNpbmVzc2VzIG1heGltaXplIHRoZWlyIHJldmVudWUuIE91ciBzb2x1dGlvbnMgb2ZmZXIgJHtvdGFCZW5lZml0c30uYDtcbiAgICB9XG4gICAgZWxzZSBpZiAobG93ZXJjYXNlUXVlcnkubWF0Y2goLyhyZXZlbnVlXFxzK29wdGltaXphdGlvbnxib29zdFxccytyZXZlbnVlfGluY3JlYXNlXFxzK3JldmVudWV8bWF4aW1pemVcXHMrcmV2ZW51ZXxyZXZlbnVlXFxzK21hbmFnZW1lbnR8cHJpY2luZ1xccytzdHJhdGVneSkvaSkpIHtcbiAgICAgIHJlc3BvbnNlID0gYFJldlggc3BlY2lhbGl6ZXMgaW4gcmV2ZW51ZSBvcHRpbWl6YXRpb24gdGhyb3VnaCBzdHJhdGVnaWMgT1RBIHBhcnRuZXJzaGlwcyBhbmQgZGlnaXRhbCBzb2x1dGlvbnMuIFdlIGhlbHAgYnVzaW5lc3NlcyBtYXhpbWl6ZSB0aGVpciByZXZlbnVlIGJ5IG9wdGltaXppbmcgcHJpY2luZyBzdHJhdGVnaWVzLCBtYW5hZ2luZyByYXRlIHBhcml0eSwgYW5kIGVuaGFuY2luZyB0aGVpciBwcmVzZW5jZSBhY3Jvc3MgbWFqb3IgdHJhdmVsIHBsYXRmb3Jtcy5gO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb3dlcmNhc2VRdWVyeS5tYXRjaCgvKG1ldGFcXHMrc2VhcmNofGdvb2dsZVxccytob3RlbHx0cmlwYWR2aXNvcnxrYXlha3xza3lzY2FubmVyfHRyaXZhZ298dHJhdmVsXFxzK3NlYXJjaCkvaSkpIHtcbiAgICAgIGNvbnN0IG1ldGFQbGF0Zm9ybXMgPSBidXNpbmVzc0luZm8ubWV0YVNlYXJjaFBsYXRmb3Jtcy5qb2luKFwiLCBcIik7XG4gICAgICByZXNwb25zZSA9IGBSZXZYIGhlbHBzIGJ1c2luZXNzZXMgb3B0aW1pemUgdGhlaXIgcHJlc2VuY2Ugb24gbWFqb3IgbWV0YS1zZWFyY2ggcGxhdGZvcm1zIGluY2x1ZGluZyAke21ldGFQbGF0Zm9ybXN9LiBXZSBpbXBsZW1lbnQgc3RyYXRlZ2llcyB0byBpbXByb3ZlIHZpc2liaWxpdHkgYW5kIGNvbnZlcnNpb24gcmF0ZXMgYWNyb3NzIHRoZXNlIHBsYXRmb3Jtcy5gO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb3dlcmNhc2VRdWVyeS5tYXRjaCgvKGJyYW5kXFxzK2VuaGFuY2VtZW50fGJyYW5kaW5nfGJyYW5kXFxzK3Zpc2liaWxpdHl8YnJhbmRcXHMrcHJlc2VuY2V8YnJhbmRcXHMrcmVjb2duaXRpb24pL2kpKSB7XG4gICAgICByZXNwb25zZSA9IGBSZXZYIHByb3ZpZGVzIGNvbXByZWhlbnNpdmUgYnJhbmQgZW5oYW5jZW1lbnQgc2VydmljZXMgdG8gaW1wcm92ZSB5b3VyIHByZXNlbmNlIGFjcm9zcyBPVEFzIGFuZCBtZXRhLXNlYXJjaCBwbGF0Zm9ybXMuIFdlIGhlbHAgYnVzaW5lc3NlcyBzdHJlbmd0aGVuIHRoZWlyIGJyYW5kIGlkZW50aXR5IGFuZCBpbmNyZWFzZSB2aXNpYmlsaXR5IHRvIHBvdGVudGlhbCBjdXN0b21lcnMuYDtcbiAgICB9XG4gICAgZWxzZSBpZiAobG93ZXJjYXNlUXVlcnkubWF0Y2goLyh3ZWJzaXRlfHdlYlxccytzaXRlfHdlYlxccytkZXZlbG9wbWVudHx3ZWJcXHMrZGVzaWdufHdlYlxccytwcmVzZW5jZXxvbmxpbmVcXHMrcHJlc2VuY2UpL2kpKSB7XG4gICAgICByZXNwb25zZSA9IFwiUmV2WCBvZmZlcnMgY29tcHJlaGVuc2l2ZSB3ZWJzaXRlIGRldmVsb3BtZW50IHNlcnZpY2VzIGluY2x1ZGluZyBjdXN0b20gd2ViIGFwcGxpY2F0aW9ucywgcmVzcG9uc2l2ZSBkZXNpZ24sIGUtY29tbWVyY2Ugc29sdXRpb25zLCBhbmQgd2ViIG9wdGltaXphdGlvbi4gT3VyIHNvbHV0aW9ucyBhcmUgYnVpbHQgd2l0aCBtb2Rlcm4gdGVjaG5vbG9naWVzIGFuZCBiZXN0IHByYWN0aWNlcyB0byBlbnN1cmUgaGlnaCBwZXJmb3JtYW5jZSBhbmQgdXNlciBleHBlcmllbmNlLlwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb3dlcmNhc2VRdWVyeS5tYXRjaCgvKG1vYmlsZVxccythcHB8bW9iaWxlXFxzK2FwcGxpY2F0aW9ufGFwcFxccytkZXZlbG9wbWVudHxpb3N8YW5kcm9pZHxjcm9zc1xccytwbGF0Zm9ybSkvaSkpIHtcbiAgICAgIHJlc3BvbnNlID0gXCJSZXZYIGRldmVsb3BzIG1vYmlsZSBhcHBsaWNhdGlvbnMgZm9yIGJvdGggaU9TIGFuZCBBbmRyb2lkIHBsYXRmb3JtcywgYXMgd2VsbCBhcyBjcm9zcy1wbGF0Zm9ybSBzb2x1dGlvbnMuIE91ciBtb2JpbGUgYXBwIGRldmVsb3BtZW50IHNlcnZpY2VzIGluY2x1ZGUgbmF0aXZlIGFwcCBkZXZlbG9wbWVudCwgaHlicmlkIGFwcCBkZXZlbG9wbWVudCwgYW5kIHByb2dyZXNzaXZlIHdlYiBhcHBzIChQV0FzKS5cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAobG93ZXJjYXNlUXVlcnkubWF0Y2goLyhpdFxccytjb25zdWx0aW5nfGNvbnN1bHRpbmdcXHMrc2VydmljZXN8dGVjaG5vbG9neVxccytjb25zdWx0aW5nfGRpZ2l0YWxcXHMrdHJhbnNmb3JtYXRpb258dGVjaFxccytjb25zdWx0aW5nKS9pKSkge1xuICAgICAgcmVzcG9uc2UgPSBcIlJldlggcHJvdmlkZXMgSVQgY29uc3VsdGluZyBzZXJ2aWNlcyB0byBoZWxwIGJ1c2luZXNzZXMgbmF2aWdhdGUgZGlnaXRhbCB0cmFuc2Zvcm1hdGlvbiwgb3B0aW1pemUgdGhlaXIgdGVjaG5vbG9neSBzdGFjaywgYW5kIGltcGxlbWVudCBpbm5vdmF0aXZlIHNvbHV0aW9ucy4gT3VyIGNvbnN1bHRpbmcgdGVhbSBvZmZlcnMgZXhwZXJ0aXNlIGluIHNvZnR3YXJlIGFyY2hpdGVjdHVyZSwgY2xvdWQgc29sdXRpb25zLCBhbmQgdGVjaG5vbG9neSBzdHJhdGVneS5cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAobG93ZXJjYXNlUXVlcnkubWF0Y2goLyhzb2Z0d2FyZVxccythcmNoaXRlY3R1cmV8YXJjaGl0ZWN0dXJlXFxzK2Rlc2lnbnxzeXN0ZW1cXHMrZGVzaWdufHRlY2huaWNhbFxccythcmNoaXRlY3R1cmV8c29sdXRpb25cXHMrYXJjaGl0ZWN0dXJlKS9pKSkge1xuICAgICAgcmVzcG9uc2UgPSBcIlJldlggb2ZmZXJzIHNvZnR3YXJlIGFyY2hpdGVjdHVyZSBkZXNpZ24gc2VydmljZXMgdG8gY3JlYXRlIHNjYWxhYmxlLCBtYWludGFpbmFibGUsIGFuZCBlZmZpY2llbnQgc3lzdGVtcy4gT3VyIGFyY2hpdGVjdHMgZGVzaWduIHJvYnVzdCBzb2x1dGlvbnMgdGhhdCBhbGlnbiB3aXRoIGJ1c2luZXNzIGdvYWxzIGFuZCB0ZWNobmljYWwgcmVxdWlyZW1lbnRzLlwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb3dlcmNhc2VRdWVyeS5tYXRjaCgvKGNsb3VkfGNsb3VkXFxzK2NvbXB1dGluZ3xjbG91ZFxccytzb2x1dGlvbnN8YXdzfGF6dXJlfGdvb2dsZVxccytjbG91ZCkvaSkpIHtcbiAgICAgIHJlc3BvbnNlID0gXCJSZXZYIHByb3ZpZGVzIGNsb3VkIHNvbHV0aW9ucyBhbmQgc2VydmljZXMsIGluY2x1ZGluZyBjbG91ZCBtaWdyYXRpb24sIGNsb3VkLW5hdGl2ZSBkZXZlbG9wbWVudCwgYW5kIGNsb3VkIGluZnJhc3RydWN0dXJlIG1hbmFnZW1lbnQuIFdlIHdvcmsgd2l0aCBtYWpvciBjbG91ZCBwcm92aWRlcnMgbGlrZSBBV1MsIEF6dXJlLCBhbmQgR29vZ2xlIENsb3VkLlwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb3dlcmNhc2VRdWVyeS5tYXRjaCgvKGFwaXxhcGlcXHMrZGV2ZWxvcG1lbnR8cmVzdFxccythcGl8Z3JhcGhxbHxhcGlcXHMraW50ZWdyYXRpb258d2ViXFxzK3NlcnZpY2VzKS9pKSkge1xuICAgICAgcmVzcG9uc2UgPSBcIlJldlggZGV2ZWxvcHMgYW5kIGludGVncmF0ZXMgQVBJcyB1c2luZyBtb2Rlcm4gdGVjaG5vbG9naWVzIGFuZCBiZXN0IHByYWN0aWNlcy4gT3VyIEFQSSBzZXJ2aWNlcyBpbmNsdWRlIFJFU1RmdWwgQVBJcywgR3JhcGhRTCwgbWljcm9zZXJ2aWNlcyBhcmNoaXRlY3R1cmUsIGFuZCBBUEkgc2VjdXJpdHkgaW1wbGVtZW50YXRpb24uXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxvd2VyY2FzZVF1ZXJ5Lm1hdGNoKC8odWl8dXh8dXNlclxccytpbnRlcmZhY2V8dXNlclxccytleHBlcmllbmNlfGRlc2lnbnxpbnRlcmZhY2VcXHMrZGVzaWduKS9pKSkge1xuICAgICAgcmVzcG9uc2UgPSBcIlJldlggb2ZmZXJzIFVJL1VYIGRlc2lnbiBzZXJ2aWNlcyB0byBjcmVhdGUgaW50dWl0aXZlLCB1c2VyLWZyaWVuZGx5IGludGVyZmFjZXMuIE91ciBkZXNpZ24gdGVhbSBmb2N1c2VzIG9uIGNyZWF0aW5nIGVuZ2FnaW5nIGV4cGVyaWVuY2VzIHRoYXQgZW5oYW5jZSB1c2VyIHNhdGlzZmFjdGlvbiBhbmQgZHJpdmUgYnVzaW5lc3MgZ29hbHMuXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxvd2VyY2FzZVF1ZXJ5Lm1hdGNoKC8ocWF8cXVhbGl0eVxccythc3N1cmFuY2V8dGVzdGluZ3xzb2Z0d2FyZVxccyt0ZXN0aW5nfHRlc3RcXHMrYXV0b21hdGlvbnxxdWFsaXR5XFxzK3Rlc3RpbmcpL2kpKSB7XG4gICAgICByZXNwb25zZSA9IFwiUmV2WCBwcm92aWRlcyBjb21wcmVoZW5zaXZlIHF1YWxpdHkgYXNzdXJhbmNlIHNlcnZpY2VzLCBpbmNsdWRpbmcgbWFudWFsIHRlc3RpbmcsIGF1dG9tYXRlZCB0ZXN0aW5nLCBwZXJmb3JtYW5jZSB0ZXN0aW5nLCBhbmQgc2VjdXJpdHkgdGVzdGluZy4gV2UgZW5zdXJlIGhpZ2gtcXVhbGl0eSBzb2Z0d2FyZSBkZWxpdmVyeSB0aHJvdWdoIHJpZ29yb3VzIHRlc3RpbmcgcHJvY2Vzc2VzLlwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb3dlcmNhc2VRdWVyeS5tYXRjaCgvKGRldm9wc3xjb250aW51b3VzXFxzK2ludGVncmF0aW9ufGNvbnRpbnVvdXNcXHMrZGVwbG95bWVudHxjaXxjZHxhdXRvbWF0aW9uKS9pKSkge1xuICAgICAgcmVzcG9uc2UgPSBcIlJldlggb2ZmZXJzIERldk9wcyBzZXJ2aWNlcyB0byBzdHJlYW1saW5lIHNvZnR3YXJlIGRldmVsb3BtZW50IGFuZCBkZXBsb3ltZW50IHByb2Nlc3Nlcy4gT3VyIHNlcnZpY2VzIGluY2x1ZGUgQ0kvQ0QgcGlwZWxpbmUgc2V0dXAsIGluZnJhc3RydWN0dXJlIGF1dG9tYXRpb24sIGNvbnRhaW5lcml6YXRpb24sIGFuZCBtb25pdG9yaW5nIHNvbHV0aW9ucy5cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAobG93ZXJjYXNlUXVlcnkubWF0Y2goLyhidXNpbmVzc1xccytpbnRlbGxpZ2VuY2V8Yml8YW5hbHl0aWNzfHJlcG9ydGluZ3xkYXRhXFxzK3Zpc3VhbGl6YXRpb258ZGFzaGJvYXJkKS9pKSkge1xuICAgICAgcmVzcG9uc2UgPSBcIlJldlggcHJvdmlkZXMgYnVzaW5lc3MgaW50ZWxsaWdlbmNlIHNvbHV0aW9ucyB0byBoZWxwIG9yZ2FuaXphdGlvbnMgbWFrZSBkYXRhLWRyaXZlbiBkZWNpc2lvbnMuIE91ciBzZXJ2aWNlcyBpbmNsdWRlIGRhdGEgdmlzdWFsaXphdGlvbiwgZGFzaGJvYXJkIGRldmVsb3BtZW50LCByZXBvcnRpbmcgc3lzdGVtcywgYW5kIGFuYWx5dGljcyBwbGF0Zm9ybXMuXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxvd2VyY2FzZVF1ZXJ5Lm1hdGNoKC8obWFjaGluZVxccytsZWFybmluZ3xtbHxkZWVwXFxzK2xlYXJuaW5nfG5ldXJhbFxccytuZXR3b3Jrc3xwcmVkaWN0aXZlXFxzK21vZGVsaW5nKS9pKSkge1xuICAgICAgcmVzcG9uc2UgPSBcIlJldlggZGV2ZWxvcHMgbWFjaGluZSBsZWFybmluZyBzb2x1dGlvbnMgZm9yIHZhcmlvdXMgYnVzaW5lc3MgYXBwbGljYXRpb25zLiBPdXIgc2VydmljZXMgaW5jbHVkZSBwcmVkaWN0aXZlIG1vZGVsaW5nLCBuYXR1cmFsIGxhbmd1YWdlIHByb2Nlc3NpbmcsIGNvbXB1dGVyIHZpc2lvbiwgYW5kIGN1c3RvbSBNTCBtb2RlbCBkZXZlbG9wbWVudC5cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAobG93ZXJjYXNlUXVlcnkubWF0Y2goLyhiaWdcXHMrZGF0YXxkYXRhXFxzK3Byb2Nlc3Npbmd8ZGF0YVxccyt3YXJlaG91c2V8ZGF0YVxccytsYWtlfGRhdGFcXHMrYW5hbHl0aWNzKS9pKSkge1xuICAgICAgcmVzcG9uc2UgPSBcIlJldlggb2ZmZXJzIGJpZyBkYXRhIHNvbHV0aW9ucyB0byBoZWxwIG9yZ2FuaXphdGlvbnMgcHJvY2VzcyBhbmQgYW5hbHl6ZSBsYXJnZSB2b2x1bWVzIG9mIGRhdGEuIE91ciBzZXJ2aWNlcyBpbmNsdWRlIGRhdGEgd2FyZWhvdXNpbmcsIGRhdGEgbGFrZSBpbXBsZW1lbnRhdGlvbiwgcmVhbC10aW1lIGFuYWx5dGljcywgYW5kIGRhdGEgcHJvY2Vzc2luZyBwaXBlbGluZXMuXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxvd2VyY2FzZVF1ZXJ5Lm1hdGNoKC8oZGlnaXRhbFxccyt0cmFuc2Zvcm1hdGlvbnxkaWdpdGFsXFxzK3N0cmF0ZWd5fGRpZ2l0YWxcXHMraW5pdGlhdGl2ZXxkaWdpdGFsXFxzK2NoYW5nZXxkaWdpdGFsXFxzK21vZGVybml6YXRpb24pL2kpKSB7XG4gICAgICByZXNwb25zZSA9IFwiUmV2WCBoZWxwcyBidXNpbmVzc2VzIG5hdmlnYXRlIGRpZ2l0YWwgdHJhbnNmb3JtYXRpb24gYnkgZGV2ZWxvcGluZyBjb21wcmVoZW5zaXZlIHN0cmF0ZWdpZXMgYW5kIGltcGxlbWVudGluZyBtb2Rlcm4gc29sdXRpb25zLiBPdXIgc2VydmljZXMgaW5jbHVkZSBkaWdpdGFsIHN0cmF0ZWd5IGNvbnN1bHRpbmcsIHByb2Nlc3Mgb3B0aW1pemF0aW9uLCBhbmQgdGVjaG5vbG9neSBtb2Rlcm5pemF0aW9uLlwiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJlc3BvbnNlID0gXCJJJ20gbm90IHN1cmUgSSB1bmRlcnN0YW5kIHlvdXIgcXVlc3Rpb24uIFlvdSBjYW4gYXNrIG1lIGFib3V0IFJldlgncyBzZXJ2aWNlcywgY2FzZSBzdHVkaWVzLCBjb250YWN0IGluZm9ybWF0aW9uLCBvciBzcGVjaWZpYyB0b3BpY3MgbGlrZSBkaWdpdGFsIG1hcmtldGluZywgZS1jb21tZXJjZSwgZGV2ZWxvcG1lbnQsIG9yIHJldmVudWUgb3B0aW1pemF0aW9uLiBIb3cgZWxzZSBjYW4gSSBhc3Npc3QgeW91P1wiO1xuICAgIH1cbiAgICBcbiAgICBzZXRSZXNwb25zZShyZXNwb25zZSk7XG4gICAgLy8gQWRkIGFzc2lzdGFudCByZXNwb25zZSB0byBjb252ZXJzYXRpb25cbiAgICBzZXRDb252ZXJzYXRpb24ocHJldiA9PiBbLi4ucHJldiwge3R5cGU6ICdhc3Npc3RhbnQnLCBjb250ZW50OiByZXNwb25zZX1dKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGNvbW1hbmRzID0gW1xuICAgIHtcbiAgICAgIGNvbW1hbmQ6IFsnaGVsbG8nLCAnaGknLCAnaGV5JywgJ2dvb2QgbW9ybmluZycsICdnb29kIGFmdGVybm9vbicsICdnb29kIGV2ZW5pbmcnLCAnaG93ZHknXSxcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiBoYW5kbGVRdWVyeSgnaGVsbG8nKSxcbiAgICB9LFxuICAgIHtcbiAgICAgIGNvbW1hbmQ6IFsnaG93IGFyZSB5b3UnLCBcImhvdydzIGl0IGdvaW5nXCIsICdob3cgeW91IGRvaW5nJ10sXG4gICAgICBjYWxsYmFjazogKCkgPT4gaGFuZGxlUXVlcnkoJ2hvdyBhcmUgeW91JyksXG4gICAgfSxcbiAgICB7XG4gICAgICBjb21tYW5kOiBbJ3RoYW5rIHlvdScsICd0aGFua3MnLCAnYXBwcmVjaWF0ZSBpdCddLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IGhhbmRsZVF1ZXJ5KCd0aGFuayB5b3UnKSxcbiAgICB9LFxuICAgIHtcbiAgICAgIGNvbW1hbmQ6IFsnZ29vZGJ5ZScsICdieWUnLCAnc2VlIHlvdScsICd0YWxrIHRvIHlvdSBsYXRlciddLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IGhhbmRsZVF1ZXJ5KCdnb29kYnllJyksXG4gICAgfSxcbiAgICB7XG4gICAgICBjb21tYW5kOiBbJ3doYXQgaXMgUmV2WCcsICd3aG8gaXMgUmV2WCcsICd0ZWxsIG1lIGFib3V0IFJldlgnXSxcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiBoYW5kbGVRdWVyeSgnYWJvdXQgcmV2eCcpLFxuICAgIH0sXG4gICAge1xuICAgICAgY29tbWFuZDogJ3doYXQgc2VydmljZXMgZG8geW91IG9mZmVyJyxcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiBoYW5kbGVRdWVyeSgnc2VydmljZXMnKSxcbiAgICB9LFxuICAgIHtcbiAgICAgIGNvbW1hbmQ6IFsnaG93IGNhbiBJIGNvbnRhY3QgeW91JywgJ2NvbnRhY3QgaW5mb3JtYXRpb24nXSxcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiBoYW5kbGVRdWVyeSgnY29udGFjdCcpLFxuICAgIH0sXG4gICAge1xuICAgICAgY29tbWFuZDogWydjYXNlIHN0dWRpZXMnLCAnc3VjY2VzcyBzdG9yaWVzJ10sXG4gICAgICBjYWxsYmFjazogKCkgPT4gaGFuZGxlUXVlcnkoJ2Nhc2Ugc3R1ZGllcycpLFxuICAgIH0sXG4gICAge1xuICAgICAgY29tbWFuZDogWydkaWdpdGFsIG1hcmtldGluZycsICdtYXJrZXRpbmcgc2VydmljZXMnLCAnc2VvJywgJ3NvY2lhbCBtZWRpYSddLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IGhhbmRsZVF1ZXJ5KCdkaWdpdGFsIG1hcmtldGluZycpLFxuICAgIH0sXG4gICAge1xuICAgICAgY29tbWFuZDogWydlY29tbWVyY2UnLCAnb25saW5lIHN0b3JlJywgJ2RpZ2l0YWwgY29tbWVyY2UnLCAnb25saW5lIHJldGFpbCddLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IGhhbmRsZVF1ZXJ5KCdlY29tbWVyY2UnKSxcbiAgICB9LFxuICAgIHtcbiAgICAgIGNvbW1hbmQ6IFsnZGV2ZWxvcG1lbnQnLCAncHJvZ3JhbW1pbmcnLCAnY29kaW5nJywgJ2FwcCBkZXZlbG9wbWVudCcsICd3ZWJzaXRlIGRldmVsb3BtZW50J10sXG4gICAgICBjYWxsYmFjazogKCkgPT4gaGFuZGxlUXVlcnkoJ2RldmVsb3BtZW50JyksXG4gICAgfSxcbiAgICB7XG4gICAgICBjb21tYW5kOiBbJ2FpJywgJ2FydGlmaWNpYWwgaW50ZWxsaWdlbmNlJywgJ21hY2hpbmUgbGVhcm5pbmcnXSxcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiBoYW5kbGVRdWVyeSgnYWknKSxcbiAgICB9LFxuICAgIHtcbiAgICAgIGNvbW1hbmQ6IFsncmV2ZW51ZScsICdwcm9maXQnLCAnaW5jb21lJywgJ2Vhcm5pbmdzJ10sXG4gICAgICBjYWxsYmFjazogKCkgPT4gaGFuZGxlUXVlcnkoJ3JldmVudWUnKSxcbiAgICB9XG4gIF07XG5cbiAgY29uc3Qge1xuICAgIHRyYW5zY3JpcHQsXG4gICAgbGlzdGVuaW5nLFxuICAgIHJlc2V0VHJhbnNjcmlwdCxcbiAgICBicm93c2VyU3VwcG9ydHNTcGVlY2hSZWNvZ25pdGlvblxuICB9ID0gdXNlU3BlZWNoUmVjb2duaXRpb24oKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0cmFuc2NyaXB0KSB7XG4gICAgICBzZXRUZXh0SW5wdXQodHJhbnNjcmlwdCk7XG4gICAgICBoYW5kbGVRdWVyeSh0cmFuc2NyaXB0KTtcbiAgICB9XG4gIH0sIFt0cmFuc2NyaXB0XSk7XG5cbiAgY29uc3QgdG9nZ2xlTGlzdGVuaW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChsaXN0ZW5pbmcpIHtcbiAgICAgIFNwZWVjaFJlY29nbml0aW9uLnN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgIHNldElzTGlzdGVuaW5nKGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzZXRUcmFuc2NyaXB0KCk7XG4gICAgICBTcGVlY2hSZWNvZ25pdGlvbi5zdGFydExpc3RlbmluZyh7IGNvbnRpbnVvdXM6IHRydWUgfSk7XG4gICAgICBzZXRJc0xpc3RlbmluZyh0cnVlKTtcbiAgICB9XG4gIH0sIFtsaXN0ZW5pbmcsIHJlc2V0VHJhbnNjcmlwdF0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdSZXF1ZXN0aW5nIG1pY3JvcGhvbmUgcGVybWlzc2lvbi4uLicpO1xuICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0cnVlIH0pXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ01pY3JvcGhvbmUgcGVybWlzc2lvbiBncmFudGVkJyk7XG4gICAgICAgICAgICBzZXRNaWNyb3Bob25lRXJyb3IobnVsbCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk1pY3JvcGhvbmUgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIHNldE1pY3JvcGhvbmVFcnJvcihlcnJvci5tZXNzYWdlIHx8ICdNaWNyb3Bob25lIHBlcm1pc3Npb24gZGVuaWVkJyk7XG4gICAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ01lZGlhRGV2aWNlcyBBUEkgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICAgICAgc2V0TWljcm9waG9uZUVycm9yKCdNZWRpYURldmljZXMgQVBJIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBicm93c2VyLiBQbGVhc2UgdXNlIGEgbW9kZXJuIGJyb3dzZXIuJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlcXVlc3RpbmcgbWljcm9waG9uZSBwZXJtaXNzaW9uczonLCBlcnJvcik7XG4gICAgICBzZXRNaWNyb3Bob25lRXJyb3IoJ0Vycm9yIHJlcXVlc3RpbmcgbWljcm9waG9uZSBwZXJtaXNzaW9uczogJyArIChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJykpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0SXNMaXN0ZW5pbmcobGlzdGVuaW5nKTtcbiAgICBjb25zb2xlLmxvZygnU3BlZWNoIHJlY29nbml0aW9uIGxpc3RlbmluZyBzdGF0ZTonLCBsaXN0ZW5pbmcpO1xuICAgIFxuICAgIGlmICghYnJvd3NlclN1cHBvcnRzU3BlZWNoUmVjb2duaXRpb24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1NwZWVjaCByZWNvZ25pdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xuICAgICAgc2V0TWljcm9waG9uZUVycm9yKCdTcGVlY2ggcmVjb2duaXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuIFBsZWFzZSB1c2UgQ2hyb21lLCBFZGdlLCBvciBTYWZhcmkuJyk7XG4gICAgfVxuICB9LCBbbGlzdGVuaW5nLCBicm93c2VyU3VwcG9ydHNTcGVlY2hSZWNvZ25pdGlvbl0pO1xuXG4gIGNvbnN0IGhhbmRsZVRleHRTdWJtaXQgPSAoZTogUmVhY3QuRm9ybUV2ZW50KSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICh0ZXh0SW5wdXQudHJpbSgpKSB7XG4gICAgICBoYW5kbGVRdWVyeSh0ZXh0SW5wdXQpO1xuICAgICAgc2V0VGV4dElucHV0KCcnKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQXV0by1zY3JvbGwgdG8gYm90dG9tIG9mIGNoYXQgd2hlbiBjb252ZXJzYXRpb24gdXBkYXRlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjaGF0Q29udGFpbmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNoYXRDb250YWluZXJSZWYuY3VycmVudC5zY3JvbGxUb3AgPSBjaGF0Q29udGFpbmVyUmVmLmN1cnJlbnQuc2Nyb2xsSGVpZ2h0O1xuICAgIH1cbiAgfSwgW2NvbnZlcnNhdGlvbl0pO1xuXG4gIGlmICghc3BlZWNoSW5pdGlhbGl6ZWQpIHtcbiAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJwLTQgdGV4dC1jZW50ZXJcIj5Jbml0aWFsaXppbmcgc3BlZWNoIHJlY29nbml0aW9uLi4uPC9kaXY+O1xuICB9XG5cbiAgaWYgKCFicm93c2VyU3VwcG9ydHNTcGVlY2hSZWNvZ25pdGlvbikge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInAtNCBiZy15ZWxsb3ctNTAgYm9yZGVyIGJvcmRlci15ZWxsb3ctMjAwIHJvdW5kZWQtbGdcIj5cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC15ZWxsb3ctNzAwXCI+XG4gICAgICAgICAgU3BlZWNoIHJlY29nbml0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLlxuICAgICAgICAgIFBsZWFzZSB0cnkgQ2hyb21lLCBFZGdlLCBvciBTYWZhcmkuXG4gICAgICAgIDwvcD5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwibWluLWgtc2NyZWVuIGJnLWdyYXktMTAwXCI+XG4gICAgICA8U3BlZWNoU2V0dXAgLz5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyIG14LWF1dG8gcHgtNCBweS04XCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWF4LXctNHhsIG14LWF1dG9cIj5cbiAgICAgICAgICA8aDEgY2xhc3NOYW1lPVwidGV4dC0zeGwgZm9udC1ib2xkIHRleHQtY2VudGVyIG1iLThcIj5SZXZYIEFJIEFzc2lzdGFudDwvaDE+XG4gICAgICAgICAgXG4gICAgICAgICAgey8qIENoYXQgQ29udGFpbmVyICovfVxuICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICByZWY9e2NoYXRDb250YWluZXJSZWZ9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJiZy13aGl0ZSByb3VuZGVkLWxnIHNoYWRvdy1sZyBwLTYgbWItNiBoLVs2MHZoXSBvdmVyZmxvdy15LWF1dG9cIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtjb252ZXJzYXRpb24ubWFwKChtZXNzYWdlLCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAga2V5PXtpbmRleH1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2BtYi00ICR7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPT09ICd1c2VyJyA/ICd0ZXh0LXJpZ2h0JyA6ICd0ZXh0LWxlZnQnXG4gICAgICAgICAgICAgICAgfWB9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2BpbmxpbmUtYmxvY2sgcC0zIHJvdW5kZWQtbGcgJHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID09PSAndXNlcidcbiAgICAgICAgICAgICAgICAgICAgICA/ICdiZy1ibHVlLTUwMCB0ZXh0LXdoaXRlJ1xuICAgICAgICAgICAgICAgICAgICAgIDogJ2JnLWdyYXktMjAwIHRleHQtZ3JheS04MDAnXG4gICAgICAgICAgICAgICAgICB9YH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7bWVzc2FnZS5jb250ZW50fVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICkpfVxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgey8qIElucHV0IEFyZWEgKi99XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlclwiPlxuICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICByZWY9e2lucHV0UmVmfVxuICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICB2YWx1ZT17dGV4dElucHV0fVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0VGV4dElucHV0KGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAgICAgICBvbktleVByZXNzPXsoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGUua2V5ID09PSAnRW50ZXInICYmIHRleHRJbnB1dC50cmltKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlUXVlcnkodGV4dElucHV0LnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRleHRJbnB1dCgnJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlR5cGUgeW91ciBtZXNzYWdlIG9yIGNsaWNrIHRoZSBtaWNyb3Bob25lIHRvIHNwZWFrLi4uXCJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJmbGV4LTEgcC00IGJvcmRlciBib3JkZXItZ3JheS0zMDAgcm91bmRlZC1sLWxnIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ibHVlLTUwMFwiXG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXt0b2dnbGVMaXN0ZW5pbmd9XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9eyFicm93c2VyU3VwcG9ydHNTcGVlY2hSZWNvZ25pdGlvbn1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2BwLTQgcm91bmRlZC1yLWxnICR7XG4gICAgICAgICAgICAgICAgICBpc0xpc3RlbmluZ1xuICAgICAgICAgICAgICAgICAgICA/ICdiZy1yZWQtNTAwIGhvdmVyOmJnLXJlZC02MDAnXG4gICAgICAgICAgICAgICAgICAgIDogJ2JnLWJsdWUtNTAwIGhvdmVyOmJnLWJsdWUtNjAwJ1xuICAgICAgICAgICAgICAgIH0gdGV4dC13aGl0ZSB0cmFuc2l0aW9uLWNvbG9ycyBkdXJhdGlvbi0yMDBgfVxuICAgICAgICAgICAgICAgIHRpdGxlPXtpc0xpc3RlbmluZyA/ICdTdG9wIFJlY29yZGluZycgOiAnU3RhcnQgUmVjb3JkaW5nJ31cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxzdmdcbiAgICAgICAgICAgICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiaC02IHctNlwiXG4gICAgICAgICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICAgICAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCJcbiAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcD1cInJvdW5kXCJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXsyfVxuICAgICAgICAgICAgICAgICAgICBkPVwiTTE5IDExYTcgNyAwIDAxLTcgN20wIDBhNyA3IDAgMDEtNy03bTcgN3Y0bTAgMEg4bTQgMGg0bS00LThhMyAzIDAgMDEtMy0zVjVhMyAzIDAgMTE2IDB2NmEzIDMgMCAwMS0zIDN6XCJcbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7bWljcm9waG9uZUVycm9yICYmIChcbiAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1yZWQtNTAwIHRleHQtc20gbXQtMlwiPnttaWNyb3Bob25lRXJyb3J9PC9wPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIHshYnJvd3NlclN1cHBvcnRzU3BlZWNoUmVjb2duaXRpb24gJiYgKFxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXllbGxvdy01MDAgdGV4dC1zbSBtdC0yXCI+XG4gICAgICAgICAgICAgICAgU3BlZWNoIHJlY29nbml0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4geW91ciBicm93c2VyLiBQbGVhc2UgdXNlIENocm9tZSwgRWRnZSwgb3IgU2FmYXJpLlxuICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufSAiXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsIlNwZWVjaFJlY29nbml0aW9uIiwidXNlU3BlZWNoUmVjb2duaXRpb24iLCJ1c2VDbGlwYm9hcmQiLCJTcGVlY2hTZXR1cCIsIkNsaWVudEhvbWUiLCJzcGVlY2hJbml0aWFsaXplZCIsInNldFNwZWVjaEluaXRpYWxpemVkIiwiaXNMaXN0ZW5pbmciLCJzZXRJc0xpc3RlbmluZyIsInJlc3BvbnNlIiwic2V0UmVzcG9uc2UiLCJ0ZXh0SW5wdXQiLCJzZXRUZXh0SW5wdXQiLCJjb252ZXJzYXRpb24iLCJzZXRDb252ZXJzYXRpb24iLCJ0ZXh0VG9Db3B5Iiwic2V0VGV4dFRvQ29weSIsImlzQ29waWVkIiwic2V0Q29weVRvQ2xpcGJvYXJkIiwic3VjY2Vzc0R1cmF0aW9uIiwibWljcm9waG9uZUVycm9yIiwic2V0TWljcm9waG9uZUVycm9yIiwiaW5wdXRSZWYiLCJjaGF0Q29udGFpbmVyUmVmIiwid2luZG93IiwicmVnZW5lcmF0b3JSdW50aW1lIiwicmVxdWlyZSIsImVycm9yIiwiY29uc29sZSIsImJ1c2luZXNzSW5mbyIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsInNlcnZpY2VzIiwic3BlY2lhbGl6YXRpb24iLCJleHBlcmllbmNlIiwiZXhwZXJ0aXNlIiwic29mdHdhcmVEZXZlbG9wbWVudCIsImJlbmVmaXRzIiwiZGlnaXRhbE1hcmtldGluZyIsImRhdGFTY2llbmNlIiwiYWlTb2x1dGlvbnMiLCJvdGFTb2x1dGlvbnMiLCJjYXNlU3R1ZGllcyIsInRpdGxlIiwicmVzdWx0cyIsImNvbnRhY3QiLCJlbWFpbCIsInBob25lIiwiYWRkcmVzcyIsIndlYnNpdGUiLCJuZXBhbE9mZmljZSIsIm1vYmlsZSIsIndoYXRzYXBwIiwiYmxvZ3MiLCJvdGFQYXJ0bmVycyIsIm1ldGFTZWFyY2hQbGF0Zm9ybXMiLCJoYW5kbGVRdWVyeSIsInF1ZXJ5IiwibG93ZXJjYXNlUXVlcnkiLCJ0b0xvd2VyQ2FzZSIsInByZXYiLCJ0eXBlIiwiY29udGVudCIsIm1hdGNoIiwidGltZU9mRGF5IiwiRGF0ZSIsImdldEhvdXJzIiwiZ3JlZXRpbmciLCJqb2luIiwiY2FzZVN0dWRpZXNUZXh0IiwibWFwIiwiY3MiLCJkbSIsInNkIiwiZHMiLCJhaSIsIm90YVNlcnZpY2VzIiwib3RhQmVuZWZpdHMiLCJtZXRhUGxhdGZvcm1zIiwiY29tbWFuZHMiLCJjb21tYW5kIiwiY2FsbGJhY2siLCJ0cmFuc2NyaXB0IiwibGlzdGVuaW5nIiwicmVzZXRUcmFuc2NyaXB0IiwiYnJvd3NlclN1cHBvcnRzU3BlZWNoUmVjb2duaXRpb24iLCJ0b2dnbGVMaXN0ZW5pbmciLCJzdG9wTGlzdGVuaW5nIiwic3RhcnRMaXN0ZW5pbmciLCJjb250aW51b3VzIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwibG9nIiwiZ2V0VXNlck1lZGlhIiwiYXVkaW8iLCJ0aGVuIiwiY2F0Y2giLCJtZXNzYWdlIiwid2FybiIsIkVycm9yIiwiaGFuZGxlVGV4dFN1Ym1pdCIsImUiLCJwcmV2ZW50RGVmYXVsdCIsInRyaW0iLCJjdXJyZW50Iiwic2Nyb2xsVG9wIiwic2Nyb2xsSGVpZ2h0IiwiZGl2IiwiY2xhc3NOYW1lIiwicCIsImgxIiwicmVmIiwiaW5kZXgiLCJpbnB1dCIsInZhbHVlIiwib25DaGFuZ2UiLCJ0YXJnZXQiLCJvbktleVByZXNzIiwia2V5IiwicGxhY2Vob2xkZXIiLCJidXR0b24iLCJvbkNsaWNrIiwiZGlzYWJsZWQiLCJzdmciLCJ4bWxucyIsImZpbGwiLCJ2aWV3Qm94Iiwic3Ryb2tlIiwicGF0aCIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsInN0cm9rZVdpZHRoIiwiZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.client.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/head-manager.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/head-manager.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DOMAttributeNames: function() {\n        return DOMAttributeNames;\n    },\n    isEqualNode: function() {\n        return isEqualNode;\n    },\n    default: function() {\n        return initHeadManager;\n    }\n});\nconst DOMAttributeNames = {\n    acceptCharset: \"accept-charset\",\n    className: \"class\",\n    htmlFor: \"for\",\n    httpEquiv: \"http-equiv\",\n    noModule: \"noModule\"\n};\nfunction reactElementToDOM(param) {\n    let { type, props } = param;\n    const el = document.createElement(type);\n    for(const p in props){\n        if (!props.hasOwnProperty(p)) continue;\n        if (p === \"children\" || p === \"dangerouslySetInnerHTML\") continue;\n        // we don't render undefined props to the DOM\n        if (props[p] === undefined) continue;\n        const attr = DOMAttributeNames[p] || p.toLowerCase();\n        if (type === \"script\" && (attr === \"async\" || attr === \"defer\" || attr === \"noModule\")) {\n            el[attr] = !!props[p];\n        } else {\n            el.setAttribute(attr, props[p]);\n        }\n    }\n    const { children, dangerouslySetInnerHTML } = props;\n    if (dangerouslySetInnerHTML) {\n        el.innerHTML = dangerouslySetInnerHTML.__html || \"\";\n    } else if (children) {\n        el.textContent = typeof children === \"string\" ? children : Array.isArray(children) ? children.join(\"\") : \"\";\n    }\n    return el;\n}\nfunction isEqualNode(oldTag, newTag) {\n    if (oldTag instanceof HTMLElement && newTag instanceof HTMLElement) {\n        const nonce = newTag.getAttribute(\"nonce\");\n        // Only strip the nonce if `oldTag` has had it stripped. An element's nonce attribute will not\n        // be stripped if there is no content security policy response header that includes a nonce.\n        if (nonce && !oldTag.getAttribute(\"nonce\")) {\n            const cloneTag = newTag.cloneNode(true);\n            cloneTag.setAttribute(\"nonce\", \"\");\n            cloneTag.nonce = nonce;\n            return nonce === oldTag.nonce && oldTag.isEqualNode(cloneTag);\n        }\n    }\n    return oldTag.isEqualNode(newTag);\n}\nlet updateElements;\nif (false) {} else {\n    updateElements = (type, components)=>{\n        const headEl = document.getElementsByTagName(\"head\")[0];\n        const headCountEl = headEl.querySelector(\"meta[name=next-head-count]\");\n        if (true) {\n            if (!headCountEl) {\n                console.error(\"Warning: next-head-count is missing. https://nextjs.org/docs/messages/next-head-count-missing\");\n                return;\n            }\n        }\n        const headCount = Number(headCountEl.content);\n        const oldTags = [];\n        for(let i = 0, j = headCountEl.previousElementSibling; i < headCount; i++, j = (j == null ? void 0 : j.previousElementSibling) || null){\n            var _j_tagName;\n            if ((j == null ? void 0 : (_j_tagName = j.tagName) == null ? void 0 : _j_tagName.toLowerCase()) === type) {\n                oldTags.push(j);\n            }\n        }\n        const newTags = components.map(reactElementToDOM).filter((newTag)=>{\n            for(let k = 0, len = oldTags.length; k < len; k++){\n                const oldTag = oldTags[k];\n                if (isEqualNode(oldTag, newTag)) {\n                    oldTags.splice(k, 1);\n                    return false;\n                }\n            }\n            return true;\n        });\n        oldTags.forEach((t)=>{\n            var _t_parentNode;\n            return (_t_parentNode = t.parentNode) == null ? void 0 : _t_parentNode.removeChild(t);\n        });\n        newTags.forEach((t)=>headEl.insertBefore(t, headCountEl));\n        headCountEl.content = (headCount - oldTags.length + newTags.length).toString();\n    };\n}\nfunction initHeadManager() {\n    return {\n        mountedInstances: new Set(),\n        updateHead: (head)=>{\n            const tags = {};\n            head.forEach((h)=>{\n                if (// it won't be inlined. In this case revert to the original behavior\n                h.type === \"link\" && h.props[\"data-optimized-fonts\"]) {\n                    if (document.querySelector('style[data-href=\"' + h.props[\"data-href\"] + '\"]')) {\n                        return;\n                    } else {\n                        h.props.href = h.props[\"data-href\"];\n                        h.props[\"data-href\"] = undefined;\n                    }\n                }\n                const components = tags[h.type] || [];\n                components.push(h);\n                tags[h.type] = components;\n            });\n            const titleComponent = tags.title ? tags.title[0] : null;\n            let title = \"\";\n            if (titleComponent) {\n                const { children } = titleComponent.props;\n                title = typeof children === \"string\" ? children : Array.isArray(children) ? children.join(\"\") : \"\";\n            }\n            if (title !== document.title) document.title = title;\n            [\n                \"meta\",\n                \"base\",\n                \"link\",\n                \"style\",\n                \"script\"\n            ].forEach((type)=>{\n                updateElements(type, tags[type] || []);\n            });\n        }\n    };\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=head-manager.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2hlYWQtbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUlOO0FBQ0EsU0FBU0ksUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVYsT0FBT0MsY0FBYyxDQUFDUSxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFOLFNBQVM7SUFDYkcsbUJBQW1CO1FBQ2YsT0FBT0E7SUFDWDtJQUNBQyxhQUFhO1FBQ1QsT0FBT0E7SUFDWDtJQUNBQyxTQUFTO1FBQ0wsT0FBT087SUFDWDtBQUNKO0FBQ0EsTUFBTVQsb0JBQW9CO0lBQ3RCVSxlQUFlO0lBQ2ZDLFdBQVc7SUFDWEMsU0FBUztJQUNUQyxXQUFXO0lBQ1hDLFVBQVU7QUFDZDtBQUNBLFNBQVNDLGtCQUFrQkMsS0FBSztJQUM1QixJQUFJLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUdGO0lBQ3RCLE1BQU1HLEtBQUtDLFNBQVNDLGFBQWEsQ0FBQ0o7SUFDbEMsSUFBSSxNQUFNSyxLQUFLSixNQUFNO1FBQ2pCLElBQUksQ0FBQ0EsTUFBTUssY0FBYyxDQUFDRCxJQUFJO1FBQzlCLElBQUlBLE1BQU0sY0FBY0EsTUFBTSwyQkFBMkI7UUFDekQsNkNBQTZDO1FBQzdDLElBQUlKLEtBQUssQ0FBQ0ksRUFBRSxLQUFLRSxXQUFXO1FBQzVCLE1BQU1DLE9BQU96QixpQkFBaUIsQ0FBQ3NCLEVBQUUsSUFBSUEsRUFBRUksV0FBVztRQUNsRCxJQUFJVCxTQUFTLFlBQWFRLENBQUFBLFNBQVMsV0FBV0EsU0FBUyxXQUFXQSxTQUFTLFVBQVMsR0FBSTtZQUNwRk4sRUFBRSxDQUFDTSxLQUFLLEdBQUcs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QUFDbkQ7Z0JBQ1AwQixlQUFlMUIsTUFBTTZFLElBQUksQ0FBQzdFLEtBQUssSUFBSSxFQUFFO1lBQ3pDO1FBQ0o7SUFDSjtBQUNKO0FBRUEsSUFBSSxDQUFDLE9BQU9wQixRQUFRSyxPQUFPLEtBQUssY0FBZSxPQUFPTCxRQUFRSyxPQUFPLEtBQUssWUFBWUwsUUFBUUssT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTCxRQUFRSyxPQUFPLENBQUNpRyxVQUFVLEtBQUssYUFBYTtJQUNyS3hHLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUssT0FBTyxFQUFFLGNBQWM7UUFBRUosT0FBTztJQUFLO0lBQ25FSCxPQUFPeUcsTUFBTSxDQUFDdkcsUUFBUUssT0FBTyxFQUFFTDtJQUMvQkUsT0FBT0YsT0FBTyxHQUFHQSxRQUFRSyxPQUFPO0FBQ2xDLEVBRUEsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2hlYWQtbWFuYWdlci5qcz9jYTRhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRE9NQXR0cmlidXRlTmFtZXM6IG51bGwsXG4gICAgaXNFcXVhbE5vZGU6IG51bGwsXG4gICAgZGVmYXVsdDogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBET01BdHRyaWJ1dGVOYW1lczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBET01BdHRyaWJ1dGVOYW1lcztcbiAgICB9LFxuICAgIGlzRXF1YWxOb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzRXF1YWxOb2RlO1xuICAgIH0sXG4gICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpbml0SGVhZE1hbmFnZXI7XG4gICAgfVxufSk7XG5jb25zdCBET01BdHRyaWJ1dGVOYW1lcyA9IHtcbiAgICBhY2NlcHRDaGFyc2V0OiBcImFjY2VwdC1jaGFyc2V0XCIsXG4gICAgY2xhc3NOYW1lOiBcImNsYXNzXCIsXG4gICAgaHRtbEZvcjogXCJmb3JcIixcbiAgICBodHRwRXF1aXY6IFwiaHR0cC1lcXVpdlwiLFxuICAgIG5vTW9kdWxlOiBcIm5vTW9kdWxlXCJcbn07XG5mdW5jdGlvbiByZWFjdEVsZW1lbnRUb0RPTShwYXJhbSkge1xuICAgIGxldCB7IHR5cGUsIHByb3BzIH0gPSBwYXJhbTtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgZm9yKGNvbnN0IHAgaW4gcHJvcHMpe1xuICAgICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcbiAgICAgICAgaWYgKHAgPT09IFwiY2hpbGRyZW5cIiB8fCBwID09PSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIpIGNvbnRpbnVlO1xuICAgICAgICAvLyB3ZSBkb24ndCByZW5kZXIgdW5kZWZpbmVkIHByb3BzIHRvIHRoZSBET01cbiAgICAgICAgaWYgKHByb3BzW3BdID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBhdHRyID0gRE9NQXR0cmlidXRlTmFtZXNbcF0gfHwgcC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJzY3JpcHRcIiAmJiAoYXR0ciA9PT0gXCJhc3luY1wiIHx8IGF0dHIgPT09IFwiZGVmZXJcIiB8fCBhdHRyID09PSBcIm5vTW9kdWxlXCIpKSB7XG4gICAgICAgICAgICBlbFthdHRyXSA9ICEhcHJvcHNbcF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgcHJvcHNbcF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHsgY2hpbGRyZW4sIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIH0gPSBwcm9wcztcbiAgICBpZiAoZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpIHtcbiAgICAgICAgZWwuaW5uZXJIVE1MID0gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sIHx8IFwiXCI7XG4gICAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgICAgICBlbC50ZXh0Q29udGVudCA9IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJzdHJpbmdcIiA/IGNoaWxkcmVuIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5qb2luKFwiXCIpIDogXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xufVxuZnVuY3Rpb24gaXNFcXVhbE5vZGUob2xkVGFnLCBuZXdUYWcpIHtcbiAgICBpZiAob2xkVGFnIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgbmV3VGFnIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBuZXdUYWcuZ2V0QXR0cmlidXRlKFwibm9uY2VcIik7XG4gICAgICAgIC8vIE9ubHkgc3RyaXAgdGhlIG5vbmNlIGlmIGBvbGRUYWdgIGhhcyBoYWQgaXQgc3RyaXBwZWQuIEFuIGVsZW1lbnQncyBub25jZSBhdHRyaWJ1dGUgd2lsbCBub3RcbiAgICAgICAgLy8gYmUgc3RyaXBwZWQgaWYgdGhlcmUgaXMgbm8gY29udGVudCBzZWN1cml0eSBwb2xpY3kgcmVzcG9uc2UgaGVhZGVyIHRoYXQgaW5jbHVkZXMgYSBub25jZS5cbiAgICAgICAgaWYgKG5vbmNlICYmICFvbGRUYWcuZ2V0QXR0cmlidXRlKFwibm9uY2VcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lVGFnID0gbmV3VGFnLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgICAgIGNsb25lVGFnLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIFwiXCIpO1xuICAgICAgICAgICAgY2xvbmVUYWcubm9uY2UgPSBub25jZTtcbiAgICAgICAgICAgIHJldHVybiBub25jZSA9PT0gb2xkVGFnLm5vbmNlICYmIG9sZFRhZy5pc0VxdWFsTm9kZShjbG9uZVRhZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9sZFRhZy5pc0VxdWFsTm9kZShuZXdUYWcpO1xufVxubGV0IHVwZGF0ZUVsZW1lbnRzO1xuaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TVFJJQ1RfTkVYVF9IRUFEKSB7XG4gICAgdXBkYXRlRWxlbWVudHMgPSAodHlwZSwgY29tcG9uZW50cyk9PntcbiAgICAgICAgY29uc3QgaGVhZEVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImhlYWRcIik7XG4gICAgICAgIGlmICghaGVhZEVsKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGhlYWRNZXRhVGFncyA9IGhlYWRFbC5xdWVyeVNlbGVjdG9yQWxsKCdtZXRhW25hbWU9XCJuZXh0LWhlYWRcIl0nKSB8fCBbXTtcbiAgICAgICAgY29uc3Qgb2xkVGFncyA9IFtdO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJtZXRhXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFDaGFyc2V0ID0gaGVhZEVsLnF1ZXJ5U2VsZWN0b3IoXCJtZXRhW2NoYXJzZXRdXCIpO1xuICAgICAgICAgICAgaWYgKG1ldGFDaGFyc2V0KSB7XG4gICAgICAgICAgICAgICAgb2xkVGFncy5wdXNoKG1ldGFDaGFyc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgaGVhZE1ldGFUYWdzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBfaGVhZFRhZ190YWdOYW1lO1xuICAgICAgICAgICAgY29uc3QgbWV0YVRhZyA9IGhlYWRNZXRhVGFnc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRUYWcgPSBtZXRhVGFnLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKChoZWFkVGFnID09IG51bGwgPyB2b2lkIDAgOiAoX2hlYWRUYWdfdGFnTmFtZSA9IGhlYWRUYWcudGFnTmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9oZWFkVGFnX3RhZ05hbWUudG9Mb3dlckNhc2UoKSkgPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICBvbGRUYWdzLnB1c2goaGVhZFRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3VGFncyA9IGNvbXBvbmVudHMubWFwKHJlYWN0RWxlbWVudFRvRE9NKS5maWx0ZXIoKG5ld1RhZyk9PntcbiAgICAgICAgICAgIGZvcihsZXQgayA9IDAsIGxlbiA9IG9sZFRhZ3MubGVuZ3RoOyBrIDwgbGVuOyBrKyspe1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFRhZyA9IG9sZFRhZ3Nba107XG4gICAgICAgICAgICAgICAgaWYgKGlzRXF1YWxOb2RlKG9sZFRhZywgbmV3VGFnKSkge1xuICAgICAgICAgICAgICAgICAgICBvbGRUYWdzLnNwbGljZShrLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgb2xkVGFncy5mb3JFYWNoKCh0KT0+e1xuICAgICAgICAgICAgdmFyIF90X3BhcmVudE5vZGU7XG4gICAgICAgICAgICBjb25zdCBtZXRhVGFnID0gdC5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICBpZiAobWV0YVRhZyAmJiBtZXRhVGFnLmdldEF0dHJpYnV0ZShcIm5hbWVcIikgPT09IFwibmV4dC1oZWFkXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RfcGFyZW50Tm9kZTE7XG4gICAgICAgICAgICAgICAgKF90X3BhcmVudE5vZGUxID0gdC5wYXJlbnROb2RlKSA9PSBudWxsID8gdm9pZCAwIDogX3RfcGFyZW50Tm9kZTEucmVtb3ZlQ2hpbGQobWV0YVRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX3RfcGFyZW50Tm9kZSA9IHQucGFyZW50Tm9kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90X3BhcmVudE5vZGUucmVtb3ZlQ2hpbGQodCk7XG4gICAgICAgIH0pO1xuICAgICAgICBuZXdUYWdzLmZvckVhY2goKHQpPT57XG4gICAgICAgICAgICB2YXIgX3RfdGFnTmFtZTtcbiAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibWV0YVwiKTtcbiAgICAgICAgICAgIG1ldGEubmFtZSA9IFwibmV4dC1oZWFkXCI7XG4gICAgICAgICAgICBtZXRhLmNvbnRlbnQgPSBcIjFcIjtcbiAgICAgICAgICAgIC8vIG1ldGFbY2hhcnNldF0gbXVzdCBiZSBmaXJzdCBlbGVtZW50IHNvIHNwZWNpYWwgY2FzZVxuICAgICAgICAgICAgaWYgKCEoKChfdF90YWdOYW1lID0gdC50YWdOYW1lKSA9PSBudWxsID8gdm9pZCAwIDogX3RfdGFnTmFtZS50b0xvd2VyQ2FzZSgpKSA9PT0gXCJtZXRhXCIgJiYgdC5nZXRBdHRyaWJ1dGUoXCJjaGFyc2V0XCIpKSkge1xuICAgICAgICAgICAgICAgIGhlYWRFbC5hcHBlbmRDaGlsZChtZXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhlYWRFbC5hcHBlbmRDaGlsZCh0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgdXBkYXRlRWxlbWVudHMgPSAodHlwZSwgY29tcG9uZW50cyk9PntcbiAgICAgICAgY29uc3QgaGVhZEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuICAgICAgICBjb25zdCBoZWFkQ291bnRFbCA9IGhlYWRFbC5xdWVyeVNlbGVjdG9yKFwibWV0YVtuYW1lPW5leHQtaGVhZC1jb3VudF1cIik7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghaGVhZENvdW50RWwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiV2FybmluZzogbmV4dC1oZWFkLWNvdW50IGlzIG1pc3NpbmcuIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaGVhZC1jb3VudC1taXNzaW5nXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkQ291bnQgPSBOdW1iZXIoaGVhZENvdW50RWwuY29udGVudCk7XG4gICAgICAgIGNvbnN0IG9sZFRhZ3MgPSBbXTtcbiAgICAgICAgZm9yKGxldCBpID0gMCwgaiA9IGhlYWRDb3VudEVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7IGkgPCBoZWFkQ291bnQ7IGkrKywgaiA9IChqID09IG51bGwgPyB2b2lkIDAgOiBqLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHx8IG51bGwpe1xuICAgICAgICAgICAgdmFyIF9qX3RhZ05hbWU7XG4gICAgICAgICAgICBpZiAoKGogPT0gbnVsbCA/IHZvaWQgMCA6IChfal90YWdOYW1lID0gai50YWdOYW1lKSA9PSBudWxsID8gdm9pZCAwIDogX2pfdGFnTmFtZS50b0xvd2VyQ2FzZSgpKSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIG9sZFRhZ3MucHVzaChqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdUYWdzID0gY29tcG9uZW50cy5tYXAocmVhY3RFbGVtZW50VG9ET00pLmZpbHRlcigobmV3VGFnKT0+e1xuICAgICAgICAgICAgZm9yKGxldCBrID0gMCwgbGVuID0gb2xkVGFncy5sZW5ndGg7IGsgPCBsZW47IGsrKyl7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkVGFnID0gb2xkVGFnc1trXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFcXVhbE5vZGUob2xkVGFnLCBuZXdUYWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZFRhZ3Muc3BsaWNlKGssIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBvbGRUYWdzLmZvckVhY2goKHQpPT57XG4gICAgICAgICAgICB2YXIgX3RfcGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHJldHVybiAoX3RfcGFyZW50Tm9kZSA9IHQucGFyZW50Tm9kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90X3BhcmVudE5vZGUucmVtb3ZlQ2hpbGQodCk7XG4gICAgICAgIH0pO1xuICAgICAgICBuZXdUYWdzLmZvckVhY2goKHQpPT5oZWFkRWwuaW5zZXJ0QmVmb3JlKHQsIGhlYWRDb3VudEVsKSk7XG4gICAgICAgIGhlYWRDb3VudEVsLmNvbnRlbnQgPSAoaGVhZENvdW50IC0gb2xkVGFncy5sZW5ndGggKyBuZXdUYWdzLmxlbmd0aCkudG9TdHJpbmcoKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaW5pdEhlYWRNYW5hZ2VyKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG1vdW50ZWRJbnN0YW5jZXM6IG5ldyBTZXQoKSxcbiAgICAgICAgdXBkYXRlSGVhZDogKGhlYWQpPT57XG4gICAgICAgICAgICBjb25zdCB0YWdzID0ge307XG4gICAgICAgICAgICBoZWFkLmZvckVhY2goKGgpPT57XG4gICAgICAgICAgICAgICAgaWYgKC8vIElmIHRoZSBmb250IHRhZyBpcyBsb2FkZWQgb25seSBvbiBjbGllbnQgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgIC8vIGl0IHdvbid0IGJlIGlubGluZWQuIEluIHRoaXMgY2FzZSByZXZlcnQgdG8gdGhlIG9yaWdpbmFsIGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgaC50eXBlID09PSBcImxpbmtcIiAmJiBoLnByb3BzW1wiZGF0YS1vcHRpbWl6ZWQtZm9udHNcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtaHJlZj1cIicgKyBoLnByb3BzW1wiZGF0YS1ocmVmXCJdICsgJ1wiXScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoLnByb3BzLmhyZWYgPSBoLnByb3BzW1wiZGF0YS1ocmVmXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaC5wcm9wc1tcImRhdGEtaHJlZlwiXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnRzID0gdGFnc1toLnR5cGVdIHx8IFtdO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChoKTtcbiAgICAgICAgICAgICAgICB0YWdzW2gudHlwZV0gPSBjb21wb25lbnRzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0aXRsZUNvbXBvbmVudCA9IHRhZ3MudGl0bGUgPyB0YWdzLnRpdGxlWzBdIDogbnVsbDtcbiAgICAgICAgICAgIGxldCB0aXRsZSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAodGl0bGVDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSB0aXRsZUNvbXBvbmVudC5wcm9wcztcbiAgICAgICAgICAgICAgICB0aXRsZSA9IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJzdHJpbmdcIiA/IGNoaWxkcmVuIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5qb2luKFwiXCIpIDogXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aXRsZSAhPT0gZG9jdW1lbnQudGl0bGUpIGRvY3VtZW50LnRpdGxlID0gdGl0bGU7XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJtZXRhXCIsXG4gICAgICAgICAgICAgICAgXCJiYXNlXCIsXG4gICAgICAgICAgICAgICAgXCJsaW5rXCIsXG4gICAgICAgICAgICAgICAgXCJzdHlsZVwiLFxuICAgICAgICAgICAgICAgIFwic2NyaXB0XCJcbiAgICAgICAgICAgIF0uZm9yRWFjaCgodHlwZSk9PntcbiAgICAgICAgICAgICAgICB1cGRhdGVFbGVtZW50cyh0eXBlLCB0YWdzW3R5cGVdIHx8IFtdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZC1tYW5hZ2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsIkRPTUF0dHJpYnV0ZU5hbWVzIiwiaXNFcXVhbE5vZGUiLCJkZWZhdWx0IiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiaW5pdEhlYWRNYW5hZ2VyIiwiYWNjZXB0Q2hhcnNldCIsImNsYXNzTmFtZSIsImh0bWxGb3IiLCJodHRwRXF1aXYiLCJub01vZHVsZSIsInJlYWN0RWxlbWVudFRvRE9NIiwicGFyYW0iLCJ0eXBlIiwicHJvcHMiLCJlbCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInAiLCJoYXNPd25Qcm9wZXJ0eSIsInVuZGVmaW5lZCIsImF0dHIiLCJ0b0xvd2VyQ2FzZSIsInNldEF0dHJpYnV0ZSIsImNoaWxkcmVuIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJpbm5lckhUTUwiLCJfX2h0bWwiLCJ0ZXh0Q29udGVudCIsIkFycmF5IiwiaXNBcnJheSIsImpvaW4iLCJvbGRUYWciLCJuZXdUYWciLCJIVE1MRWxlbWVudCIsIm5vbmNlIiwiZ2V0QXR0cmlidXRlIiwiY2xvbmVUYWciLCJjbG9uZU5vZGUiLCJ1cGRhdGVFbGVtZW50cyIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfU1RSSUNUX05FWFRfSEVBRCIsImNvbXBvbmVudHMiLCJoZWFkRWwiLCJxdWVyeVNlbGVjdG9yIiwiaGVhZE1ldGFUYWdzIiwicXVlcnlTZWxlY3RvckFsbCIsIm9sZFRhZ3MiLCJtZXRhQ2hhcnNldCIsInB1c2giLCJpIiwibGVuZ3RoIiwiX2hlYWRUYWdfdGFnTmFtZSIsIm1ldGFUYWciLCJoZWFkVGFnIiwibmV4dFNpYmxpbmciLCJ0YWdOYW1lIiwibmV3VGFncyIsIm1hcCIsImZpbHRlciIsImsiLCJsZW4iLCJzcGxpY2UiLCJmb3JFYWNoIiwidCIsIl90X3BhcmVudE5vZGUiLCJwcmV2aW91c1NpYmxpbmciLCJfdF9wYXJlbnROb2RlMSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsIl90X3RhZ05hbWUiLCJtZXRhIiwiY29udGVudCIsImFwcGVuZENoaWxkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJoZWFkQ291bnRFbCIsImNvbnNvbGUiLCJlcnJvciIsImhlYWRDb3VudCIsIk51bWJlciIsImoiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwiX2pfdGFnTmFtZSIsImluc2VydEJlZm9yZSIsInRvU3RyaW5nIiwibW91bnRlZEluc3RhbmNlcyIsIlNldCIsInVwZGF0ZUhlYWQiLCJoZWFkIiwidGFncyIsImgiLCJocmVmIiwidGl0bGVDb21wb25lbnQiLCJ0aXRsZSIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/head-manager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    requestIdleCallback: function() {\n        return requestIdleCallback;\n    },\n    cancelIdleCallback: function() {\n        return cancelIdleCallback;\n    }\n});\nconst requestIdleCallback = typeof self !== \"undefined\" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    let start = Date.now();\n    return self.setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nconst cancelIdleCallback = typeof self !== \"undefined\" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=request-idle-callback.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcscUJBQXFCO1FBQ2pCLE9BQU9BO0lBQ1g7SUFDQUMsb0JBQW9CO1FBQ2hCLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1ELHNCQUFzQixPQUFPUSxTQUFTLGVBQWVBLEtBQUtSLG1CQUFtQixJQUFJUSxLQUFLUixtQkFBbUIsQ0FBQ1MsSUFBSSxDQUFDQyxXQUFXLFNBQVNDLEVBQUU7SUFDdkksSUFBSUMsUUFBUUMsS0FBS0MsR0FBRztJQUNwQixPQUFPTixLQUFLTyxVQUFVLENBQUM7UUFDbkJKLEdBQUc7WUFDQ0ssWUFBWTtZQUNaQyxlQUFlO2dCQUNYLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLEtBQU1OLENBQUFBLEtBQUtDLEdBQUcsS0FBS0YsS0FBSTtZQUM5QztRQUNKO0lBQ0osR0FBRztBQUNQO0FBQ0EsTUFBTVgscUJBQXFCLE9BQU9PLFNBQVMsZUFBZUEsS0FBS1Asa0JBQWtCLElBQUlPLEtBQUtQLGtCQUFrQixDQUFDUSxJQUFJLENBQUNDLFdBQVcsU0FBU1UsRUFBRTtJQUNwSSxPQUFPQyxhQUFhRDtBQUN4QjtBQUVBLElBQUksQ0FBQyxPQUFPdkIsUUFBUXlCLE9BQU8sS0FBSyxjQUFlLE9BQU96QixRQUFReUIsT0FBTyxLQUFLLFlBQVl6QixRQUFReUIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPekIsUUFBUXlCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcks1QixPQUFPQyxjQUFjLENBQUNDLFFBQVF5QixPQUFPLEVBQUUsY0FBYztRQUFFeEIsT0FBTztJQUFLO0lBQ25FSCxPQUFPNkIsTUFBTSxDQUFDM0IsUUFBUXlCLE9BQU8sRUFBRXpCO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLFFBQVF5QixPQUFPO0FBQ2xDLEVBRUEsaURBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcz8xZTIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcmVxdWVzdElkbGVDYWxsYmFjazogbnVsbCxcbiAgICBjYW5jZWxJZGxlQ2FsbGJhY2s6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgcmVxdWVzdElkbGVDYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0SWRsZUNhbGxiYWNrO1xuICAgIH0sXG4gICAgY2FuY2VsSWRsZUNhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNhbmNlbElkbGVDYWxsYmFjaztcbiAgICB9XG59KTtcbmNvbnN0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgPSB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnJlcXVlc3RJZGxlQ2FsbGJhY2sgJiYgc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSB8fCBmdW5jdGlvbihjYikge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIHNlbGYuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgY2Ioe1xuICAgICAgICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICAgICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgNTAgLSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIDEpO1xufTtcbmNvbnN0IGNhbmNlbElkbGVDYWxsYmFjayA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSB8fCBmdW5jdGlvbihpZCkge1xuICAgIHJldHVybiBjbGVhclRpbWVvdXQoaWQpO1xufTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdC1pZGxlLWNhbGxiYWNrLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJzZWxmIiwiYmluZCIsIndpbmRvdyIsImNiIiwic3RhcnQiLCJEYXRlIiwibm93Iiwic2V0VGltZW91dCIsImRpZFRpbWVvdXQiLCJ0aW1lUmVtYWluaW5nIiwiTWF0aCIsIm1heCIsImlkIiwiY2xlYXJUaW1lb3V0IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/script.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/script.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    handleClientScriptLoad: function() {\n        return handleClientScriptLoad;\n    },\n    initScriptLoader: function() {\n        return initScriptLoader;\n    },\n    default: function() {\n        return _default;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ../shared/lib/head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _headmanager = __webpack_require__(/*! ./head-manager */ \"(app-pages-browser)/./node_modules/next/dist/client/head-manager.js\");\nconst _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\");\nconst ScriptCache = new Map();\nconst LoadCache = new Set();\nconst ignoreProps = [\n    \"onLoad\",\n    \"onReady\",\n    \"dangerouslySetInnerHTML\",\n    \"children\",\n    \"onError\",\n    \"strategy\",\n    \"stylesheets\"\n];\nconst insertStylesheets = (stylesheets)=>{\n    // Case 1: Styles for afterInteractive/lazyOnload with appDir injected via handleClientScriptLoad\n    //\n    // Using ReactDOM.preinit to feature detect appDir and inject styles\n    // Stylesheets might have already been loaded if initialized with Script component\n    // Re-inject styles here to handle scripts loaded via handleClientScriptLoad\n    // ReactDOM.preinit handles dedup and ensures the styles are loaded only once\n    if (_reactdom.default.preinit) {\n        stylesheets.forEach((stylesheet)=>{\n            _reactdom.default.preinit(stylesheet, {\n                as: \"style\"\n            });\n        });\n        return;\n    }\n    // Case 2: Styles for afterInteractive/lazyOnload with pages injected via handleClientScriptLoad\n    //\n    // We use this function to load styles when appdir is not detected\n    // TODO: Use React float APIs to load styles once available for pages dir\n    if (true) {\n        let head = document.head;\n        stylesheets.forEach((stylesheet)=>{\n            let link = document.createElement(\"link\");\n            link.type = \"text/css\";\n            link.rel = \"stylesheet\";\n            link.href = stylesheet;\n            head.appendChild(link);\n        });\n    }\n};\nconst loadScript = (props)=>{\n    const { src, id, onLoad = ()=>{}, onReady = null, dangerouslySetInnerHTML, children = \"\", strategy = \"afterInteractive\", onError, stylesheets } = props;\n    const cacheKey = id || src;\n    // Script has already loaded\n    if (cacheKey && LoadCache.has(cacheKey)) {\n        return;\n    }\n    // Contents of this script are already loading/loaded\n    if (ScriptCache.has(src)) {\n        LoadCache.add(cacheKey);\n        // It is possible that multiple `next/script` components all have same \"src\", but has different \"onLoad\"\n        // This is to make sure the same remote script will only load once, but \"onLoad\" are executed in order\n        ScriptCache.get(src).then(onLoad, onError);\n        return;\n    }\n    /** Execute after the script first loaded */ const afterLoad = ()=>{\n        // Run onReady for the first time after load event\n        if (onReady) {\n            onReady();\n        }\n        // add cacheKey to LoadCache when load successfully\n        LoadCache.add(cacheKey);\n    };\n    const el = document.createElement(\"script\");\n    const loadPromise = new Promise((resolve, reject)=>{\n        el.addEventListener(\"load\", function(e) {\n            resolve();\n            if (onLoad) {\n                onLoad.call(this, e);\n            }\n            afterLoad();\n        });\n        el.addEventListener(\"error\", function(e) {\n            reject(e);\n        });\n    }).catch(function(e) {\n        if (onError) {\n            onError(e);\n        }\n    });\n    if (dangerouslySetInnerHTML) {\n        // Casting since lib.dom.d.ts doesn't have TrustedHTML yet.\n        el.innerHTML = dangerouslySetInnerHTML.__html || \"\";\n        afterLoad();\n    } else if (children) {\n        el.textContent = typeof children === \"string\" ? children : Array.isArray(children) ? children.join(\"\") : \"\";\n        afterLoad();\n    } else if (src) {\n        el.src = src;\n        // do not add cacheKey into LoadCache for remote script here\n        // cacheKey will be added to LoadCache when it is actually loaded (see loadPromise above)\n        ScriptCache.set(src, loadPromise);\n    }\n    for (const [k, value] of Object.entries(props)){\n        if (value === undefined || ignoreProps.includes(k)) {\n            continue;\n        }\n        const attr = _headmanager.DOMAttributeNames[k] || k.toLowerCase();\n        el.setAttribute(attr, value);\n    }\n    if (strategy === \"worker\") {\n        el.setAttribute(\"type\", \"text/partytown\");\n    }\n    el.setAttribute(\"data-nscript\", strategy);\n    // Load styles associated with this script\n    if (stylesheets) {\n        insertStylesheets(stylesheets);\n    }\n    document.body.appendChild(el);\n};\nfunction handleClientScriptLoad(props) {\n    const { strategy = \"afterInteractive\" } = props;\n    if (strategy === \"lazyOnload\") {\n        window.addEventListener(\"load\", ()=>{\n            (0, _requestidlecallback.requestIdleCallback)(()=>loadScript(props));\n        });\n    } else {\n        loadScript(props);\n    }\n}\nfunction loadLazyScript(props) {\n    if (document.readyState === \"complete\") {\n        (0, _requestidlecallback.requestIdleCallback)(()=>loadScript(props));\n    } else {\n        window.addEventListener(\"load\", ()=>{\n            (0, _requestidlecallback.requestIdleCallback)(()=>loadScript(props));\n        });\n    }\n}\nfunction addBeforeInteractiveToCache() {\n    const scripts = [\n        ...document.querySelectorAll('[data-nscript=\"beforeInteractive\"]'),\n        ...document.querySelectorAll('[data-nscript=\"beforePageRender\"]')\n    ];\n    scripts.forEach((script)=>{\n        const cacheKey = script.id || script.getAttribute(\"src\");\n        LoadCache.add(cacheKey);\n    });\n}\nfunction initScriptLoader(scriptLoaderItems) {\n    scriptLoaderItems.forEach(handleClientScriptLoad);\n    addBeforeInteractiveToCache();\n}\nfunction Script(props) {\n    const { id, src = \"\", onLoad = ()=>{}, onReady = null, strategy = \"afterInteractive\", onError, stylesheets, ...restProps } = props;\n    // Context is available only during SSR\n    const { updateScripts, scripts, getIsSsr, appDir, nonce } = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);\n    /**\n   * - First mount:\n   *   1. The useEffect for onReady executes\n   *   2. hasOnReadyEffectCalled.current is false, but the script hasn't loaded yet (not in LoadCache)\n   *      onReady is skipped, set hasOnReadyEffectCalled.current to true\n   *   3. The useEffect for loadScript executes\n   *   4. hasLoadScriptEffectCalled.current is false, loadScript executes\n   *      Once the script is loaded, the onLoad and onReady will be called by then\n   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n   *   5. The useEffect for onReady executes again\n   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n   *   7. The useEffect for loadScript executes again\n   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n   *\n   * - Second mount:\n   *   1. The useEffect for onReady executes\n   *   2. hasOnReadyEffectCalled.current is false, but the script has already loaded (found in LoadCache)\n   *      onReady is called, set hasOnReadyEffectCalled.current to true\n   *   3. The useEffect for loadScript executes\n   *   4. The script is already loaded, loadScript bails out\n   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n   *   5. The useEffect for onReady executes again\n   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n   *   7. The useEffect for loadScript executes again\n   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n   */ const hasOnReadyEffectCalled = (0, _react.useRef)(false);\n    (0, _react.useEffect)(()=>{\n        const cacheKey = id || src;\n        if (!hasOnReadyEffectCalled.current) {\n            // Run onReady if script has loaded before but component is re-mounted\n            if (onReady && cacheKey && LoadCache.has(cacheKey)) {\n                onReady();\n            }\n            hasOnReadyEffectCalled.current = true;\n        }\n    }, [\n        onReady,\n        id,\n        src\n    ]);\n    const hasLoadScriptEffectCalled = (0, _react.useRef)(false);\n    (0, _react.useEffect)(()=>{\n        if (!hasLoadScriptEffectCalled.current) {\n            if (strategy === \"afterInteractive\") {\n                loadScript(props);\n            } else if (strategy === \"lazyOnload\") {\n                loadLazyScript(props);\n            }\n            hasLoadScriptEffectCalled.current = true;\n        }\n    }, [\n        props,\n        strategy\n    ]);\n    if (strategy === \"beforeInteractive\" || strategy === \"worker\") {\n        if (updateScripts) {\n            scripts[strategy] = (scripts[strategy] || []).concat([\n                {\n                    id,\n                    src,\n                    onLoad,\n                    onReady,\n                    onError,\n                    ...restProps\n                }\n            ]);\n            updateScripts(scripts);\n        } else if (getIsSsr && getIsSsr()) {\n            // Script has already loaded during SSR\n            LoadCache.add(id || src);\n        } else if (getIsSsr && !getIsSsr()) {\n            loadScript(props);\n        }\n    }\n    // For the app directory, we need React Float to preload these scripts.\n    if (appDir) {\n        // Injecting stylesheets here handles beforeInteractive and worker scripts correctly\n        // For other strategies injecting here ensures correct stylesheet order\n        // ReactDOM.preinit handles loading the styles in the correct order,\n        // also ensures the stylesheet is loaded only once and in a consistent manner\n        //\n        // Case 1: Styles for beforeInteractive/worker with appDir - handled here\n        // Case 2: Styles for beforeInteractive/worker with pages dir - Not handled yet\n        // Case 3: Styles for afterInteractive/lazyOnload with appDir - handled here\n        // Case 4: Styles for afterInteractive/lazyOnload with pages dir - handled in insertStylesheets function\n        if (stylesheets) {\n            stylesheets.forEach((styleSrc)=>{\n                _reactdom.default.preinit(styleSrc, {\n                    as: \"style\"\n                });\n            });\n        }\n        // Before interactive scripts need to be loaded by Next.js' runtime instead\n        // of native <script> tags, because they no longer have `defer`.\n        if (strategy === \"beforeInteractive\") {\n            if (!src) {\n                // For inlined scripts, we put the content in `children`.\n                if (restProps.dangerouslySetInnerHTML) {\n                    // Casting since lib.dom.d.ts doesn't have TrustedHTML yet.\n                    restProps.children = restProps.dangerouslySetInnerHTML.__html;\n                    delete restProps.dangerouslySetInnerHTML;\n                }\n                return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"script\", {\n                    nonce: nonce,\n                    dangerouslySetInnerHTML: {\n                        __html: \"(self.__next_s=self.__next_s||[]).push(\" + JSON.stringify([\n                            0,\n                            {\n                                ...restProps,\n                                id\n                            }\n                        ]) + \")\"\n                    }\n                });\n            } else {\n                // @ts-ignore\n                _reactdom.default.preload(src, restProps.integrity ? {\n                    as: \"script\",\n                    integrity: restProps.integrity\n                } : {\n                    as: \"script\"\n                });\n                return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"script\", {\n                    nonce: nonce,\n                    dangerouslySetInnerHTML: {\n                        __html: \"(self.__next_s=self.__next_s||[]).push(\" + JSON.stringify([\n                            src,\n                            {\n                                ...restProps,\n                                id\n                            }\n                        ]) + \")\"\n                    }\n                });\n            }\n        } else if (strategy === \"afterInteractive\") {\n            if (src) {\n                // @ts-ignore\n                _reactdom.default.preload(src, restProps.integrity ? {\n                    as: \"script\",\n                    integrity: restProps.integrity\n                } : {\n                    as: \"script\"\n                });\n            }\n        }\n    }\n    return null;\n}\n_c = Script;\nObject.defineProperty(Script, \"__nextScript\", {\n    value: true\n});\nconst _default = Script;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=script.js.map\nvar _c;\n$RefreshReg$(_c, \"Script\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3NjcmlwdC5qcyIsIm1hcHBpbmdzIjoicURBRWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FJTjtBQUNBLFNBQVNJLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlWLE9BQU9DLGNBQWMsQ0FBQ1EsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTixTQUFTO0lBQ2JHLHdCQUF3QjtRQUNwQixPQUFPQTtJQUNYO0lBQ0FDLGtCQUFrQjtRQUNkLE9BQU9BO0lBQ1g7SUFDQUMsU0FBUztRQUNMLE9BQU9PO0lBQ1g7QUFDSjtBQUNBLE1BQU1DLDJCQUEyQkMsbUJBQU9BLENBQUMsZ0lBQXlDO0FBQ2xGLE1BQU1DLDRCQUE0QkQsbUJBQU9BLENBQUMsa0lBQTBDO0FBQ3BGLE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLHFHQUFtQjtBQUMvQyxNQUFNRyxZQUFZLFdBQVcsR0FBR0oseUJBQXlCSyxDQUFDLENBQUNKLG1CQUFPQSxDQUFDLDJGQUFXO0FBQzlFLE1BQU1LLFNBQVMsV0FBVyxHQUFHSiwwQkFBMEJHLENBQUMsQ0FBQ0osbUJBQU9BLENBQUMsbUZBQU87QUFDeEUsTUFBTU0sbUNBQW1DTixtQkFBT0EsQ0FBQyx5SkFBbUQ7QUFDcEcsTUFBTU8sZUFBZVAsbUJBQU9BLENBQUMsMkZBQWdCO0FBQzdDLE1BQU1RLHVCQUF1QlIsbUJBQU9BLENBQUMsNkdBQXlCO0FBQzlELE1BQU1TLGNBQWMsSUFBSUM7QUFDeEIsTUFBTUMsWUFBWSxJQUFJQztBQUN0QixNQUFNQyxjQUFjO0lBQ2hCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRCxNQUFNQyxvQkFBb0IsQ0FBQ0M7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QUFRSyxPQUFPLENBQUMyRyxVQUFVLEtBQUssYUFBYTtJQUNyS2xILE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUssT0FBTyxFQUFFLGNBQWM7UUFBRUosT0FBTztJQUFLO0lBQ25FSCxPQUFPbUgsTUFBTSxDQUFDakgsUUFBUUssT0FBTyxFQUFFTDtJQUMvQkUsT0FBT0YsT0FBTyxHQUFHQSxRQUFRSyxPQUFPO0FBQ2xDLEVBRUEsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3NjcmlwdC5qcz9iZDZhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGhhbmRsZUNsaWVudFNjcmlwdExvYWQ6IG51bGwsXG4gICAgaW5pdFNjcmlwdExvYWRlcjogbnVsbCxcbiAgICBkZWZhdWx0OiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGhhbmRsZUNsaWVudFNjcmlwdExvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlQ2xpZW50U2NyaXB0TG9hZDtcbiAgICB9LFxuICAgIGluaXRTY3JpcHRMb2FkZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaW5pdFNjcmlwdExvYWRlcjtcbiAgICB9LFxuICAgIGRlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2RlZmF1bHQ7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkXCIpO1xuY29uc3QgX2pzeHJ1bnRpbWUgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG5jb25zdCBfcmVhY3Rkb20gPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJyZWFjdC1kb21cIikpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IF9oZWFkbWFuYWdlcmNvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaGVhZC1tYW5hZ2VyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWVcIik7XG5jb25zdCBfaGVhZG1hbmFnZXIgPSByZXF1aXJlKFwiLi9oZWFkLW1hbmFnZXJcIik7XG5jb25zdCBfcmVxdWVzdGlkbGVjYWxsYmFjayA9IHJlcXVpcmUoXCIuL3JlcXVlc3QtaWRsZS1jYWxsYmFja1wiKTtcbmNvbnN0IFNjcmlwdENhY2hlID0gbmV3IE1hcCgpO1xuY29uc3QgTG9hZENhY2hlID0gbmV3IFNldCgpO1xuY29uc3QgaWdub3JlUHJvcHMgPSBbXG4gICAgXCJvbkxvYWRcIixcbiAgICBcIm9uUmVhZHlcIixcbiAgICBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIsXG4gICAgXCJjaGlsZHJlblwiLFxuICAgIFwib25FcnJvclwiLFxuICAgIFwic3RyYXRlZ3lcIixcbiAgICBcInN0eWxlc2hlZXRzXCJcbl07XG5jb25zdCBpbnNlcnRTdHlsZXNoZWV0cyA9IChzdHlsZXNoZWV0cyk9PntcbiAgICAvLyBDYXNlIDE6IFN0eWxlcyBmb3IgYWZ0ZXJJbnRlcmFjdGl2ZS9sYXp5T25sb2FkIHdpdGggYXBwRGlyIGluamVjdGVkIHZpYSBoYW5kbGVDbGllbnRTY3JpcHRMb2FkXG4gICAgLy9cbiAgICAvLyBVc2luZyBSZWFjdERPTS5wcmVpbml0IHRvIGZlYXR1cmUgZGV0ZWN0IGFwcERpciBhbmQgaW5qZWN0IHN0eWxlc1xuICAgIC8vIFN0eWxlc2hlZXRzIG1pZ2h0IGhhdmUgYWxyZWFkeSBiZWVuIGxvYWRlZCBpZiBpbml0aWFsaXplZCB3aXRoIFNjcmlwdCBjb21wb25lbnRcbiAgICAvLyBSZS1pbmplY3Qgc3R5bGVzIGhlcmUgdG8gaGFuZGxlIHNjcmlwdHMgbG9hZGVkIHZpYSBoYW5kbGVDbGllbnRTY3JpcHRMb2FkXG4gICAgLy8gUmVhY3RET00ucHJlaW5pdCBoYW5kbGVzIGRlZHVwIGFuZCBlbnN1cmVzIHRoZSBzdHlsZXMgYXJlIGxvYWRlZCBvbmx5IG9uY2VcbiAgICBpZiAoX3JlYWN0ZG9tLmRlZmF1bHQucHJlaW5pdCkge1xuICAgICAgICBzdHlsZXNoZWV0cy5mb3JFYWNoKChzdHlsZXNoZWV0KT0+e1xuICAgICAgICAgICAgX3JlYWN0ZG9tLmRlZmF1bHQucHJlaW5pdChzdHlsZXNoZWV0LCB7XG4gICAgICAgICAgICAgICAgYXM6IFwic3R5bGVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENhc2UgMjogU3R5bGVzIGZvciBhZnRlckludGVyYWN0aXZlL2xhenlPbmxvYWQgd2l0aCBwYWdlcyBpbmplY3RlZCB2aWEgaGFuZGxlQ2xpZW50U2NyaXB0TG9hZFxuICAgIC8vXG4gICAgLy8gV2UgdXNlIHRoaXMgZnVuY3Rpb24gdG8gbG9hZCBzdHlsZXMgd2hlbiBhcHBkaXIgaXMgbm90IGRldGVjdGVkXG4gICAgLy8gVE9ETzogVXNlIFJlYWN0IGZsb2F0IEFQSXMgdG8gbG9hZCBzdHlsZXMgb25jZSBhdmFpbGFibGUgZm9yIHBhZ2VzIGRpclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGxldCBoZWFkID0gZG9jdW1lbnQuaGVhZDtcbiAgICAgICAgc3R5bGVzaGVldHMuZm9yRWFjaCgoc3R5bGVzaGVldCk9PntcbiAgICAgICAgICAgIGxldCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgICAgICAgICBsaW5rLnR5cGUgPSBcInRleHQvY3NzXCI7XG4gICAgICAgICAgICBsaW5rLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuICAgICAgICAgICAgbGluay5ocmVmID0gc3R5bGVzaGVldDtcbiAgICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5jb25zdCBsb2FkU2NyaXB0ID0gKHByb3BzKT0+e1xuICAgIGNvbnN0IHsgc3JjLCBpZCwgb25Mb2FkID0gKCk9Pnt9LCBvblJlYWR5ID0gbnVsbCwgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsIGNoaWxkcmVuID0gXCJcIiwgc3RyYXRlZ3kgPSBcImFmdGVySW50ZXJhY3RpdmVcIiwgb25FcnJvciwgc3R5bGVzaGVldHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gaWQgfHwgc3JjO1xuICAgIC8vIFNjcmlwdCBoYXMgYWxyZWFkeSBsb2FkZWRcbiAgICBpZiAoY2FjaGVLZXkgJiYgTG9hZENhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDb250ZW50cyBvZiB0aGlzIHNjcmlwdCBhcmUgYWxyZWFkeSBsb2FkaW5nL2xvYWRlZFxuICAgIGlmIChTY3JpcHRDYWNoZS5oYXMoc3JjKSkge1xuICAgICAgICBMb2FkQ2FjaGUuYWRkKGNhY2hlS2V5KTtcbiAgICAgICAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCBtdWx0aXBsZSBgbmV4dC9zY3JpcHRgIGNvbXBvbmVudHMgYWxsIGhhdmUgc2FtZSBcInNyY1wiLCBidXQgaGFzIGRpZmZlcmVudCBcIm9uTG9hZFwiXG4gICAgICAgIC8vIFRoaXMgaXMgdG8gbWFrZSBzdXJlIHRoZSBzYW1lIHJlbW90ZSBzY3JpcHQgd2lsbCBvbmx5IGxvYWQgb25jZSwgYnV0IFwib25Mb2FkXCIgYXJlIGV4ZWN1dGVkIGluIG9yZGVyXG4gICAgICAgIFNjcmlwdENhY2hlLmdldChzcmMpLnRoZW4ob25Mb2FkLCBvbkVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKiogRXhlY3V0ZSBhZnRlciB0aGUgc2NyaXB0IGZpcnN0IGxvYWRlZCAqLyBjb25zdCBhZnRlckxvYWQgPSAoKT0+e1xuICAgICAgICAvLyBSdW4gb25SZWFkeSBmb3IgdGhlIGZpcnN0IHRpbWUgYWZ0ZXIgbG9hZCBldmVudFxuICAgICAgICBpZiAob25SZWFkeSkge1xuICAgICAgICAgICAgb25SZWFkeSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBjYWNoZUtleSB0byBMb2FkQ2FjaGUgd2hlbiBsb2FkIHN1Y2Nlc3NmdWxseVxuICAgICAgICBMb2FkQ2FjaGUuYWRkKGNhY2hlS2V5KTtcbiAgICB9O1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICBjb25zdCBsb2FkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIGlmIChvbkxvYWQpIHtcbiAgICAgICAgICAgICAgICBvbkxvYWQuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFmdGVyTG9hZCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgb25FcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChkYW5nZXJvdXNseVNldElubmVySFRNTCkge1xuICAgICAgICAvLyBDYXN0aW5nIHNpbmNlIGxpYi5kb20uZC50cyBkb2Vzbid0IGhhdmUgVHJ1c3RlZEhUTUwgeWV0LlxuICAgICAgICBlbC5pbm5lckhUTUwgPSBkYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWwgfHwgXCJcIjtcbiAgICAgICAgYWZ0ZXJMb2FkKCk7XG4gICAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgICAgICBlbC50ZXh0Q29udGVudCA9IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJzdHJpbmdcIiA/IGNoaWxkcmVuIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5qb2luKFwiXCIpIDogXCJcIjtcbiAgICAgICAgYWZ0ZXJMb2FkKCk7XG4gICAgfSBlbHNlIGlmIChzcmMpIHtcbiAgICAgICAgZWwuc3JjID0gc3JjO1xuICAgICAgICAvLyBkbyBub3QgYWRkIGNhY2hlS2V5IGludG8gTG9hZENhY2hlIGZvciByZW1vdGUgc2NyaXB0IGhlcmVcbiAgICAgICAgLy8gY2FjaGVLZXkgd2lsbCBiZSBhZGRlZCB0byBMb2FkQ2FjaGUgd2hlbiBpdCBpcyBhY3R1YWxseSBsb2FkZWQgKHNlZSBsb2FkUHJvbWlzZSBhYm92ZSlcbiAgICAgICAgU2NyaXB0Q2FjaGUuc2V0KHNyYywgbG9hZFByb21pc2UpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKXtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgaWdub3JlUHJvcHMuaW5jbHVkZXMoaykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHIgPSBfaGVhZG1hbmFnZXIuRE9NQXR0cmlidXRlTmFtZXNba10gfHwgay50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAoc3RyYXRlZ3kgPT09IFwid29ya2VyXCIpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInRleHQvcGFydHl0b3duXCIpO1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLW5zY3JpcHRcIiwgc3RyYXRlZ3kpO1xuICAgIC8vIExvYWQgc3R5bGVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNjcmlwdFxuICAgIGlmIChzdHlsZXNoZWV0cykge1xuICAgICAgICBpbnNlcnRTdHlsZXNoZWV0cyhzdHlsZXNoZWV0cyk7XG4gICAgfVxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xufTtcbmZ1bmN0aW9uIGhhbmRsZUNsaWVudFNjcmlwdExvYWQocHJvcHMpIHtcbiAgICBjb25zdCB7IHN0cmF0ZWd5ID0gXCJhZnRlckludGVyYWN0aXZlXCIgfSA9IHByb3BzO1xuICAgIGlmIChzdHJhdGVneSA9PT0gXCJsYXp5T25sb2FkXCIpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpPT57XG4gICAgICAgICAgICAoMCwgX3JlcXVlc3RpZGxlY2FsbGJhY2sucmVxdWVzdElkbGVDYWxsYmFjaykoKCk9PmxvYWRTY3JpcHQocHJvcHMpKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbG9hZFNjcmlwdChwcm9wcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbG9hZExhenlTY3JpcHQocHJvcHMpIHtcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICgwLCBfcmVxdWVzdGlkbGVjYWxsYmFjay5yZXF1ZXN0SWRsZUNhbGxiYWNrKSgoKT0+bG9hZFNjcmlwdChwcm9wcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKT0+e1xuICAgICAgICAgICAgKDAsIF9yZXF1ZXN0aWRsZWNhbGxiYWNrLnJlcXVlc3RJZGxlQ2FsbGJhY2spKCgpPT5sb2FkU2NyaXB0KHByb3BzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZEJlZm9yZUludGVyYWN0aXZlVG9DYWNoZSgpIHtcbiAgICBjb25zdCBzY3JpcHRzID0gW1xuICAgICAgICAuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1uc2NyaXB0PVwiYmVmb3JlSW50ZXJhY3RpdmVcIl0nKSxcbiAgICAgICAgLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbnNjcmlwdD1cImJlZm9yZVBhZ2VSZW5kZXJcIl0nKVxuICAgIF07XG4gICAgc2NyaXB0cy5mb3JFYWNoKChzY3JpcHQpPT57XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gc2NyaXB0LmlkIHx8IHNjcmlwdC5nZXRBdHRyaWJ1dGUoXCJzcmNcIik7XG4gICAgICAgIExvYWRDYWNoZS5hZGQoY2FjaGVLZXkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5pdFNjcmlwdExvYWRlcihzY3JpcHRMb2FkZXJJdGVtcykge1xuICAgIHNjcmlwdExvYWRlckl0ZW1zLmZvckVhY2goaGFuZGxlQ2xpZW50U2NyaXB0TG9hZCk7XG4gICAgYWRkQmVmb3JlSW50ZXJhY3RpdmVUb0NhY2hlKCk7XG59XG5mdW5jdGlvbiBTY3JpcHQocHJvcHMpIHtcbiAgICBjb25zdCB7IGlkLCBzcmMgPSBcIlwiLCBvbkxvYWQgPSAoKT0+e30sIG9uUmVhZHkgPSBudWxsLCBzdHJhdGVneSA9IFwiYWZ0ZXJJbnRlcmFjdGl2ZVwiLCBvbkVycm9yLCBzdHlsZXNoZWV0cywgLi4ucmVzdFByb3BzIH0gPSBwcm9wcztcbiAgICAvLyBDb250ZXh0IGlzIGF2YWlsYWJsZSBvbmx5IGR1cmluZyBTU1JcbiAgICBjb25zdCB7IHVwZGF0ZVNjcmlwdHMsIHNjcmlwdHMsIGdldElzU3NyLCBhcHBEaXIsIG5vbmNlIH0gPSAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKF9oZWFkbWFuYWdlcmNvbnRleHRzaGFyZWRydW50aW1lLkhlYWRNYW5hZ2VyQ29udGV4dCk7XG4gICAgLyoqXG4gICAqIC0gRmlyc3QgbW91bnQ6XG4gICAqICAgMS4gVGhlIHVzZUVmZmVjdCBmb3Igb25SZWFkeSBleGVjdXRlc1xuICAgKiAgIDIuIGhhc09uUmVhZHlFZmZlY3RDYWxsZWQuY3VycmVudCBpcyBmYWxzZSwgYnV0IHRoZSBzY3JpcHQgaGFzbid0IGxvYWRlZCB5ZXQgKG5vdCBpbiBMb2FkQ2FjaGUpXG4gICAqICAgICAgb25SZWFkeSBpcyBza2lwcGVkLCBzZXQgaGFzT25SZWFkeUVmZmVjdENhbGxlZC5jdXJyZW50IHRvIHRydWVcbiAgICogICAzLiBUaGUgdXNlRWZmZWN0IGZvciBsb2FkU2NyaXB0IGV4ZWN1dGVzXG4gICAqICAgNC4gaGFzTG9hZFNjcmlwdEVmZmVjdENhbGxlZC5jdXJyZW50IGlzIGZhbHNlLCBsb2FkU2NyaXB0IGV4ZWN1dGVzXG4gICAqICAgICAgT25jZSB0aGUgc2NyaXB0IGlzIGxvYWRlZCwgdGhlIG9uTG9hZCBhbmQgb25SZWFkeSB3aWxsIGJlIGNhbGxlZCBieSB0aGVuXG4gICAqICAgW0lmIHN0cmljdCBtb2RlIGlzIGVuYWJsZWQgLyBpcyB3cmFwcGVkIGluIDxPZmZTY3JlZW4gLz4gY29tcG9uZW50XVxuICAgKiAgIDUuIFRoZSB1c2VFZmZlY3QgZm9yIG9uUmVhZHkgZXhlY3V0ZXMgYWdhaW5cbiAgICogICA2LiBoYXNPblJlYWR5RWZmZWN0Q2FsbGVkLmN1cnJlbnQgaXMgdHJ1ZSwgc28gZW50aXJlIGVmZmVjdCBpcyBza2lwcGVkXG4gICAqICAgNy4gVGhlIHVzZUVmZmVjdCBmb3IgbG9hZFNjcmlwdCBleGVjdXRlcyBhZ2FpblxuICAgKiAgIDguIGhhc0xvYWRTY3JpcHRFZmZlY3RDYWxsZWQuY3VycmVudCBpcyB0cnVlLCBzbyBlbnRpcmUgZWZmZWN0IGlzIHNraXBwZWRcbiAgICpcbiAgICogLSBTZWNvbmQgbW91bnQ6XG4gICAqICAgMS4gVGhlIHVzZUVmZmVjdCBmb3Igb25SZWFkeSBleGVjdXRlc1xuICAgKiAgIDIuIGhhc09uUmVhZHlFZmZlY3RDYWxsZWQuY3VycmVudCBpcyBmYWxzZSwgYnV0IHRoZSBzY3JpcHQgaGFzIGFscmVhZHkgbG9hZGVkIChmb3VuZCBpbiBMb2FkQ2FjaGUpXG4gICAqICAgICAgb25SZWFkeSBpcyBjYWxsZWQsIHNldCBoYXNPblJlYWR5RWZmZWN0Q2FsbGVkLmN1cnJlbnQgdG8gdHJ1ZVxuICAgKiAgIDMuIFRoZSB1c2VFZmZlY3QgZm9yIGxvYWRTY3JpcHQgZXhlY3V0ZXNcbiAgICogICA0LiBUaGUgc2NyaXB0IGlzIGFscmVhZHkgbG9hZGVkLCBsb2FkU2NyaXB0IGJhaWxzIG91dFxuICAgKiAgIFtJZiBzdHJpY3QgbW9kZSBpcyBlbmFibGVkIC8gaXMgd3JhcHBlZCBpbiA8T2ZmU2NyZWVuIC8+IGNvbXBvbmVudF1cbiAgICogICA1LiBUaGUgdXNlRWZmZWN0IGZvciBvblJlYWR5IGV4ZWN1dGVzIGFnYWluXG4gICAqICAgNi4gaGFzT25SZWFkeUVmZmVjdENhbGxlZC5jdXJyZW50IGlzIHRydWUsIHNvIGVudGlyZSBlZmZlY3QgaXMgc2tpcHBlZFxuICAgKiAgIDcuIFRoZSB1c2VFZmZlY3QgZm9yIGxvYWRTY3JpcHQgZXhlY3V0ZXMgYWdhaW5cbiAgICogICA4LiBoYXNMb2FkU2NyaXB0RWZmZWN0Q2FsbGVkLmN1cnJlbnQgaXMgdHJ1ZSwgc28gZW50aXJlIGVmZmVjdCBpcyBza2lwcGVkXG4gICAqLyBjb25zdCBoYXNPblJlYWR5RWZmZWN0Q2FsbGVkID0gKDAsIF9yZWFjdC51c2VSZWYpKGZhbHNlKTtcbiAgICAoMCwgX3JlYWN0LnVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBpZCB8fCBzcmM7XG4gICAgICAgIGlmICghaGFzT25SZWFkeUVmZmVjdENhbGxlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICAvLyBSdW4gb25SZWFkeSBpZiBzY3JpcHQgaGFzIGxvYWRlZCBiZWZvcmUgYnV0IGNvbXBvbmVudCBpcyByZS1tb3VudGVkXG4gICAgICAgICAgICBpZiAob25SZWFkeSAmJiBjYWNoZUtleSAmJiBMb2FkQ2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgICAgICAgICAgICAgIG9uUmVhZHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhc09uUmVhZHlFZmZlY3RDYWxsZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIG9uUmVhZHksXG4gICAgICAgIGlkLFxuICAgICAgICBzcmNcbiAgICBdKTtcbiAgICBjb25zdCBoYXNMb2FkU2NyaXB0RWZmZWN0Q2FsbGVkID0gKDAsIF9yZWFjdC51c2VSZWYpKGZhbHNlKTtcbiAgICAoMCwgX3JlYWN0LnVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKCFoYXNMb2FkU2NyaXB0RWZmZWN0Q2FsbGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmIChzdHJhdGVneSA9PT0gXCJhZnRlckludGVyYWN0aXZlXCIpIHtcbiAgICAgICAgICAgICAgICBsb2FkU2NyaXB0KHByb3BzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyYXRlZ3kgPT09IFwibGF6eU9ubG9hZFwiKSB7XG4gICAgICAgICAgICAgICAgbG9hZExhenlTY3JpcHQocHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFzTG9hZFNjcmlwdEVmZmVjdENhbGxlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgXSk7XG4gICAgaWYgKHN0cmF0ZWd5ID09PSBcImJlZm9yZUludGVyYWN0aXZlXCIgfHwgc3RyYXRlZ3kgPT09IFwid29ya2VyXCIpIHtcbiAgICAgICAgaWYgKHVwZGF0ZVNjcmlwdHMpIHtcbiAgICAgICAgICAgIHNjcmlwdHNbc3RyYXRlZ3ldID0gKHNjcmlwdHNbc3RyYXRlZ3ldIHx8IFtdKS5jb25jYXQoW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICAgICAgb25Mb2FkLFxuICAgICAgICAgICAgICAgICAgICBvblJlYWR5LFxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgICAgICAgICAuLi5yZXN0UHJvcHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHVwZGF0ZVNjcmlwdHMoc2NyaXB0cyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ2V0SXNTc3IgJiYgZ2V0SXNTc3IoKSkge1xuICAgICAgICAgICAgLy8gU2NyaXB0IGhhcyBhbHJlYWR5IGxvYWRlZCBkdXJpbmcgU1NSXG4gICAgICAgICAgICBMb2FkQ2FjaGUuYWRkKGlkIHx8IHNyYyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ2V0SXNTc3IgJiYgIWdldElzU3NyKCkpIHtcbiAgICAgICAgICAgIGxvYWRTY3JpcHQocHJvcHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZvciB0aGUgYXBwIGRpcmVjdG9yeSwgd2UgbmVlZCBSZWFjdCBGbG9hdCB0byBwcmVsb2FkIHRoZXNlIHNjcmlwdHMuXG4gICAgaWYgKGFwcERpcikge1xuICAgICAgICAvLyBJbmplY3Rpbmcgc3R5bGVzaGVldHMgaGVyZSBoYW5kbGVzIGJlZm9yZUludGVyYWN0aXZlIGFuZCB3b3JrZXIgc2NyaXB0cyBjb3JyZWN0bHlcbiAgICAgICAgLy8gRm9yIG90aGVyIHN0cmF0ZWdpZXMgaW5qZWN0aW5nIGhlcmUgZW5zdXJlcyBjb3JyZWN0IHN0eWxlc2hlZXQgb3JkZXJcbiAgICAgICAgLy8gUmVhY3RET00ucHJlaW5pdCBoYW5kbGVzIGxvYWRpbmcgdGhlIHN0eWxlcyBpbiB0aGUgY29ycmVjdCBvcmRlcixcbiAgICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoZSBzdHlsZXNoZWV0IGlzIGxvYWRlZCBvbmx5IG9uY2UgYW5kIGluIGEgY29uc2lzdGVudCBtYW5uZXJcbiAgICAgICAgLy9cbiAgICAgICAgLy8gQ2FzZSAxOiBTdHlsZXMgZm9yIGJlZm9yZUludGVyYWN0aXZlL3dvcmtlciB3aXRoIGFwcERpciAtIGhhbmRsZWQgaGVyZVxuICAgICAgICAvLyBDYXNlIDI6IFN0eWxlcyBmb3IgYmVmb3JlSW50ZXJhY3RpdmUvd29ya2VyIHdpdGggcGFnZXMgZGlyIC0gTm90IGhhbmRsZWQgeWV0XG4gICAgICAgIC8vIENhc2UgMzogU3R5bGVzIGZvciBhZnRlckludGVyYWN0aXZlL2xhenlPbmxvYWQgd2l0aCBhcHBEaXIgLSBoYW5kbGVkIGhlcmVcbiAgICAgICAgLy8gQ2FzZSA0OiBTdHlsZXMgZm9yIGFmdGVySW50ZXJhY3RpdmUvbGF6eU9ubG9hZCB3aXRoIHBhZ2VzIGRpciAtIGhhbmRsZWQgaW4gaW5zZXJ0U3R5bGVzaGVldHMgZnVuY3Rpb25cbiAgICAgICAgaWYgKHN0eWxlc2hlZXRzKSB7XG4gICAgICAgICAgICBzdHlsZXNoZWV0cy5mb3JFYWNoKChzdHlsZVNyYyk9PntcbiAgICAgICAgICAgICAgICBfcmVhY3Rkb20uZGVmYXVsdC5wcmVpbml0KHN0eWxlU3JjLCB7XG4gICAgICAgICAgICAgICAgICAgIGFzOiBcInN0eWxlXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJlZm9yZSBpbnRlcmFjdGl2ZSBzY3JpcHRzIG5lZWQgdG8gYmUgbG9hZGVkIGJ5IE5leHQuanMnIHJ1bnRpbWUgaW5zdGVhZFxuICAgICAgICAvLyBvZiBuYXRpdmUgPHNjcmlwdD4gdGFncywgYmVjYXVzZSB0aGV5IG5vIGxvbmdlciBoYXZlIGBkZWZlcmAuXG4gICAgICAgIGlmIChzdHJhdGVneSA9PT0gXCJiZWZvcmVJbnRlcmFjdGl2ZVwiKSB7XG4gICAgICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgICAgIC8vIEZvciBpbmxpbmVkIHNjcmlwdHMsIHdlIHB1dCB0aGUgY29udGVudCBpbiBgY2hpbGRyZW5gLlxuICAgICAgICAgICAgICAgIGlmIChyZXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FzdGluZyBzaW5jZSBsaWIuZG9tLmQudHMgZG9lc24ndCBoYXZlIFRydXN0ZWRIVE1MIHlldC5cbiAgICAgICAgICAgICAgICAgICAgcmVzdFByb3BzLmNoaWxkcmVuID0gcmVzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbDtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoXCJzY3JpcHRcIiwge1xuICAgICAgICAgICAgICAgICAgICBub25jZTogbm9uY2UsXG4gICAgICAgICAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfX2h0bWw6IFwiKHNlbGYuX19uZXh0X3M9c2VsZi5fX25leHRfc3x8W10pLnB1c2goXCIgKyBKU09OLnN0cmluZ2lmeShbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnJlc3RQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBdKSArIFwiKVwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIF9yZWFjdGRvbS5kZWZhdWx0LnByZWxvYWQoc3JjLCByZXN0UHJvcHMuaW50ZWdyaXR5ID8ge1xuICAgICAgICAgICAgICAgICAgICBhczogXCJzY3JpcHRcIixcbiAgICAgICAgICAgICAgICAgICAgaW50ZWdyaXR5OiByZXN0UHJvcHMuaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICAgICAgYXM6IFwic2NyaXB0XCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShcInNjcmlwdFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG5vbmNlOiBub25jZSxcbiAgICAgICAgICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9faHRtbDogXCIoc2VsZi5fX25leHRfcz1zZWxmLl9fbmV4dF9zfHxbXSkucHVzaChcIiArIEpTT04uc3RyaW5naWZ5KFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5yZXN0UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXSkgKyBcIilcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyYXRlZ3kgPT09IFwiYWZ0ZXJJbnRlcmFjdGl2ZVwiKSB7XG4gICAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIF9yZWFjdGRvbS5kZWZhdWx0LnByZWxvYWQoc3JjLCByZXN0UHJvcHMuaW50ZWdyaXR5ID8ge1xuICAgICAgICAgICAgICAgICAgICBhczogXCJzY3JpcHRcIixcbiAgICAgICAgICAgICAgICAgICAgaW50ZWdyaXR5OiByZXN0UHJvcHMuaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICAgICAgYXM6IFwic2NyaXB0XCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY3JpcHQsIFwiX19uZXh0U2NyaXB0XCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5jb25zdCBfZGVmYXVsdCA9IFNjcmlwdDtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NyaXB0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsImhhbmRsZUNsaWVudFNjcmlwdExvYWQiLCJpbml0U2NyaXB0TG9hZGVyIiwiZGVmYXVsdCIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIl9kZWZhdWx0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfanN4cnVudGltZSIsIl9yZWFjdGRvbSIsIl8iLCJfcmVhY3QiLCJfaGVhZG1hbmFnZXJjb250ZXh0c2hhcmVkcnVudGltZSIsIl9oZWFkbWFuYWdlciIsIl9yZXF1ZXN0aWRsZWNhbGxiYWNrIiwiU2NyaXB0Q2FjaGUiLCJNYXAiLCJMb2FkQ2FjaGUiLCJTZXQiLCJpZ25vcmVQcm9wcyIsImluc2VydFN0eWxlc2hlZXRzIiwic3R5bGVzaGVldHMiLCJwcmVpbml0IiwiZm9yRWFjaCIsInN0eWxlc2hlZXQiLCJhcyIsImhlYWQiLCJkb2N1bWVudCIsImxpbmsiLCJjcmVhdGVFbGVtZW50IiwidHlwZSIsInJlbCIsImhyZWYiLCJhcHBlbmRDaGlsZCIsImxvYWRTY3JpcHQiLCJwcm9wcyIsInNyYyIsImlkIiwib25Mb2FkIiwib25SZWFkeSIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiY2hpbGRyZW4iLCJzdHJhdGVneSIsIm9uRXJyb3IiLCJjYWNoZUtleSIsImhhcyIsImFkZCIsInRoZW4iLCJhZnRlckxvYWQiLCJlbCIsImxvYWRQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsImNhbGwiLCJjYXRjaCIsImlubmVySFRNTCIsIl9faHRtbCIsInRleHRDb250ZW50IiwiQXJyYXkiLCJpc0FycmF5Iiwiam9pbiIsInNldCIsImsiLCJlbnRyaWVzIiwidW5kZWZpbmVkIiwiaW5jbHVkZXMiLCJhdHRyIiwiRE9NQXR0cmlidXRlTmFtZXMiLCJ0b0xvd2VyQ2FzZSIsInNldEF0dHJpYnV0ZSIsImJvZHkiLCJ3aW5kb3ciLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwibG9hZExhenlTY3JpcHQiLCJyZWFkeVN0YXRlIiwiYWRkQmVmb3JlSW50ZXJhY3RpdmVUb0NhY2hlIiwic2NyaXB0cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJzY3JpcHQiLCJnZXRBdHRyaWJ1dGUiLCJzY3JpcHRMb2FkZXJJdGVtcyIsIlNjcmlwdCIsInJlc3RQcm9wcyIsInVwZGF0ZVNjcmlwdHMiLCJnZXRJc1NzciIsImFwcERpciIsIm5vbmNlIiwidXNlQ29udGV4dCIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsImhhc09uUmVhZHlFZmZlY3RDYWxsZWQiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJjdXJyZW50IiwiaGFzTG9hZFNjcmlwdEVmZmVjdENhbGxlZCIsImNvbmNhdCIsInN0eWxlU3JjIiwianN4IiwiSlNPTiIsInN0cmluZ2lmeSIsInByZWxvYWQiLCJpbnRlZ3JpdHkiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/script.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js ***!
  \**********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"BailoutToCSR\", ({\n    enumerable: true,\n    get: function() {\n        return BailoutToCSR;\n    }\n}));\nconst _bailouttocsr = __webpack_require__(/*! ./bailout-to-csr */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js\");\nfunction BailoutToCSR(param) {\n    let { reason, children } = param;\n    if (false) {}\n    return children;\n} //# sourceMappingURL=dynamic-bailout-to-csr.js.map\n_c = BailoutToCSR;\nvar _c;\n$RefreshReg$(_c, \"BailoutToCSR\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9sYXp5LWR5bmFtaWMvZHluYW1pYy1iYWlsb3V0LXRvLWNzci5qcyIsIm1hcHBpbmdzIjoicURBRWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILGdEQUErQztJQUMzQ0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLGdCQUFnQkMsbUJBQU9BLENBQUMsZ0hBQWtCO0FBQ2hELFNBQVNGLGFBQWFHLEtBQUs7SUFDdkIsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHRjtJQUMzQixJQUFJLEtBQTZCLEVBQUUsRUFFbEM7SUFDRCxPQUFPRTtBQUNYLEVBRUEsa0RBQWtEO0tBUnpDTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbGF6eS1keW5hbWljL2R5bmFtaWMtYmFpbG91dC10by1jc3IuanM/ZjY5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYWlsb3V0VG9DU1JcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEJhaWxvdXRUb0NTUjtcbiAgICB9XG59KTtcbmNvbnN0IF9iYWlsb3V0dG9jc3IgPSByZXF1aXJlKFwiLi9iYWlsb3V0LXRvLWNzclwiKTtcbmZ1bmN0aW9uIEJhaWxvdXRUb0NTUihwYXJhbSkge1xuICAgIGxldCB7IHJlYXNvbiwgY2hpbGRyZW4gfSA9IHBhcmFtO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBfYmFpbG91dHRvY3NyLkJhaWxvdXRUb0NTUkVycm9yKHJlYXNvbik7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHluYW1pYy1iYWlsb3V0LXRvLWNzci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiQmFpbG91dFRvQ1NSIiwiX2JhaWxvdXR0b2NzciIsInJlcXVpcmUiLCJwYXJhbSIsInJlYXNvbiIsImNoaWxkcmVuIiwiQmFpbG91dFRvQ1NSRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsantoshbaral%2FDocuments%2FREVX%2Fhelpdex%2Fspu-ai%2Fapp%2Fcomponents%2FSpeechSetup.tsx&modules=%2FUsers%2Fsantoshbaral%2FDocuments%2FREVX%2Fhelpdex%2Fspu-ai%2Fapp%2Fpage.client.tsx&modules=%2FUsers%2Fsantoshbaral%2FDocuments%2FREVX%2Fhelpdex%2Fspu-ai%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fscript.js&modules=%2FUsers%2Fsantoshbaral%2FDocuments%2FREVX%2Fhelpdex%2Fspu-ai%2Fnode_modules%2Fnext%2Fdist%2Fshared%2Flib%2Flazy-dynamic%2Fdynamic-bailout-to-csr.js&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);